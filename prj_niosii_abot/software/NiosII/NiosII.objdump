
NiosII.elf:     file format elf32-littlenios2
NiosII.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0041022c

Program Header:
    LOAD off    0x00001000 vaddr 0x00410000 paddr 0x00410000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00410020 paddr 0x00410020 align 2**12
         filesz 0x0000786c memsz 0x0000786c flags r-x
    LOAD off    0x0000888c vaddr 0x0041788c paddr 0x00417d04 align 2**12
         filesz 0x00000478 memsz 0x00000478 flags rw-
    LOAD off    0x0000917c vaddr 0x0041817c paddr 0x0041817c align 2**12
         filesz 0x00000000 memsz 0x000003e8 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00410000  00410000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000020c  00410020  00410020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000074b8  0041022c  0041022c  0000122c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000001a8  004176e4  004176e4  000086e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000478  0041788c  00417d04  0000888c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000003e8  0041817c  0041817c  0000917c  2**2
                  ALLOC, SMALL_DATA
  6 .epcs_flash_controller_0 00000000  00021000  00021000  00008d04  2**0
                  CONTENTS
  7 .onchip_memory2_0 00000000  00418564  00418564  00008d04  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00008d04  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000a38  00000000  00000000  00008d28  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000e5ad  00000000  00000000  00009760  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000052db  00000000  00000000  00017d0d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00005a4b  00000000  00000000  0001cfe8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001e30  00000000  00000000  00022a34  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000309e  00000000  00000000  00024864  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000454a  00000000  00000000  00027902  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000010  00000000  00000000  0002be4c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000720  00000000  00000000  0002be60  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  0002f5ba  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0002f5bd  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0002f5c9  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0002f5ca  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   0000000b  00000000  00000000  0002f5cb  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    0000000b  00000000  00000000  0002f5d6  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   0000000b  00000000  00000000  0002f5e1  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 00000006  00000000  00000000  0002f5ec  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 00000035  00000000  00000000  0002f5f2  2**0
                  CONTENTS, READONLY
 27 .jdi          00003e87  00000000  00000000  0002f627  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     000648b1  00000000  00000000  000334ae  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00410000 l    d  .entry	00000000 .entry
00410020 l    d  .exceptions	00000000 .exceptions
0041022c l    d  .text	00000000 .text
004176e4 l    d  .rodata	00000000 .rodata
0041788c l    d  .rwdata	00000000 .rwdata
0041817c l    d  .bss	00000000 .bss
00021000 l    d  .epcs_flash_controller_0	00000000 .epcs_flash_controller_0
00418564 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../NiosII_Bsp/obj/HAL/src/crt0.o
00410264 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 Ap.c
00000000 l    df *ABS*	00000000 MSP.c
004181c8 l     O .bss	00000043 Cmd
0041820b l     O .bss	00000044 Resp
0041817c l     O .bss	00000001 Cmd_State
0041817d l     O .bss	00000001 Index_Data
00418180 l     O .bss	00000004 CurrentTime
00418184 l     O .bss	00000004 PreviousTime
00418188 l     O .bss	00000001 CmdReceived
0041818a l     O .bss	00000008 RcCmd.2870
00000000 l    df *ABS*	00000000 Hw_ISR.c
00000000 l    df *ABS*	00000000 Hw_Timer.c
00418194 l     O .bss	00000004 Hw_Timer_Counter
00418198 l     O .bss	00000002 Tmr_Ctn
0041819a l     O .bss	00000002 Tmr_HandleIndex
00418250 l     O .bss	000000a0 Timer_Tbl
0041819c l     O .bss	00000001 Excute.2809
00000000 l    df *ABS*	00000000 Hw_Uart.c
00410dc0 l     F .text	000000d8 Hw_Uart_ISR_Handler
00000000 l    df *ABS*	00000000 Hw_Uart_Q.c
00000000 l    df *ABS*	00000000 Hw_Led.c
00000000 l    df *ABS*	00000000 Hw.c
00000000 l    df *ABS*	00000000 Lb_Printf.c
00000000 l    df *ABS*	00000000 Lb_Util.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00411dd4 l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 addsf3.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 subsf3.c
00000000 l    df *ABS*	00000000 fixsfsi.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
0041309c l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 fvwrite_small_str.c
00000000 l    df *ABS*	00000000 impure.c
0041788c l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 vfprintf.c
004138c0 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
004141e4 l     F .text	00000064 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
00414340 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00414490 l     F .text	00000038 alt_dev_reg
0041796c l     O .rwdata	000000cc epcs_flash_controller_0
00417a38 l     O .rwdata	0000002c jtag_uart_0
00417a64 l     O .rwdata	000000c4 uart_0
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
00414598 l     F .text	00000038 alt_flash_device_register
00414624 l     F .text	000003f8 alt_epcs_flash_query
00414a1c l     F .text	000000e8 alt_epcs_flash_memcmp
00414df0 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
004152c8 l     F .text	00000074 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_ts.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_vars.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
004156bc l     F .text	00000098 altera_avalon_uart_irq
00415754 l     F .text	000000e0 altera_avalon_uart_rxirq
00415834 l     F .text	00000144 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
004159cc l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
00415bf8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 epcs_commands.c
00415e50 l     F .text	00000038 epcs_test_wip
00415e88 l     F .text	00000038 epcs_await_wip_released
00000000 l    df *ABS*	00000000 alt_close.c
00416420 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00416564 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00416590 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
004168ac l     F .text	000000e0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
00416a04 l     F .text	00000050 alt_get_errno
00416a54 l     F .text	000000f4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
004181bc g     O .bss	00000004 alt_instruction_exception_handler
00414d64 g     F .text	0000008c alt_epcs_flash_get_info
004142c8 g     F .text	00000078 alt_main
00412fec g     F .text	00000080 _puts_r
00418464 g     O .bss	00000100 alt_irq
004105ec g     F .text	00000024 MSP_Get_RespPtr
00411aa0 g     F .text	00000048 Uart1_ISR
00417d04 g       *ABS*	00000000 __flash_rwdata_start
00411538 g     F .text	00000138 Hw_Uart_Q_Push
00412fa0 g     F .text	0000004c printf
004136f4 g     F .text	00000024 vsprintf
00410bbc g     F .text	0000004c Hw_Timer_Start
00410e98 g     F .text	000000a8 Hw_Uart_Init
00411254 g     F .text	0000007c Hw_Uart_PrintEx
00412408 g     F .text	00000450 .hidden __divsf3
004181b8 g     O .bss	00000004 altera_avalon_timer_ts_freq
00413860 g     F .text	00000060 memmove
00410980 g     F .text	00000170 Hw_Timer_Tick
00412d54 g     F .text	00000078 .hidden __fixsfsi
004105c8 g     F .text	00000024 MSP_Get_CmdPtr
00416ec4 g     F .text	00000020 altera_nios2_gen2_irq_init
00000000  w      *UND*	00000000 __errno
00415ec0 g     F .text	000000f8 epcs_sector_erase
004137c4 g     F .text	0000009c __sfvwrite_small_str
00410000 g     F .entry	0000000c __reset
00410020 g       *ABS*	00000000 __flash_exceptions_start
004106c0 g     F .text	00000154 MSP_SendResp
004181a0 g     O .bss	00000004 errno
004114a4 g     F .text	00000038 HW_UART_Q_VAILD
004181ac g     O .bss	00000004 alt_argv
0041fcd0 g       *ABS*	00000000 _gp
00412858 g     F .text	000004fc .hidden __subsf3
00417b50 g     O .rwdata	00000180 alt_fd_list
004160fc g     F .text	00000068 epcs_write_status_register
004170e8 g     F .text	00000090 alt_find_dev
0041698c g     F .text	00000078 alt_io_redirect
004176e4 g       *ABS*	00000000 __DTOR_END__
0041306c g     F .text	00000014 puts
00416810 g     F .text	0000009c alt_exception_cause_generated_bad_addr
00414ef8 g     F .text	00000100 alt_epcs_flash_write_block
004118f4 g     F .text	00000040 Hw_Led_Wait
0041085c g     F .text	000000d0 Hw_Timer_Init
00415150 g     F .text	000000e4 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
00412f64 g     F .text	0000003c _printf_r
00410000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
00411ef0 g     F .text	00000008 .hidden __udivsi3
004102f0 g     F .text	0000003c MSP_Init
00418350 g     O .bss	000000e7 Hw_Uart_Q_Buffer
004114dc g     F .text	0000005c Hw_Uart_Q_PushReady
00417cec g     O .rwdata	00000004 alt_max_fd
00410290 g     F .text	00000060 MSP_ISR
00414e84 g     F .text	00000074 alt_epcs_flash_erase_block
00417cd0 g     O .rwdata	00000004 _global_impure_ptr
004163c4 g     F .text	0000005c epcs_exit_4_bytes_mode
00418564 g       *ABS*	00000000 __bss_end
004140f4 g     F .text	000000f0 alt_iic_isr_register
00416dc0 g     F .text	00000104 alt_tick
0041179c g     F .text	00000034 Hw_Led_Init
00415614 g     F .text	000000a8 altera_avalon_uart_init
004117d0 g     F .text	00000060 Hw_Led_On
004140a8 g     F .text	0000004c alt_ic_irq_enabled
00416d28 g     F .text	00000098 alt_alarm_stop
00410834 g     F .text	00000028 Hw_Timer_ISR
004181a4 g     O .bss	00000004 alt_irq_active
004100fc g     F .exceptions	000000d0 alt_irq_handler
00417b28 g     O .rwdata	00000028 alt_dev_null
00411098 g     F .text	00000044 Hw_Uart_Open_COM2
00411124 g     F .text	0000005c Hw_Uart_Getch
004182f0 g     O .bss	00000060 Hw_Uart_Ch
00416548 g     F .text	0000001c alt_dcache_flush_all
004119a4 g     F .text	0000003c Hw_Wait_Usec
00410358 g     F .text	00000270 MSP_Update
00417d04 g       *ABS*	00000000 __ram_rwdata_end
00417ce4 g     O .rwdata	00000008 alt_dev_list
00414390 g     F .text	00000100 write
004154dc g     F .text	00000028 alt_timestamp_freq
0041788c g       *ABS*	00000000 __ram_rodata_end
00410f5c g     F .text	00000090 Hw_Uart_Open
00411ef8 g     F .text	00000008 .hidden __umodsi3
00411670 g     F .text	0000012c Hw_Uart_Q_Pop
00416280 g     F .text	00000068 epcs_read_electronic_signature
00418564 g       *ABS*	00000000 end
00415c48 g     F .text	000001ac altera_avalon_uart_write
004101cc g     F .exceptions	00000060 alt_instruction_exception_entry
004176e4 g       *ABS*	00000000 __CTOR_LIST__
0041bb80 g       *ABS*	00000000 __alt_stack_pointer
0041533c g     F .text	00000088 alt_avalon_timer_sc_init
00415564 g     F .text	00000060 altera_avalon_uart_write_fd
00412f00 g     F .text	00000064 .hidden __clzsi2
004155c4 g     F .text	00000050 altera_avalon_uart_close_fd
00415234 g     F .text	00000094 altera_avalon_jtag_uart_write
00413108 g     F .text	0000056c ___vfprintf_internal_r
00417514 g     F .text	0000019c __call_exitprocs
00410cfc g     F .text	00000034 Hw_Timer_Get_Handle
00410d30 g     F .text	00000028 Hw_Timer_Get_CountValue
0041022c g     F .text	0000003c _start
004181c0 g     O .bss	00000004 _alt_tick_rate
004112d0 g     F .text	00000064 Hw_Uart_Printf
00416ee4 g     F .text	00000204 alt_avalon_spi_command
004181c4 g     O .bss	00000004 _alt_nticks
004144fc g     F .text	0000009c alt_sys_init
00412dcc g     F .text	00000134 .hidden __floatsisf
004173c4 g     F .text	00000150 __register_exitproc
00411f00 g     F .text	00000028 .hidden __mulsi3
0041788c g       *ABS*	00000000 __ram_rwdata_start
004176e4 g       *ABS*	00000000 __ram_rodata_start
00415df4 g     F .text	0000005c epcs_read_status_register
00415090 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0041728c g     F .text	000000d4 alt_get_fd
004162e8 g     F .text	00000080 epcs_read_device_id
00417394 g     F .text	00000030 memcmp
00418564 g       *ABS*	00000000 __alt_stack_base
00021000 g       *ABS*	00000000 __alt_mem_epcs_flash_controller_0
00411390 g     F .text	00000080 Hw_Uart_Q_Init
00410268 g     F .text	00000028 Ap_Init
00411334 g     F .text	0000005c Hw_Uart_GetchNoWait
00411894 g     F .text	00000060 Hw_Led_Toggle
00411410 g     F .text	00000094 HW_UART_Q_SIZE
00417178 g     F .text	00000114 alt_find_file
004165e0 g     F .text	000000a4 alt_dev_llist_insert
0041392c g     F .text	0000056c ___svfprintf_internal_r
00417cf4 g     O .rwdata	00000008 alt_flash_dev_list
00413718 g     F .text	000000ac __sfvwrite_small_dev
00418438 g     O .bss	0000000e Hw_Uart_Q_Size
00410814 g     F .text	00000020 Hw_ISR_Init
0041817c g       *ABS*	00000000 __bss_start
00410948 g     F .text	0000001c Hw_Timer_SetupISR
00411ae8 g     F .text	000002c0 main
004181b0 g     O .bss	00000004 alt_envp
004150f0 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
004110dc g     F .text	00000048 Hw_Uart_SetReceiveFuncISR
00410cc0 g     F .text	0000003c Hw_Timer_Delay_ms
004153c4 g     F .text	00000088 alt_timestamp_start
00417cf0 g     O .rwdata	00000004 alt_errno
00411a14 g     F .text	00000028 micros
00411e40 g     F .text	00000054 .hidden __divsi3
00410c50 g     F .text	00000070 Hw_Timer_Reset
004176e4 g       *ABS*	00000000 __CTOR_END__
00414b04 g     F .text	00000260 alt_epcs_flash_write
004176e4 g       *ABS*	00000000 __flash_rodata_start
004176e4 g       *ABS*	00000000 __DTOR_LIST__
00411a3c g     F .text	00000034 delay
004144c8 g     F .text	00000034 alt_irq_init
00416ca8 g     F .text	00000080 alt_release_fd
0041032c g     F .text	0000002c MSP_GetReceived
00417728 g     O .rodata	00000100 .hidden __clz_tab
00417360 g     F .text	00000014 atexit
00413ebc g     F .text	00000058 _write_r
00413698 g     F .text	0000005c _vsprintf_r
00410f40 g     F .text	0000001c Hw_Uart_DeInit
00417cd4 g     O .rwdata	00000004 _impure_ptr
004181a8 g     O .bss	00000004 alt_argc
004181b4 g     O .bss	00000004 altera_avalon_timer_ts_base
004166e0 g     F .text	0000005c _do_dtors
00410020 g       .exceptions	00000000 alt_irq_entry
00411a70 g     F .text	00000030 delay_second
00417cdc g     O .rwdata	00000008 alt_fs_list
00413e98 g     F .text	00000024 __vfprintf_internal_unused
00410020 g       *ABS*	00000000 __ram_exceptions_start
00410af0 g     F .text	000000cc Hw_Timer_Set
0041544c g     F .text	00000090 alt_timestamp
00415fb8 g     F .text	000000f4 epcs_read_buffer
004145d0 g     F .text	00000054 alt_epcs_flash_init
00413f14 g     F .text	00000050 alt_ic_isr_register
00417d04 g       *ABS*	00000000 _edata
00415504 g     F .text	00000060 altera_avalon_uart_read_fd
00418564 g       *ABS*	00000000 _end
0041673c g     F .text	00000068 alt_flash_open_dev
00411934 g     F .text	00000030 Hw_Init
0041022c g       *ABS*	00000000 __ram_exceptions_end
00410d58 g     F .text	00000038 Hw_Timer_TimeStart
00414004 g     F .text	000000a4 alt_ic_irq_disable
00416368 g     F .text	0000005c epcs_enter_4_bytes_mode
00418446 g     O .bss	0000000e Hw_Uart_Q_End
00417374 g     F .text	00000020 exit
00410fec g     F .text	000000ac Hw_Uart_Open_COM1
00410610 g     F .text	000000b0 MSP_Get_CmdRcPtr
004167a4 g     F .text	00000050 alt_flash_close_dev
00411e94 g     F .text	0000005c .hidden __modsi3
0041bb80 g       *ABS*	00000000 __alt_data_end
00410020 g     F .exceptions	00000000 alt_exception
00415978 g     F .text	00000054 altera_avalon_uart_close
004176b0 g     F .text	00000034 _exit
00411964 g     F .text	00000040 Hw_Wait
00411da8 g     F .text	0000002c Main_Init
00413080 g     F .text	0000001c strlen
004160ac g     F .text	00000050 epcs_write_enable
00411830 g     F .text	00000064 Hw_Led_Off
00416b48 g     F .text	00000160 open
00410c08 g     F .text	00000048 Hw_Timer_Stop
004167f4 g     F .text	0000001c alt_icache_flush_all
00417cd8 g     O .rwdata	00000004 alt_priority_mask
00413f64 g     F .text	000000a0 alt_ic_irq_enable
0041092c g     F .text	0000001c Hw_Timer_DeInit
00413674 g     F .text	00000024 __vfprintf_internal
00415a1c g     F .text	000001dc altera_avalon_uart_read
00410d90 g     F .text	00000030 Hw_Timer_TimeGetElapse
00414ff8 g     F .text	00000098 alt_epcs_flash_read
00417cfc g     O .rwdata	00000008 alt_alarm_list
00416684 g     F .text	0000005c _do_ctors
004119e0 g     F .text	00000034 millis
00416470 g     F .text	000000d8 close
00411f28 g     F .text	000004e0 .hidden __addsf3
00414248 g     F .text	00000080 alt_load
00410964 g     F .text	0000001c Hw_Timer_Setup
00000000  w      *UND*	00000000 free
00416164 g     F .text	0000011c epcs_write_buffer
00418454 g     O .bss	0000000e Hw_Uart_Q_Start
00411180 g     F .text	000000d4 Hw_Uart_Putch



Disassembly of section .entry:

00410000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  410000:	00401074 	movhi	at,65
    ori r1, r1, %lo(_start)
  410004:	08408b14 	ori	at,at,556
    jmp r1
  410008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

00410020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  410020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  410024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  410028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  41002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  410030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  410034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  410038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  41003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  410040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  410044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  410048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  41004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  410050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  410054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  410058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  41005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  410060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  410064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  410068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  41006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  410070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  410074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  410078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  41007c:	10000326 	beq	r2,zero,41008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  410080:	20000226 	beq	r4,zero,41008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  410084:	04100fc0 	call	4100fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  410088:	00000706 	br	4100a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  41008c:	df401215 	stw	ea,72(sp)
        ldhu.n  r2, 0(r4)
        ldhu.n  r3, 2(r4)
        slli.n  r3, r3, 16
        or.n    r2, r2, r3 /* Instruction that caused exception */
#else
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  410090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
  410094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
  410098:	04101cc0 	call	4101cc <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
  41009c:	1000021e 	bne	r2,zero,4100a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
  4100a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  4100a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  4100a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  4100ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  4100b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  4100b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  4100b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  4100bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  4100c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  4100c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  4100c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  4100cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  4100d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  4100d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  4100d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  4100dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  4100e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  4100e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  4100e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  4100ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  4100f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  4100f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  4100f8:	ef80083a 	eret

004100fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  4100fc:	defff904 	addi	sp,sp,-28
  410100:	dfc00615 	stw	ra,24(sp)
  410104:	df000515 	stw	fp,20(sp)
  410108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  41010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  410110:	0005313a 	rdctl	r2,ipending
  410114:	e0bffe15 	stw	r2,-8(fp)

  return active;
  410118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  41011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  410120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  410124:	00800044 	movi	r2,1
  410128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  41012c:	e0fffb17 	ldw	r3,-20(fp)
  410130:	e0bffc17 	ldw	r2,-16(fp)
  410134:	1884703a 	and	r2,r3,r2
  410138:	10001426 	beq	r2,zero,41018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  41013c:	008010b4 	movhi	r2,66
  410140:	10a11904 	addi	r2,r2,-31644
  410144:	e0fffd17 	ldw	r3,-12(fp)
  410148:	180690fa 	slli	r3,r3,3
  41014c:	10c5883a 	add	r2,r2,r3
  410150:	10c00017 	ldw	r3,0(r2)
  410154:	008010b4 	movhi	r2,66
  410158:	10a11904 	addi	r2,r2,-31644
  41015c:	e13ffd17 	ldw	r4,-12(fp)
  410160:	200890fa 	slli	r4,r4,3
  410164:	21000104 	addi	r4,r4,4
  410168:	1105883a 	add	r2,r2,r4
  41016c:	10800017 	ldw	r2,0(r2)
  410170:	1009883a 	mov	r4,r2
  410174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  410178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  41017c:	0005313a 	rdctl	r2,ipending
  410180:	e0bfff15 	stw	r2,-4(fp)

  return active;
  410184:	e0bfff17 	ldw	r2,-4(fp)
  410188:	00000706 	br	4101a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
  41018c:	e0bffc17 	ldw	r2,-16(fp)
  410190:	1085883a 	add	r2,r2,r2
  410194:	e0bffc15 	stw	r2,-16(fp)
      i++;
  410198:	e0bffd17 	ldw	r2,-12(fp)
  41019c:	10800044 	addi	r2,r2,1
  4101a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  4101a4:	003fe106 	br	41012c <_gp+0xffff045c>

    active = alt_irq_pending ();
  4101a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  4101ac:	e0bffb17 	ldw	r2,-20(fp)
  4101b0:	103fdb1e 	bne	r2,zero,410120 <_gp+0xffff0450>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  4101b4:	0001883a 	nop
}
  4101b8:	e037883a 	mov	sp,fp
  4101bc:	dfc00117 	ldw	ra,4(sp)
  4101c0:	df000017 	ldw	fp,0(sp)
  4101c4:	dec00204 	addi	sp,sp,8
  4101c8:	f800283a 	ret

004101cc <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
  4101cc:	defffb04 	addi	sp,sp,-20
  4101d0:	dfc00415 	stw	ra,16(sp)
  4101d4:	df000315 	stw	fp,12(sp)
  4101d8:	df000304 	addi	fp,sp,12
  4101dc:	e13fff15 	stw	r4,-4(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  4101e0:	00bfffc4 	movi	r2,-1
  4101e4:	e0bffd15 	stw	r2,-12(fp)
  badaddr = 0;
  4101e8:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
  4101ec:	d0a13b17 	ldw	r2,-31508(gp)
  4101f0:	10000726 	beq	r2,zero,410210 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
  4101f4:	d0a13b17 	ldw	r2,-31508(gp)
  4101f8:	e0fffd17 	ldw	r3,-12(fp)
  4101fc:	1809883a 	mov	r4,r3
  410200:	e17fff17 	ldw	r5,-4(fp)
  410204:	e1bffe17 	ldw	r6,-8(fp)
  410208:	103ee83a 	callr	r2
  41020c:	00000206 	br	410218 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
  410210:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
  410214:	0005883a 	mov	r2,zero
}
  410218:	e037883a 	mov	sp,fp
  41021c:	dfc00117 	ldw	ra,4(sp)
  410220:	df000017 	ldw	fp,0(sp)
  410224:	dec00204 	addi	sp,sp,8
  410228:	f800283a 	ret

Disassembly of section .text:

0041022c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  41022c:	06c01074 	movhi	sp,65
    ori sp, sp, %lo(__alt_stack_pointer)
  410230:	deeee014 	ori	sp,sp,48000
    movhi gp, %hi(_gp)
  410234:	06801074 	movhi	gp,65
    ori gp, gp, %lo(_gp)
  410238:	d6bf3414 	ori	gp,gp,64720
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  41023c:	00801074 	movhi	r2,65
    ori r2, r2, %lo(__bss_start)
  410240:	10a05f14 	ori	r2,r2,33148

    movhi r3, %hi(__bss_end)
  410244:	00c01074 	movhi	r3,65
    ori r3, r3, %lo(__bss_end)
  410248:	18e15914 	ori	r3,r3,34148

    beq r2, r3, 1f
  41024c:	10c00326 	beq	r2,r3,41025c <_start+0x30>

0:
    stw zero, (r2)
  410250:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  410254:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  410258:	10fffd36 	bltu	r2,r3,410250 <_gp+0xffff0580>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  41025c:	04142480 	call	414248 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  410260:	04142c80 	call	4142c8 <alt_main>

00410264 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  410264:	003fff06 	br	410264 <_gp+0xffff0594>

00410268 <Ap_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Ap_Init( void )
{
  410268:	defffe04 	addi	sp,sp,-8
  41026c:	dfc00115 	stw	ra,4(sp)
  410270:	df000015 	stw	fp,0(sp)
  410274:	d839883a 	mov	fp,sp
	MSP_Init();
  410278:	04102f00 	call	4102f0 <MSP_Init>
}
  41027c:	e037883a 	mov	sp,fp
  410280:	dfc00117 	ldw	ra,4(sp)
  410284:	df000017 	ldw	fp,0(sp)
  410288:	dec00204 	addi	sp,sp,8
  41028c:	f800283a 	ret

00410290 <MSP_ISR>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void MSP_ISR(char Ch)
{
  410290:	defffc04 	addi	sp,sp,-16
  410294:	dfc00315 	stw	ra,12(sp)
  410298:	df000215 	stw	fp,8(sp)
  41029c:	df000204 	addi	fp,sp,8
  4102a0:	2005883a 	mov	r2,r4
  4102a4:	e0bfff05 	stb	r2,-4(fp)
	BOOL Ret;

	Ret = MSP_Update(Ch);
  4102a8:	e0bfff03 	ldbu	r2,-4(fp)
  4102ac:	10803fcc 	andi	r2,r2,255
  4102b0:	1009883a 	mov	r4,r2
  4102b4:	04103580 	call	410358 <MSP_Update>
  4102b8:	e0bffe05 	stb	r2,-8(fp)

	if( Ret == TRUE && CmdReceived == FALSE )
  4102bc:	e0bffe03 	ldbu	r2,-8(fp)
  4102c0:	10800058 	cmpnei	r2,r2,1
  4102c4:	1000051e 	bne	r2,zero,4102dc <MSP_ISR+0x4c>
  4102c8:	d0a12e03 	ldbu	r2,-31560(gp)
  4102cc:	10803fcc 	andi	r2,r2,255
  4102d0:	1000021e 	bne	r2,zero,4102dc <MSP_ISR+0x4c>
	{
		CmdReceived = TRUE;
  4102d4:	00800044 	movi	r2,1
  4102d8:	d0a12e05 	stb	r2,-31560(gp)
	}
}
  4102dc:	e037883a 	mov	sp,fp
  4102e0:	dfc00117 	ldw	ra,4(sp)
  4102e4:	df000017 	ldw	fp,0(sp)
  4102e8:	dec00204 	addi	sp,sp,8
  4102ec:	f800283a 	ret

004102f0 <MSP_Init>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void MSP_Init( void )
{
  4102f0:	defffe04 	addi	sp,sp,-8
  4102f4:	dfc00115 	stw	ra,4(sp)
  4102f8:	df000015 	stw	fp,0(sp)
  4102fc:	d839883a 	mov	fp,sp
	CmdReceived = FALSE;
  410300:	d0212e05 	stb	zero,-31560(gp)
	Cmd_State   = MSP_CMD_STATE_WAIT_START;
  410304:	d0212b05 	stb	zero,-31572(gp)

	Hw_Uart_SetReceiveFuncISR( HW_UART_CH_MSP, MSP_ISR );
  410308:	0009883a 	mov	r4,zero
  41030c:	01401074 	movhi	r5,65
  410310:	2940a404 	addi	r5,r5,656
  410314:	04110dc0 	call	4110dc <Hw_Uart_SetReceiveFuncISR>
}
  410318:	e037883a 	mov	sp,fp
  41031c:	dfc00117 	ldw	ra,4(sp)
  410320:	df000017 	ldw	fp,0(sp)
  410324:	dec00204 	addi	sp,sp,8
  410328:	f800283a 	ret

0041032c <MSP_GetReceived>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
BOOL MSP_GetReceived( void )
{
  41032c:	defffe04 	addi	sp,sp,-8
  410330:	df000115 	stw	fp,4(sp)
  410334:	df000104 	addi	fp,sp,4
	BOOL Ret;

	Ret = CmdReceived;
  410338:	d0a12e03 	ldbu	r2,-31560(gp)
  41033c:	e0bfff05 	stb	r2,-4(fp)
	CmdReceived = FALSE;
  410340:	d0212e05 	stb	zero,-31560(gp)

	return Ret;
  410344:	e0bfff03 	ldbu	r2,-4(fp)
}
  410348:	e037883a 	mov	sp,fp
  41034c:	df000017 	ldw	fp,0(sp)
  410350:	dec00104 	addi	sp,sp,4
  410354:	f800283a 	ret

00410358 <MSP_Update>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
BOOL MSP_Update( uint8_t ch )
{
  410358:	defffc04 	addi	sp,sp,-16
  41035c:	dfc00315 	stw	ra,12(sp)
  410360:	df000215 	stw	fp,8(sp)
  410364:	df000204 	addi	fp,sp,8
  410368:	2005883a 	mov	r2,r4
  41036c:	e0bfff05 	stb	r2,-4(fp)
	BOOL Ret = FALSE;
  410370:	e03ffe05 	stb	zero,-8(fp)



	//-- 바이트간 타임아웃 설정(200ms)
	//
	CurrentTime = micros();
  410374:	0411a140 	call	411a14 <micros>
  410378:	d0a12c15 	stw	r2,-31568(gp)

	if( (CurrentTime - PreviousTime) > 200000 )
  41037c:	d0e12c17 	ldw	r3,-31568(gp)
  410380:	d0a12d17 	ldw	r2,-31564(gp)
  410384:	1887c83a 	sub	r3,r3,r2
  410388:	008000f4 	movhi	r2,3
  41038c:	10835004 	addi	r2,r2,3392
  410390:	10c0032e 	bgeu	r2,r3,4103a0 <MSP_Update+0x48>
	{
		Cmd_State    = MSP_CMD_STATE_WAIT_START;
  410394:	d0212b05 	stb	zero,-31572(gp)
		PreviousTime = CurrentTime;
  410398:	d0a12c17 	ldw	r2,-31568(gp)
  41039c:	d0a12d15 	stw	r2,-31564(gp)



	//-- 명령어 상태
	//
	switch( Cmd_State )
  4103a0:	d0a12b03 	ldbu	r2,-31572(gp)
  4103a4:	10803fcc 	andi	r2,r2,255
  4103a8:	10c001e8 	cmpgeui	r3,r2,7
  4103ac:	1800801e 	bne	r3,zero,4105b0 <MSP_Update+0x258>
  4103b0:	100690ba 	slli	r3,r2,2
  4103b4:	00801074 	movhi	r2,65
  4103b8:	1080f204 	addi	r2,r2,968
  4103bc:	1885883a 	add	r2,r3,r2
  4103c0:	10800017 	ldw	r2,0(r2)
  4103c4:	1000683a 	jmp	r2
  4103c8:	004103e4 	muli	at,zero,1039
  4103cc:	00410400 	call	41040 <__alt_mem_epcs_flash_controller_0+0x20040>
  4103d0:	00410420 	cmpeqi	at,zero,1040
  4103d4:	00410458 	cmpnei	at,zero,1041
  4103d8:	004104b0 	cmpltui	at,zero,1042
  4103dc:	00410510 	cmplti	at,zero,1044
  4103e0:	00410588 	cmpgei	at,zero,1046
		//-- 시작 문자 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_START:

			// 시작 문자를 기다림
			if( ch == MSP_CMD_START )
  4103e4:	e0bfff03 	ldbu	r2,-4(fp)
  4103e8:	10800918 	cmpnei	r2,r2,36
  4103ec:	1000031e 	bne	r2,zero,4103fc <MSP_Update+0xa4>
			{
				Cmd_State    = MSP_CMD_STATE_WAIT_HEADER_M;
  4103f0:	00800044 	movi	r2,1
  4103f4:	d0a12b05 	stb	r2,-31572(gp)
			}
			break;
  4103f8:	00006d06 	br	4105b0 <MSP_Update+0x258>
  4103fc:	00006c06 	br	4105b0 <MSP_Update+0x258>


		//-- 'M' 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_HEADER_M:
			if( ch == MSP_CMD_HEADER_M )
  410400:	e0bfff03 	ldbu	r2,-4(fp)
  410404:	10801358 	cmpnei	r2,r2,77
  410408:	1000031e 	bne	r2,zero,410418 <MSP_Update+0xc0>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_HEADER_ARROW;
  41040c:	00800084 	movi	r2,2
  410410:	d0a12b05 	stb	r2,-31572(gp)
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
			}
			break;
  410414:	00006606 	br	4105b0 <MSP_Update+0x258>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_HEADER_ARROW;
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
  410418:	d0212b05 	stb	zero,-31572(gp)
			}
			break;
  41041c:	00006406 	br	4105b0 <MSP_Update+0x258>


		//-- '<' 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_HEADER_ARROW:
			if( ch == MSP_CMD_HEADER_ARROW )
  410420:	e0bfff03 	ldbu	r2,-4(fp)
  410424:	10800f18 	cmpnei	r2,r2,60
  410428:	1000091e 	bne	r2,zero,410450 <MSP_Update+0xf8>
			{
				Cmd.CheckSum = 0x00;
  41042c:	008010b4 	movhi	r2,66
  410430:	10a07204 	addi	r2,r2,-32312
  410434:	10000085 	stb	zero,2(r2)
				Cmd.Length   = 0;
  410438:	008010b4 	movhi	r2,66
  41043c:	10a07204 	addi	r2,r2,-32312
  410440:	10000045 	stb	zero,1(r2)
				Cmd_State = MSP_CMD_STATE_WAIT_DATA_SIZE;
  410444:	008000c4 	movi	r2,3
  410448:	d0a12b05 	stb	r2,-31572(gp)
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
			}
			break;
  41044c:	00005806 	br	4105b0 <MSP_Update+0x258>
				Cmd.Length   = 0;
				Cmd_State = MSP_CMD_STATE_WAIT_DATA_SIZE;
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
  410450:	d0212b05 	stb	zero,-31572(gp)
			}
			break;
  410454:	00005606 	br	4105b0 <MSP_Update+0x258>

		//-- 데이터 사이즈 기다리는 상태(64까지)
		//
		case MSP_CMD_STATE_WAIT_DATA_SIZE:

			if( ch <= MSP_CMD_MAX_LENGTH )
  410458:	e0bfff03 	ldbu	r2,-4(fp)
  41045c:	10801068 	cmpgeui	r2,r2,65
  410460:	1000111e 	bne	r2,zero,4104a8 <MSP_Update+0x150>
			{
				Cmd.Length    = ch;
  410464:	008010b4 	movhi	r2,66
  410468:	10a07204 	addi	r2,r2,-32312
  41046c:	e0ffff03 	ldbu	r3,-4(fp)
  410470:	10c00045 	stb	r3,1(r2)
				Index_Data    = 0;
  410474:	d0212b45 	stb	zero,-31571(gp)
				Cmd.CheckSum ^= ch;
  410478:	008010b4 	movhi	r2,66
  41047c:	10a07204 	addi	r2,r2,-32312
  410480:	10c00083 	ldbu	r3,2(r2)
  410484:	e0bfff03 	ldbu	r2,-4(fp)
  410488:	1884f03a 	xor	r2,r3,r2
  41048c:	1007883a 	mov	r3,r2
  410490:	008010b4 	movhi	r2,66
  410494:	10a07204 	addi	r2,r2,-32312
  410498:	10c00085 	stb	r3,2(r2)
				Cmd_State     = MSP_CMD_STATE_WAIT_CMD;
  41049c:	00800104 	movi	r2,4
  4104a0:	d0a12b05 	stb	r2,-31572(gp)
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
			}
			break;
  4104a4:	00004206 	br	4105b0 <MSP_Update+0x258>
				Cmd.CheckSum ^= ch;
				Cmd_State     = MSP_CMD_STATE_WAIT_CMD;
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
  4104a8:	d0212b05 	stb	zero,-31572(gp)
			}
			break;
  4104ac:	00004006 	br	4105b0 <MSP_Update+0x258>

		//-- 명령어를 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_CMD:

			Cmd.Cmd       = ch;
  4104b0:	008010b4 	movhi	r2,66
  4104b4:	10a07204 	addi	r2,r2,-32312
  4104b8:	e0ffff03 	ldbu	r3,-4(fp)
  4104bc:	10c00005 	stb	r3,0(r2)
			Cmd.CheckSum ^= ch;
  4104c0:	008010b4 	movhi	r2,66
  4104c4:	10a07204 	addi	r2,r2,-32312
  4104c8:	10c00083 	ldbu	r3,2(r2)
  4104cc:	e0bfff03 	ldbu	r2,-4(fp)
  4104d0:	1884f03a 	xor	r2,r3,r2
  4104d4:	1007883a 	mov	r3,r2
  4104d8:	008010b4 	movhi	r2,66
  4104dc:	10a07204 	addi	r2,r2,-32312
  4104e0:	10c00085 	stb	r3,2(r2)

			if( Cmd.Length == 0 )
  4104e4:	008010b4 	movhi	r2,66
  4104e8:	10a07204 	addi	r2,r2,-32312
  4104ec:	10800043 	ldbu	r2,1(r2)
  4104f0:	10803fcc 	andi	r2,r2,255
  4104f4:	1000031e 	bne	r2,zero,410504 <MSP_Update+0x1ac>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_CHECKSUM;
  4104f8:	00800184 	movi	r2,6
  4104fc:	d0a12b05 	stb	r2,-31572(gp)
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_DATA;
			}
			break;
  410500:	00002b06 	br	4105b0 <MSP_Update+0x258>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_CHECKSUM;
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_DATA;
  410504:	00800144 	movi	r2,5
  410508:	d0a12b05 	stb	r2,-31572(gp)
			}
			break;
  41050c:	00002806 	br	4105b0 <MSP_Update+0x258>

		//-- 데이터를 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_DATA:

			Cmd.CheckSum          ^= ch;
  410510:	008010b4 	movhi	r2,66
  410514:	10a07204 	addi	r2,r2,-32312
  410518:	10c00083 	ldbu	r3,2(r2)
  41051c:	e0bfff03 	ldbu	r2,-4(fp)
  410520:	1884f03a 	xor	r2,r3,r2
  410524:	1007883a 	mov	r3,r2
  410528:	008010b4 	movhi	r2,66
  41052c:	10a07204 	addi	r2,r2,-32312
  410530:	10c00085 	stb	r3,2(r2)
			Cmd.Data[ Index_Data ] = ch;
  410534:	d0a12b43 	ldbu	r2,-31571(gp)
  410538:	10c03fcc 	andi	r3,r2,255
  41053c:	008010b4 	movhi	r2,66
  410540:	10a07204 	addi	r2,r2,-32312
  410544:	10c5883a 	add	r2,r2,r3
  410548:	e0ffff03 	ldbu	r3,-4(fp)
  41054c:	10c000c5 	stb	r3,3(r2)

			Index_Data++;
  410550:	d0a12b43 	ldbu	r2,-31571(gp)
  410554:	10800044 	addi	r2,r2,1
  410558:	d0a12b45 	stb	r2,-31571(gp)

			if( Index_Data >= Cmd.Length )
  41055c:	008010b4 	movhi	r2,66
  410560:	10a07204 	addi	r2,r2,-32312
  410564:	10800043 	ldbu	r2,1(r2)
  410568:	d0e12b43 	ldbu	r3,-31571(gp)
  41056c:	10803fcc 	andi	r2,r2,255
  410570:	18c03fcc 	andi	r3,r3,255
  410574:	18800336 	bltu	r3,r2,410584 <MSP_Update+0x22c>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_CHECKSUM;
  410578:	00800184 	movi	r2,6
  41057c:	d0a12b05 	stb	r2,-31572(gp)
			}
			break;
  410580:	00000b06 	br	4105b0 <MSP_Update+0x258>
  410584:	00000a06 	br	4105b0 <MSP_Update+0x258>

		//-- 체크섬을 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_CHECKSUM:

			if( Cmd.CheckSum == ch )
  410588:	008010b4 	movhi	r2,66
  41058c:	10a07204 	addi	r2,r2,-32312
  410590:	10800083 	ldbu	r2,2(r2)
  410594:	10c03fcc 	andi	r3,r2,255
  410598:	e0bfff03 	ldbu	r2,-4(fp)
  41059c:	1880021e 	bne	r3,r2,4105a8 <MSP_Update+0x250>
			{
				Ret = TRUE;
  4105a0:	00800044 	movi	r2,1
  4105a4:	e0bffe05 	stb	r2,-8(fp)
			}

			Cmd_State = MSP_CMD_STATE_WAIT_START;
  4105a8:	d0212b05 	stb	zero,-31572(gp)
			break;
  4105ac:	0001883a 	nop
	}

	return Ret;
  4105b0:	e0bffe03 	ldbu	r2,-8(fp)
}
  4105b4:	e037883a 	mov	sp,fp
  4105b8:	dfc00117 	ldw	ra,4(sp)
  4105bc:	df000017 	ldw	fp,0(sp)
  4105c0:	dec00204 	addi	sp,sp,8
  4105c4:	f800283a 	ret

004105c8 <MSP_Get_CmdPtr>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
MSP_CMD_OBJ *MSP_Get_CmdPtr( void )
{
  4105c8:	deffff04 	addi	sp,sp,-4
  4105cc:	df000015 	stw	fp,0(sp)
  4105d0:	d839883a 	mov	fp,sp
	return &Cmd;
  4105d4:	008010b4 	movhi	r2,66
  4105d8:	10a07204 	addi	r2,r2,-32312
}
  4105dc:	e037883a 	mov	sp,fp
  4105e0:	df000017 	ldw	fp,0(sp)
  4105e4:	dec00104 	addi	sp,sp,4
  4105e8:	f800283a 	ret

004105ec <MSP_Get_RespPtr>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
MSP_RESP_OBJ *MSP_Get_RespPtr( void )
{
  4105ec:	deffff04 	addi	sp,sp,-4
  4105f0:	df000015 	stw	fp,0(sp)
  4105f4:	d839883a 	mov	fp,sp
	return &Resp;
  4105f8:	008010b4 	movhi	r2,66
  4105fc:	10a082c4 	addi	r2,r2,-32245
}
  410600:	e037883a 	mov	sp,fp
  410604:	df000017 	ldw	fp,0(sp)
  410608:	dec00104 	addi	sp,sp,4
  41060c:	f800283a 	ret

00410610 <MSP_Get_CmdRcPtr>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
MSP_CMD_RC_OBJ *MSP_Get_CmdRcPtr( void )
{
  410610:	defffe04 	addi	sp,sp,-8
  410614:	df000115 	stw	fp,4(sp)
  410618:	df000104 	addi	fp,sp,4
	static MSP_CMD_RC_OBJ RcCmd;
	MSP_CMD_OBJ *pCmd = &Cmd;
  41061c:	008010b4 	movhi	r2,66
  410620:	10a07204 	addi	r2,r2,-32312
  410624:	e0bfff15 	stw	r2,-4(fp)


	RcCmd.Roll     = pCmd->Data[0] * 4 - 500;
  410628:	e0bfff17 	ldw	r2,-4(fp)
  41062c:	108000c3 	ldbu	r2,3(r2)
  410630:	10803fcc 	andi	r2,r2,255
  410634:	10bfe0c4 	addi	r2,r2,-125
  410638:	1085883a 	add	r2,r2,r2
  41063c:	1085883a 	add	r2,r2,r2
  410640:	d0a12e8d 	sth	r2,-31558(gp)
	RcCmd.Pitch    = pCmd->Data[1] * 4 - 500;
  410644:	e0bfff17 	ldw	r2,-4(fp)
  410648:	10800103 	ldbu	r2,4(r2)
  41064c:	10803fcc 	andi	r2,r2,255
  410650:	10bfe0c4 	addi	r2,r2,-125
  410654:	1085883a 	add	r2,r2,r2
  410658:	1085883a 	add	r2,r2,r2
  41065c:	1007883a 	mov	r3,r2
  410660:	d0a12f04 	addi	r2,gp,-31556
  410664:	10c0000d 	sth	r3,0(r2)
	RcCmd.Yaw      = pCmd->Data[2] * 4 - 500;
  410668:	e0bfff17 	ldw	r2,-4(fp)
  41066c:	10800143 	ldbu	r2,5(r2)
  410670:	10803fcc 	andi	r2,r2,255
  410674:	10bfe0c4 	addi	r2,r2,-125
  410678:	1085883a 	add	r2,r2,r2
  41067c:	1085883a 	add	r2,r2,r2
  410680:	1007883a 	mov	r3,r2
  410684:	d0a12f84 	addi	r2,gp,-31554
  410688:	10c0000d 	sth	r3,0(r2)
	RcCmd.Throthle = pCmd->Data[3] * 4;
  41068c:	e0bfff17 	ldw	r2,-4(fp)
  410690:	10800183 	ldbu	r2,6(r2)
  410694:	10803fcc 	andi	r2,r2,255
  410698:	1085883a 	add	r2,r2,r2
  41069c:	1085883a 	add	r2,r2,r2
  4106a0:	1007883a 	mov	r3,r2
  4106a4:	d0a13004 	addi	r2,gp,-31552
  4106a8:	10c0000d 	sth	r3,0(r2)


	return &RcCmd;
  4106ac:	d0a12e84 	addi	r2,gp,-31558
}
  4106b0:	e037883a 	mov	sp,fp
  4106b4:	df000017 	ldw	fp,0(sp)
  4106b8:	dec00104 	addi	sp,sp,4
  4106bc:	f800283a 	ret

004106c0 <MSP_SendResp>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void MSP_SendResp( MSP_RESP_OBJ *pResp )
{
  4106c0:	defffc04 	addi	sp,sp,-16
  4106c4:	dfc00315 	stw	ra,12(sp)
  4106c8:	df000215 	stw	fp,8(sp)
  4106cc:	df000204 	addi	fp,sp,8
  4106d0:	e13fff15 	stw	r4,-4(fp)
	uint8_t i;
	uint8_t CheckSum = 0;
  4106d4:	e03ffe45 	stb	zero,-7(fp)


	Hw_Uart_Putch(HW_UART_CH_MSP, MSP_CMD_START );
  4106d8:	0009883a 	mov	r4,zero
  4106dc:	01400904 	movi	r5,36
  4106e0:	04111800 	call	411180 <Hw_Uart_Putch>
	Hw_Uart_Putch(HW_UART_CH_MSP, MSP_CMD_HEADER_M );
  4106e4:	0009883a 	mov	r4,zero
  4106e8:	01401344 	movi	r5,77
  4106ec:	04111800 	call	411180 <Hw_Uart_Putch>

	if( pResp->ErrorCode > 0 )	Hw_Uart_Putch(HW_UART_CH_MSP, '!');
  4106f0:	e0bfff17 	ldw	r2,-4(fp)
  4106f4:	10800083 	ldbu	r2,2(r2)
  4106f8:	10803fcc 	andi	r2,r2,255
  4106fc:	10000426 	beq	r2,zero,410710 <MSP_SendResp+0x50>
  410700:	0009883a 	mov	r4,zero
  410704:	01400844 	movi	r5,33
  410708:	04111800 	call	411180 <Hw_Uart_Putch>
  41070c:	00000306 	br	41071c <MSP_SendResp+0x5c>
	else						Hw_Uart_Putch(HW_UART_CH_MSP, '>');
  410710:	0009883a 	mov	r4,zero
  410714:	01400f84 	movi	r5,62
  410718:	04111800 	call	411180 <Hw_Uart_Putch>

	Hw_Uart_Putch(HW_UART_CH_MSP, pResp->Length );
  41071c:	e0bfff17 	ldw	r2,-4(fp)
  410720:	10800043 	ldbu	r2,1(r2)
  410724:	10803fcc 	andi	r2,r2,255
  410728:	1080201c 	xori	r2,r2,128
  41072c:	10bfe004 	addi	r2,r2,-128
  410730:	0009883a 	mov	r4,zero
  410734:	100b883a 	mov	r5,r2
  410738:	04111800 	call	411180 <Hw_Uart_Putch>
	Hw_Uart_Putch(HW_UART_CH_MSP, pResp->Cmd );
  41073c:	e0bfff17 	ldw	r2,-4(fp)
  410740:	10800003 	ldbu	r2,0(r2)
  410744:	10803fcc 	andi	r2,r2,255
  410748:	1080201c 	xori	r2,r2,128
  41074c:	10bfe004 	addi	r2,r2,-128
  410750:	0009883a 	mov	r4,zero
  410754:	100b883a 	mov	r5,r2
  410758:	04111800 	call	411180 <Hw_Uart_Putch>
	CheckSum ^= pResp->Cmd;
  41075c:	e0bfff17 	ldw	r2,-4(fp)
  410760:	10c00003 	ldbu	r3,0(r2)
  410764:	e0bffe43 	ldbu	r2,-7(fp)
  410768:	1884f03a 	xor	r2,r3,r2
  41076c:	e0bffe45 	stb	r2,-7(fp)

	for( i=0; i<pResp->Length; i++ )
  410770:	e03ffe05 	stb	zero,-8(fp)
  410774:	00001606 	br	4107d0 <MSP_SendResp+0x110>
	{
		Hw_Uart_Putch( HW_UART_CH_MSP, pResp->Data[i] );
  410778:	e0bffe03 	ldbu	r2,-8(fp)
  41077c:	e0ffff17 	ldw	r3,-4(fp)
  410780:	1885883a 	add	r2,r3,r2
  410784:	10800104 	addi	r2,r2,4
  410788:	10800003 	ldbu	r2,0(r2)
  41078c:	10803fcc 	andi	r2,r2,255
  410790:	1080201c 	xori	r2,r2,128
  410794:	10bfe004 	addi	r2,r2,-128
  410798:	0009883a 	mov	r4,zero
  41079c:	100b883a 	mov	r5,r2
  4107a0:	04111800 	call	411180 <Hw_Uart_Putch>
		CheckSum ^= pResp->Data[i];
  4107a4:	e0bffe03 	ldbu	r2,-8(fp)
  4107a8:	e0ffff17 	ldw	r3,-4(fp)
  4107ac:	1885883a 	add	r2,r3,r2
  4107b0:	10800104 	addi	r2,r2,4
  4107b4:	10c00003 	ldbu	r3,0(r2)
  4107b8:	e0bffe43 	ldbu	r2,-7(fp)
  4107bc:	1884f03a 	xor	r2,r3,r2
  4107c0:	e0bffe45 	stb	r2,-7(fp)

	Hw_Uart_Putch(HW_UART_CH_MSP, pResp->Length );
	Hw_Uart_Putch(HW_UART_CH_MSP, pResp->Cmd );
	CheckSum ^= pResp->Cmd;

	for( i=0; i<pResp->Length; i++ )
  4107c4:	e0bffe03 	ldbu	r2,-8(fp)
  4107c8:	10800044 	addi	r2,r2,1
  4107cc:	e0bffe05 	stb	r2,-8(fp)
  4107d0:	e0bfff17 	ldw	r2,-4(fp)
  4107d4:	10800043 	ldbu	r2,1(r2)
  4107d8:	10803fcc 	andi	r2,r2,255
  4107dc:	e0fffe03 	ldbu	r3,-8(fp)
  4107e0:	18bfe536 	bltu	r3,r2,410778 <_gp+0xffff0aa8>
	{
		Hw_Uart_Putch( HW_UART_CH_MSP, pResp->Data[i] );
		CheckSum ^= pResp->Data[i];
	}

	Hw_Uart_Putch(HW_UART_CH_MSP, CheckSum );
  4107e4:	e0bffe43 	ldbu	r2,-7(fp)
  4107e8:	10803fcc 	andi	r2,r2,255
  4107ec:	1080201c 	xori	r2,r2,128
  4107f0:	10bfe004 	addi	r2,r2,-128
  4107f4:	0009883a 	mov	r4,zero
  4107f8:	100b883a 	mov	r5,r2
  4107fc:	04111800 	call	411180 <Hw_Uart_Putch>
}
  410800:	e037883a 	mov	sp,fp
  410804:	dfc00117 	ldw	ra,4(sp)
  410808:	df000017 	ldw	fp,0(sp)
  41080c:	dec00204 	addi	sp,sp,8
  410810:	f800283a 	ret

00410814 <Hw_ISR_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
s32 Hw_ISR_Init( void )
{
  410814:	deffff04 	addi	sp,sp,-4
  410818:	df000015 	stw	fp,0(sp)
  41081c:	d839883a 	mov	fp,sp


	return 1;
  410820:	00800044 	movi	r2,1
}
  410824:	e037883a 	mov	sp,fp
  410828:	df000017 	ldw	fp,0(sp)
  41082c:	dec00104 	addi	sp,sp,4
  410830:	f800283a 	ret

00410834 <Hw_Timer_ISR>:
void Hw_Timer_Setup( void );



void Hw_Timer_ISR(void)
{
  410834:	defffe04 	addi	sp,sp,-8
  410838:	dfc00115 	stw	ra,4(sp)
  41083c:	df000015 	stw	fp,0(sp)
  410840:	d839883a 	mov	fp,sp

	Hw_Timer_Tick();  
  410844:	04109800 	call	410980 <Hw_Timer_Tick>

}
  410848:	e037883a 	mov	sp,fp
  41084c:	dfc00117 	ldw	ra,4(sp)
  410850:	df000017 	ldw	fp,0(sp)
  410854:	dec00204 	addi	sp,sp,8
  410858:	f800283a 	ret

0041085c <Hw_Timer_Init>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Timer_Init( void )
{
  41085c:	defffd04 	addi	sp,sp,-12
  410860:	dfc00215 	stw	ra,8(sp)
  410864:	df000115 	stw	fp,4(sp)
  410868:	df000104 	addi	fp,sp,4
	u8 i;
	static u8 Excute = 0;

	
	if( Excute == 1 ) return;  // 이미 한번 실행했다면 정지.
  41086c:	d0a13303 	ldbu	r2,-31540(gp)
  410870:	10803fcc 	andi	r2,r2,255
  410874:	10800058 	cmpnei	r2,r2,1
  410878:	1000011e 	bne	r2,zero,410880 <Hw_Timer_Init+0x24>
  41087c:	00002606 	br	410918 <Hw_Timer_Init+0xbc>
	
	
	// 구조체 초기화
	for(i=0; i<TIMER_MAX; i++)
  410880:	e03fff05 	stb	zero,-4(fp)
  410884:	00001d06 	br	4108fc <Hw_Timer_Init+0xa0>
	{
		Timer_Tbl[i].Timer_En   = OFF;
  410888:	e0ffff03 	ldbu	r3,-4(fp)
  41088c:	008010b4 	movhi	r2,66
  410890:	10a09404 	addi	r2,r2,-32176
  410894:	1806913a 	slli	r3,r3,4
  410898:	10c5883a 	add	r2,r2,r3
  41089c:	10000005 	stb	zero,0(r2)
		Timer_Tbl[i].Timer_Ctn  = 0;
  4108a0:	e0ffff03 	ldbu	r3,-4(fp)
  4108a4:	008010b4 	movhi	r2,66
  4108a8:	10a09404 	addi	r2,r2,-32176
  4108ac:	1806913a 	slli	r3,r3,4
  4108b0:	10c5883a 	add	r2,r2,r3
  4108b4:	1000008d 	sth	zero,2(r2)
		Timer_Tbl[i].Timer_Init = 0;
  4108b8:	e0ffff03 	ldbu	r3,-4(fp)
  4108bc:	008010b4 	movhi	r2,66
  4108c0:	10a09404 	addi	r2,r2,-32176
  4108c4:	1806913a 	slli	r3,r3,4
  4108c8:	18c00104 	addi	r3,r3,4
  4108cc:	10c5883a 	add	r2,r2,r3
  4108d0:	1000000d 	sth	zero,0(r2)
		Timer_Tbl[i].TmrFnct    = NULL;
  4108d4:	e0ffff03 	ldbu	r3,-4(fp)
  4108d8:	008010b4 	movhi	r2,66
  4108dc:	10a09404 	addi	r2,r2,-32176
  4108e0:	1806913a 	slli	r3,r3,4
  4108e4:	18c00204 	addi	r3,r3,8
  4108e8:	10c5883a 	add	r2,r2,r3
  4108ec:	10000015 	stw	zero,0(r2)
	
	if( Excute == 1 ) return;  // 이미 한번 실행했다면 정지.
	
	
	// 구조체 초기화
	for(i=0; i<TIMER_MAX; i++)
  4108f0:	e0bfff03 	ldbu	r2,-4(fp)
  4108f4:	10800044 	addi	r2,r2,1
  4108f8:	e0bfff05 	stb	r2,-4(fp)
  4108fc:	e0bfff03 	ldbu	r2,-4(fp)
  410900:	108002b0 	cmpltui	r2,r2,10
  410904:	103fe01e 	bne	r2,zero,410888 <_gp+0xffff0bb8>
		Timer_Tbl[i].Timer_Init = 0;
		Timer_Tbl[i].TmrFnct    = NULL;
	}	                   
	
	
	Hw_Timer_SetupISR();
  410908:	04109480 	call	410948 <Hw_Timer_SetupISR>
	Hw_Timer_Setup();	
  41090c:	04109640 	call	410964 <Hw_Timer_Setup>

	Excute = 1;
  410910:	00800044 	movi	r2,1
  410914:	d0a13305 	stb	r2,-31540(gp)

}
  410918:	e037883a 	mov	sp,fp
  41091c:	dfc00117 	ldw	ra,4(sp)
  410920:	df000017 	ldw	fp,0(sp)
  410924:	dec00204 	addi	sp,sp,8
  410928:	f800283a 	ret

0041092c <Hw_Timer_DeInit>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Timer_DeInit( void )
{
  41092c:	deffff04 	addi	sp,sp,-4
  410930:	df000015 	stw	fp,0(sp)
  410934:	d839883a 	mov	fp,sp

}
  410938:	e037883a 	mov	sp,fp
  41093c:	df000017 	ldw	fp,0(sp)
  410940:	dec00104 	addi	sp,sp,4
  410944:	f800283a 	ret

00410948 <Hw_Timer_SetupISR>:
     	 	 	 타이머 H/W 기능을 초기화 한다.
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Timer_SetupISR( void )
{	
  410948:	deffff04 	addi	sp,sp,-4
  41094c:	df000015 	stw	fp,0(sp)
  410950:	d839883a 	mov	fp,sp

}
  410954:	e037883a 	mov	sp,fp
  410958:	df000017 	ldw	fp,0(sp)
  41095c:	dec00104 	addi	sp,sp,4
  410960:	f800283a 	ret

00410964 <Hw_Timer_Setup>:
     	 	 	 타이머 H/W 기능을 초기화 한다.
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Timer_Setup( void )
{
  410964:	deffff04 	addi	sp,sp,-4
  410968:	df000015 	stw	fp,0(sp)
  41096c:	d839883a 	mov	fp,sp
	
}
  410970:	e037883a 	mov	sp,fp
  410974:	df000017 	ldw	fp,0(sp)
  410978:	dec00104 	addi	sp,sp,4
  41097c:	f800283a 	ret

00410980 <Hw_Timer_Tick>:
			타이머인터럽트 발생시에 실행되는 함수(1ms 혹은 10ms 단위로 실행)
     ARG	: void
     RET	: void
---------------------------------------------------------------------------*/
void Hw_Timer_Tick(void)
{
  410980:	defffd04 	addi	sp,sp,-12
  410984:	dfc00215 	stw	ra,8(sp)
  410988:	df000115 	stw	fp,4(sp)
  41098c:	df000104 	addi	fp,sp,4
	u8 i;

	
	Hw_Timer_Counter++;
  410990:	d0a13117 	ldw	r2,-31548(gp)
  410994:	10800044 	addi	r2,r2,1
  410998:	d0a13115 	stw	r2,-31548(gp)


	if( Tmr_Ctn ) Tmr_Ctn--;
  41099c:	d0a1320b 	ldhu	r2,-31544(gp)
  4109a0:	10bfffcc 	andi	r2,r2,65535
  4109a4:	10000326 	beq	r2,zero,4109b4 <Hw_Timer_Tick+0x34>
  4109a8:	d0a1320b 	ldhu	r2,-31544(gp)
  4109ac:	10bfffc4 	addi	r2,r2,-1
  4109b0:	d0a1320d 	sth	r2,-31544(gp)
	
	
			   
	for(i=0; i<TIMER_MAX; i++)								// 타이머 갯수만큼
  4109b4:	e03fff05 	stb	zero,-4(fp)
  4109b8:	00004506 	br	410ad0 <Hw_Timer_Tick+0x150>
	{
		if( Timer_Tbl[i].Timer_En == ON)   					// 타이머가 활성화 됬니?
  4109bc:	e0ffff03 	ldbu	r3,-4(fp)
  4109c0:	008010b4 	movhi	r2,66
  4109c4:	10a09404 	addi	r2,r2,-32176
  4109c8:	1806913a 	slli	r3,r3,4
  4109cc:	10c5883a 	add	r2,r2,r3
  4109d0:	10800003 	ldbu	r2,0(r2)
  4109d4:	10803fcc 	andi	r2,r2,255
  4109d8:	10800058 	cmpnei	r2,r2,1
  4109dc:	1000391e 	bne	r2,zero,410ac4 <Hw_Timer_Tick+0x144>
		{
			Timer_Tbl[i].Timer_Ctn--;  						// 타이머값 감소
  4109e0:	e0ffff03 	ldbu	r3,-4(fp)
  4109e4:	008010b4 	movhi	r2,66
  4109e8:	10a09404 	addi	r2,r2,-32176
  4109ec:	1808913a 	slli	r4,r3,4
  4109f0:	1105883a 	add	r2,r2,r4
  4109f4:	1080008b 	ldhu	r2,2(r2)
  4109f8:	10bfffc4 	addi	r2,r2,-1
  4109fc:	1009883a 	mov	r4,r2
  410a00:	008010b4 	movhi	r2,66
  410a04:	10a09404 	addi	r2,r2,-32176
  410a08:	1806913a 	slli	r3,r3,4
  410a0c:	10c5883a 	add	r2,r2,r3
  410a10:	1100008d 	sth	r4,2(r2)

			if(Timer_Tbl[i].Timer_Ctn == 0) 				// 타이머 오버플로어
  410a14:	e0ffff03 	ldbu	r3,-4(fp)
  410a18:	008010b4 	movhi	r2,66
  410a1c:	10a09404 	addi	r2,r2,-32176
  410a20:	1806913a 	slli	r3,r3,4
  410a24:	10c5883a 	add	r2,r2,r3
  410a28:	1080008b 	ldhu	r2,2(r2)
  410a2c:	10bfffcc 	andi	r2,r2,65535
  410a30:	1000241e 	bne	r2,zero,410ac4 <Hw_Timer_Tick+0x144>
			{
				if(Timer_Tbl[i].Timer_Mode == ONE_TIME)  	// 한번만 실행하는거면
  410a34:	e0ffff03 	ldbu	r3,-4(fp)
  410a38:	008010b4 	movhi	r2,66
  410a3c:	10a09404 	addi	r2,r2,-32176
  410a40:	1806913a 	slli	r3,r3,4
  410a44:	10c5883a 	add	r2,r2,r3
  410a48:	10800043 	ldbu	r2,1(r2)
  410a4c:	10803fcc 	andi	r2,r2,255
  410a50:	10800058 	cmpnei	r2,r2,1
  410a54:	1000061e 	bne	r2,zero,410a70 <Hw_Timer_Tick+0xf0>

				Timer_Tbl[i].Timer_En = OFF;     			// 타이머 OFF 한다.
  410a58:	e0ffff03 	ldbu	r3,-4(fp)
  410a5c:	008010b4 	movhi	r2,66
  410a60:	10a09404 	addi	r2,r2,-32176
  410a64:	1806913a 	slli	r3,r3,4
  410a68:	10c5883a 	add	r2,r2,r3
  410a6c:	10000005 	stb	zero,0(r2)

				Timer_Tbl[i].Timer_Ctn = Timer_Tbl[i].Timer_Init; // 타이머 초기화
  410a70:	e13fff03 	ldbu	r4,-4(fp)
  410a74:	e0ffff03 	ldbu	r3,-4(fp)
  410a78:	008010b4 	movhi	r2,66
  410a7c:	10a09404 	addi	r2,r2,-32176
  410a80:	1806913a 	slli	r3,r3,4
  410a84:	18c00104 	addi	r3,r3,4
  410a88:	10c5883a 	add	r2,r2,r3
  410a8c:	10c0000b 	ldhu	r3,0(r2)
  410a90:	008010b4 	movhi	r2,66
  410a94:	10a09404 	addi	r2,r2,-32176
  410a98:	2008913a 	slli	r4,r4,4
  410a9c:	1105883a 	add	r2,r2,r4
  410aa0:	10c0008d 	sth	r3,2(r2)

				(*Timer_Tbl[i].TmrFnct)();  				// 전달변수 없이 함수 실행
  410aa4:	e0ffff03 	ldbu	r3,-4(fp)
  410aa8:	008010b4 	movhi	r2,66
  410aac:	10a09404 	addi	r2,r2,-32176
  410ab0:	1806913a 	slli	r3,r3,4
  410ab4:	18c00204 	addi	r3,r3,8
  410ab8:	10c5883a 	add	r2,r2,r3
  410abc:	10800017 	ldw	r2,0(r2)
  410ac0:	103ee83a 	callr	r2

	if( Tmr_Ctn ) Tmr_Ctn--;
	
	
			   
	for(i=0; i<TIMER_MAX; i++)								// 타이머 갯수만큼
  410ac4:	e0bfff03 	ldbu	r2,-4(fp)
  410ac8:	10800044 	addi	r2,r2,1
  410acc:	e0bfff05 	stb	r2,-4(fp)
  410ad0:	e0bfff03 	ldbu	r2,-4(fp)
  410ad4:	108002b0 	cmpltui	r2,r2,10
  410ad8:	103fb81e 	bne	r2,zero,4109bc <_gp+0xffff0cec>
				(*Timer_Tbl[i].TmrFnct)();  				// 전달변수 없이 함수 실행
			}
		}
	}
	
}
  410adc:	e037883a 	mov	sp,fp
  410ae0:	dfc00117 	ldw	ra,4(sp)
  410ae4:	df000017 	ldw	fp,0(sp)
  410ae8:	dec00204 	addi	sp,sp,8
  410aec:	f800283a 	ret

00410af0 <Hw_Timer_Set>:
			void (*Fnct)(void),void *arg : 실행할 타이머 함수.
     RET
     	 	void
---------------------------------------------------------------------------*/
void Hw_Timer_Set(u8 TmrNum, u16 TmrData, u8 TmrMode, void (*Fnct)(void),void *arg)
{
  410af0:	defffb04 	addi	sp,sp,-20
  410af4:	df000415 	stw	fp,16(sp)
  410af8:	df000404 	addi	fp,sp,16
  410afc:	2807883a 	mov	r3,r5
  410b00:	3005883a 	mov	r2,r6
  410b04:	e1ffff15 	stw	r7,-4(fp)
  410b08:	e13ffc05 	stb	r4,-16(fp)
  410b0c:	e0fffd0d 	sth	r3,-12(fp)
  410b10:	e0bffe05 	stb	r2,-8(fp)
	Timer_Tbl[TmrNum].Timer_Mode = TmrMode;    // 모트설정
  410b14:	e0fffc03 	ldbu	r3,-16(fp)
  410b18:	008010b4 	movhi	r2,66
  410b1c:	10a09404 	addi	r2,r2,-32176
  410b20:	1806913a 	slli	r3,r3,4
  410b24:	10c5883a 	add	r2,r2,r3
  410b28:	e0fffe03 	ldbu	r3,-8(fp)
  410b2c:	10c00045 	stb	r3,1(r2)
	Timer_Tbl[TmrNum].TmrFnct    = Fnct;       // 실행할 함수
  410b30:	e0fffc03 	ldbu	r3,-16(fp)
  410b34:	008010b4 	movhi	r2,66
  410b38:	10a09404 	addi	r2,r2,-32176
  410b3c:	1806913a 	slli	r3,r3,4
  410b40:	18c00204 	addi	r3,r3,8
  410b44:	10c5883a 	add	r2,r2,r3
  410b48:	e0ffff17 	ldw	r3,-4(fp)
  410b4c:	10c00015 	stw	r3,0(r2)
	Timer_Tbl[TmrNum].TmrFnctArg = arg;        // 매개변수
  410b50:	e0fffc03 	ldbu	r3,-16(fp)
  410b54:	008010b4 	movhi	r2,66
  410b58:	10a09404 	addi	r2,r2,-32176
  410b5c:	1806913a 	slli	r3,r3,4
  410b60:	18c00304 	addi	r3,r3,12
  410b64:	10c5883a 	add	r2,r2,r3
  410b68:	e0c00117 	ldw	r3,4(fp)
  410b6c:	10c00015 	stw	r3,0(r2)
	Timer_Tbl[TmrNum].Timer_Ctn  = TmrData;
  410b70:	e0fffc03 	ldbu	r3,-16(fp)
  410b74:	008010b4 	movhi	r2,66
  410b78:	10a09404 	addi	r2,r2,-32176
  410b7c:	1806913a 	slli	r3,r3,4
  410b80:	10c5883a 	add	r2,r2,r3
  410b84:	e0fffd0b 	ldhu	r3,-12(fp)
  410b88:	10c0008d 	sth	r3,2(r2)
	Timer_Tbl[TmrNum].Timer_Init = TmrData;
  410b8c:	e0fffc03 	ldbu	r3,-16(fp)
  410b90:	008010b4 	movhi	r2,66
  410b94:	10a09404 	addi	r2,r2,-32176
  410b98:	1806913a 	slli	r3,r3,4
  410b9c:	18c00104 	addi	r3,r3,4
  410ba0:	10c5883a 	add	r2,r2,r3
  410ba4:	e0fffd0b 	ldhu	r3,-12(fp)
  410ba8:	10c0000d 	sth	r3,0(r2)
}
  410bac:	e037883a 	mov	sp,fp
  410bb0:	df000017 	ldw	fp,0(sp)
  410bb4:	dec00104 	addi	sp,sp,4
  410bb8:	f800283a 	ret

00410bbc <Hw_Timer_Start>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_Start(u8 TmrNum)
{
  410bbc:	defffe04 	addi	sp,sp,-8
  410bc0:	df000115 	stw	fp,4(sp)
  410bc4:	df000104 	addi	fp,sp,4
  410bc8:	2005883a 	mov	r2,r4
  410bcc:	e0bfff05 	stb	r2,-4(fp)
	if(TmrNum < TIMER_MAX)
  410bd0:	e0bfff03 	ldbu	r2,-4(fp)
  410bd4:	108002a8 	cmpgeui	r2,r2,10
  410bd8:	1000071e 	bne	r2,zero,410bf8 <Hw_Timer_Start+0x3c>
		Timer_Tbl[TmrNum].Timer_En = ON;
  410bdc:	e0ffff03 	ldbu	r3,-4(fp)
  410be0:	008010b4 	movhi	r2,66
  410be4:	10a09404 	addi	r2,r2,-32176
  410be8:	1806913a 	slli	r3,r3,4
  410bec:	10c5883a 	add	r2,r2,r3
  410bf0:	00c00044 	movi	r3,1
  410bf4:	10c00005 	stb	r3,0(r2)
}
  410bf8:	e037883a 	mov	sp,fp
  410bfc:	df000017 	ldw	fp,0(sp)
  410c00:	dec00104 	addi	sp,sp,4
  410c04:	f800283a 	ret

00410c08 <Hw_Timer_Stop>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_Stop(u8 TmrNum)
{
  410c08:	defffe04 	addi	sp,sp,-8
  410c0c:	df000115 	stw	fp,4(sp)
  410c10:	df000104 	addi	fp,sp,4
  410c14:	2005883a 	mov	r2,r4
  410c18:	e0bfff05 	stb	r2,-4(fp)
	if(TmrNum < TIMER_MAX)
  410c1c:	e0bfff03 	ldbu	r2,-4(fp)
  410c20:	108002a8 	cmpgeui	r2,r2,10
  410c24:	1000061e 	bne	r2,zero,410c40 <Hw_Timer_Stop+0x38>
		Timer_Tbl[TmrNum].Timer_En = OFF;
  410c28:	e0ffff03 	ldbu	r3,-4(fp)
  410c2c:	008010b4 	movhi	r2,66
  410c30:	10a09404 	addi	r2,r2,-32176
  410c34:	1806913a 	slli	r3,r3,4
  410c38:	10c5883a 	add	r2,r2,r3
  410c3c:	10000005 	stb	zero,0(r2)
}
  410c40:	e037883a 	mov	sp,fp
  410c44:	df000017 	ldw	fp,0(sp)
  410c48:	dec00104 	addi	sp,sp,4
  410c4c:	f800283a 	ret

00410c50 <Hw_Timer_Reset>:
     	 	 - 타이머값 초기화
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_Reset(u8 TmrNum)
{
  410c50:	defffe04 	addi	sp,sp,-8
  410c54:	df000115 	stw	fp,4(sp)
  410c58:	df000104 	addi	fp,sp,4
  410c5c:	2005883a 	mov	r2,r4
  410c60:	e0bfff05 	stb	r2,-4(fp)
	Timer_Tbl[TmrNum].Timer_En   = OFF;
  410c64:	e0ffff03 	ldbu	r3,-4(fp)
  410c68:	008010b4 	movhi	r2,66
  410c6c:	10a09404 	addi	r2,r2,-32176
  410c70:	1806913a 	slli	r3,r3,4
  410c74:	10c5883a 	add	r2,r2,r3
  410c78:	10000005 	stb	zero,0(r2)
	Timer_Tbl[TmrNum].Timer_Ctn  = Timer_Tbl[TmrNum].Timer_Init;
  410c7c:	e13fff03 	ldbu	r4,-4(fp)
  410c80:	e0ffff03 	ldbu	r3,-4(fp)
  410c84:	008010b4 	movhi	r2,66
  410c88:	10a09404 	addi	r2,r2,-32176
  410c8c:	1806913a 	slli	r3,r3,4
  410c90:	18c00104 	addi	r3,r3,4
  410c94:	10c5883a 	add	r2,r2,r3
  410c98:	10c0000b 	ldhu	r3,0(r2)
  410c9c:	008010b4 	movhi	r2,66
  410ca0:	10a09404 	addi	r2,r2,-32176
  410ca4:	2008913a 	slli	r4,r4,4
  410ca8:	1105883a 	add	r2,r2,r4
  410cac:	10c0008d 	sth	r3,2(r2)
}
  410cb0:	e037883a 	mov	sp,fp
  410cb4:	df000017 	ldw	fp,0(sp)
  410cb8:	dec00104 	addi	sp,sp,4
  410cbc:	f800283a 	ret

00410cc0 <Hw_Timer_Delay_ms>:
     	 	 ms 단위로 딜레이를 준다.
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_Delay_ms( u16 DelayData )
{
  410cc0:	defffe04 	addi	sp,sp,-8
  410cc4:	df000115 	stw	fp,4(sp)
  410cc8:	df000104 	addi	fp,sp,4
  410ccc:	2005883a 	mov	r2,r4
  410cd0:	e0bfff0d 	sth	r2,-4(fp)
	Tmr_Ctn = DelayData;
  410cd4:	e0bfff0b 	ldhu	r2,-4(fp)
  410cd8:	d0a1320d 	sth	r2,-31544(gp)
	
	while( Tmr_Ctn );
  410cdc:	0001883a 	nop
  410ce0:	d0a1320b 	ldhu	r2,-31544(gp)
  410ce4:	10bfffcc 	andi	r2,r2,65535
  410ce8:	103ffd1e 	bne	r2,zero,410ce0 <_gp+0xffff1010>
}
  410cec:	e037883a 	mov	sp,fp
  410cf0:	df000017 	ldw	fp,0(sp)
  410cf4:	dec00104 	addi	sp,sp,4
  410cf8:	f800283a 	ret

00410cfc <Hw_Timer_Get_Handle>:
     	 	 ms 단위로 딜레이를 준다.
     ARG
     RET
---------------------------------------------------------------------------*/
s16 Hw_Timer_Get_Handle( void )
{
  410cfc:	defffe04 	addi	sp,sp,-8
  410d00:	df000115 	stw	fp,4(sp)
  410d04:	df000104 	addi	fp,sp,4
	s16 TmrIndex = Tmr_HandleIndex;
  410d08:	d0a1328b 	ldhu	r2,-31542(gp)
  410d0c:	e0bfff0d 	sth	r2,-4(fp)
	
	Tmr_HandleIndex++;
  410d10:	d0a1328b 	ldhu	r2,-31542(gp)
  410d14:	10800044 	addi	r2,r2,1
  410d18:	d0a1328d 	sth	r2,-31542(gp)
	
	return TmrIndex;
  410d1c:	e0bfff0b 	ldhu	r2,-4(fp)
}
  410d20:	e037883a 	mov	sp,fp
  410d24:	df000017 	ldw	fp,0(sp)
  410d28:	dec00104 	addi	sp,sp,4
  410d2c:	f800283a 	ret

00410d30 <Hw_Timer_Get_CountValue>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
u32 Hw_Timer_Get_CountValue( void )
{
  410d30:	defffe04 	addi	sp,sp,-8
  410d34:	dfc00115 	stw	ra,4(sp)
  410d38:	df000015 	stw	fp,0(sp)
  410d3c:	d839883a 	mov	fp,sp
	return millis();
  410d40:	04119e00 	call	4119e0 <millis>
}
  410d44:	e037883a 	mov	sp,fp
  410d48:	dfc00117 	ldw	ra,4(sp)
  410d4c:	df000017 	ldw	fp,0(sp)
  410d50:	dec00204 	addi	sp,sp,8
  410d54:	f800283a 	ret

00410d58 <Hw_Timer_TimeStart>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_TimeStart( HW_TIMER_TIME_OBJ *TimerTimePtr )
{
  410d58:	defffd04 	addi	sp,sp,-12
  410d5c:	dfc00215 	stw	ra,8(sp)
  410d60:	df000115 	stw	fp,4(sp)
  410d64:	df000104 	addi	fp,sp,4
  410d68:	e13fff15 	stw	r4,-4(fp)
	TimerTimePtr->Start = Hw_Timer_Get_CountValue();
  410d6c:	0410d300 	call	410d30 <Hw_Timer_Get_CountValue>
  410d70:	1007883a 	mov	r3,r2
  410d74:	e0bfff17 	ldw	r2,-4(fp)
  410d78:	10c00015 	stw	r3,0(r2)
}
  410d7c:	e037883a 	mov	sp,fp
  410d80:	dfc00117 	ldw	ra,4(sp)
  410d84:	df000017 	ldw	fp,0(sp)
  410d88:	dec00204 	addi	sp,sp,8
  410d8c:	f800283a 	ret

00410d90 <Hw_Timer_TimeGetElapse>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
u32 Hw_Timer_TimeGetElapse( HW_TIMER_TIME_OBJ *TimerTimePtr )
{
  410d90:	defffe04 	addi	sp,sp,-8
  410d94:	df000115 	stw	fp,4(sp)
  410d98:	df000104 	addi	fp,sp,4
  410d9c:	e13fff15 	stw	r4,-4(fp)
	return (Hw_Timer_Counter - TimerTimePtr->Start);
  410da0:	d0e13117 	ldw	r3,-31548(gp)
  410da4:	e0bfff17 	ldw	r2,-4(fp)
  410da8:	10800017 	ldw	r2,0(r2)
  410dac:	1885c83a 	sub	r2,r3,r2
}
  410db0:	e037883a 	mov	sp,fp
  410db4:	df000017 	ldw	fp,0(sp)
  410db8:	dec00104 	addi	sp,sp,4
  410dbc:	f800283a 	ret

00410dc0 <Hw_Uart_ISR_Handler>:




static void Hw_Uart_ISR_Handler(void* context)
{
  410dc0:	defffa04 	addi	sp,sp,-24
  410dc4:	dfc00515 	stw	ra,20(sp)
  410dc8:	df000415 	stw	fp,16(sp)
  410dcc:	df000404 	addi	fp,sp,16
  410dd0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 status;
	u8      UartData;

	HW_UART_OBJ *pUart = (HW_UART_OBJ *)context;
  410dd4:	e0bfff17 	ldw	r2,-4(fp)
  410dd8:	e0bffc15 	stw	r2,-16(fp)



	//-- 상태 읽기
	//
	status = IORD_ALTERA_AVALON_UART_STATUS(pUart->pBase);
  410ddc:	e0bffc17 	ldw	r2,-16(fp)
  410de0:	10800317 	ldw	r2,12(r2)
  410de4:	10800204 	addi	r2,r2,8
  410de8:	10800037 	ldwio	r2,0(r2)
  410dec:	e0bffd15 	stw	r2,-12(fp)

	//-- Clear any error flags set at the device
	//
	IOWR_ALTERA_AVALON_UART_STATUS(pUart->pBase, 0);
  410df0:	e0bffc17 	ldw	r2,-16(fp)
  410df4:	10800317 	ldw	r2,12(r2)
  410df8:	10800204 	addi	r2,r2,8
  410dfc:	0007883a 	mov	r3,zero
  410e00:	10c00035 	stwio	r3,0(r2)

	//-- Dummy read to ensure IRQ is negated before ISR returns
	//
	IORD_ALTERA_AVALON_UART_STATUS(pUart->pBase);
  410e04:	e0bffc17 	ldw	r2,-16(fp)
  410e08:	10800317 	ldw	r2,12(r2)
  410e0c:	10800204 	addi	r2,r2,8
  410e10:	10800037 	ldwio	r2,0(r2)


	//-- RX 인터럽트 처리
	//
	if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  410e14:	e0bffd17 	ldw	r2,-12(fp)
  410e18:	1080200c 	andi	r2,r2,128
  410e1c:	10001926 	beq	r2,zero,410e84 <Hw_Uart_ISR_Handler+0xc4>
	{
		if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | ALTERA_AVALON_UART_STATUS_FE_MSK))
  410e20:	e0bffd17 	ldw	r2,-12(fp)
  410e24:	108000cc 	andi	r2,r2,3
  410e28:	1000161e 	bne	r2,zero,410e84 <Hw_Uart_ISR_Handler+0xc4>
		{
			return;
		}

		UartData = IORD_ALTERA_AVALON_UART_RXDATA(pUart->pBase);
  410e2c:	e0bffc17 	ldw	r2,-16(fp)
  410e30:	10800317 	ldw	r2,12(r2)
  410e34:	10800037 	ldwio	r2,0(r2)
  410e38:	e0bffe05 	stb	r2,-8(fp)

		Hw_Uart_Q_Push( pUart->Port, &UartData );
  410e3c:	e0bffc17 	ldw	r2,-16(fp)
  410e40:	10800017 	ldw	r2,0(r2)
  410e44:	10c03fcc 	andi	r3,r2,255
  410e48:	e0bffe04 	addi	r2,fp,-8
  410e4c:	1809883a 	mov	r4,r3
  410e50:	100b883a 	mov	r5,r2
  410e54:	04115380 	call	411538 <Hw_Uart_Q_Push>

		if( pUart->ISR_FuncPtr != NULL )
  410e58:	e0bffc17 	ldw	r2,-16(fp)
  410e5c:	10800217 	ldw	r2,8(r2)
  410e60:	10000826 	beq	r2,zero,410e84 <Hw_Uart_ISR_Handler+0xc4>
		{
			(*pUart->ISR_FuncPtr)(UartData);
  410e64:	e0bffc17 	ldw	r2,-16(fp)
  410e68:	10800217 	ldw	r2,8(r2)
  410e6c:	e0fffe03 	ldbu	r3,-8(fp)
  410e70:	18c03fcc 	andi	r3,r3,255
  410e74:	18c0201c 	xori	r3,r3,128
  410e78:	18ffe004 	addi	r3,r3,-128
  410e7c:	1809883a 	mov	r4,r3
  410e80:	103ee83a 	callr	r2
		}
	}
}
  410e84:	e037883a 	mov	sp,fp
  410e88:	dfc00117 	ldw	ra,4(sp)
  410e8c:	df000017 	ldw	fp,0(sp)
  410e90:	dec00204 	addi	sp,sp,8
  410e94:	f800283a 	ret

00410e98 <Hw_Uart_Init>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Init( void )
{
  410e98:	defffd04 	addi	sp,sp,-12
  410e9c:	dfc00215 	stw	ra,8(sp)
  410ea0:	df000115 	stw	fp,4(sp)
  410ea4:	df000104 	addi	fp,sp,4
	u32 i;
	
	Hw_Uart_Q_Init();
  410ea8:	04113900 	call	411390 <Hw_Uart_Q_Init>
	
	
	for( i=0; i<HW_UART_MAX_CH; i++ )
  410eac:	e03fff15 	stw	zero,-4(fp)
  410eb0:	00001106 	br	410ef8 <Hw_Uart_Init+0x60>
	{
		Hw_Uart_Ch[i].Baud 		  = 0;
  410eb4:	008010b4 	movhi	r2,66
  410eb8:	10a0bc04 	addi	r2,r2,-32016
  410ebc:	e0ffff17 	ldw	r3,-4(fp)
  410ec0:	1806913a 	slli	r3,r3,4
  410ec4:	18c00104 	addi	r3,r3,4
  410ec8:	10c5883a 	add	r2,r2,r3
  410ecc:	10000015 	stw	zero,0(r2)
		Hw_Uart_Ch[i].ISR_FuncPtr = NULL;
  410ed0:	008010b4 	movhi	r2,66
  410ed4:	10a0bc04 	addi	r2,r2,-32016
  410ed8:	e0ffff17 	ldw	r3,-4(fp)
  410edc:	1806913a 	slli	r3,r3,4
  410ee0:	18c00204 	addi	r3,r3,8
  410ee4:	10c5883a 	add	r2,r2,r3
  410ee8:	10000015 	stw	zero,0(r2)
	u32 i;
	
	Hw_Uart_Q_Init();
	
	
	for( i=0; i<HW_UART_MAX_CH; i++ )
  410eec:	e0bfff17 	ldw	r2,-4(fp)
  410ef0:	10800044 	addi	r2,r2,1
  410ef4:	e0bfff15 	stw	r2,-4(fp)
  410ef8:	e0bfff17 	ldw	r2,-4(fp)
  410efc:	108001b0 	cmpltui	r2,r2,6
  410f00:	103fec1e 	bne	r2,zero,410eb4 <_gp+0xffff11e4>
		Hw_Uart_Ch[i].Baud 		  = 0;
		Hw_Uart_Ch[i].ISR_FuncPtr = NULL;
	}	
	
	
	Hw_Uart_Open( HW_UART_COM1, 115200, NULL );
  410f04:	0009883a 	mov	r4,zero
  410f08:	014000b4 	movhi	r5,2
  410f0c:	29708004 	addi	r5,r5,-15872
  410f10:	000d883a 	mov	r6,zero
  410f14:	0410f5c0 	call	410f5c <Hw_Uart_Open>
	Hw_Uart_Open( HW_UART_COM2, 115200, NULL );	
  410f18:	01000044 	movi	r4,1
  410f1c:	014000b4 	movhi	r5,2
  410f20:	29708004 	addi	r5,r5,-15872
  410f24:	000d883a 	mov	r6,zero
  410f28:	0410f5c0 	call	410f5c <Hw_Uart_Open>
}
  410f2c:	e037883a 	mov	sp,fp
  410f30:	dfc00117 	ldw	ra,4(sp)
  410f34:	df000017 	ldw	fp,0(sp)
  410f38:	dec00204 	addi	sp,sp,8
  410f3c:	f800283a 	ret

00410f40 <Hw_Uart_DeInit>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_DeInit( void )
{
  410f40:	deffff04 	addi	sp,sp,-4
  410f44:	df000015 	stw	fp,0(sp)
  410f48:	d839883a 	mov	fp,sp

}
  410f4c:	e037883a 	mov	sp,fp
  410f50:	df000017 	ldw	fp,0(sp)
  410f54:	dec00104 	addi	sp,sp,4
  410f58:	f800283a 	ret

00410f5c <Hw_Uart_Open>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Open( u8 Ch, u32 BaudData, void (*ISR_FuncPtr)(char Ch) )
{	
  410f5c:	defffb04 	addi	sp,sp,-20
  410f60:	dfc00415 	stw	ra,16(sp)
  410f64:	df000315 	stw	fp,12(sp)
  410f68:	df000304 	addi	fp,sp,12
  410f6c:	2005883a 	mov	r2,r4
  410f70:	e17ffe15 	stw	r5,-8(fp)
  410f74:	e1bfff15 	stw	r6,-4(fp)
  410f78:	e0bffd05 	stb	r2,-12(fp)
	switch( Ch )
  410f7c:	e0bffd03 	ldbu	r2,-12(fp)
  410f80:	10c00168 	cmpgeui	r3,r2,5
  410f84:	1800141e 	bne	r3,zero,410fd8 <Hw_Uart_Open+0x7c>
  410f88:	100690ba 	slli	r3,r2,2
  410f8c:	00801074 	movhi	r2,65
  410f90:	1083e804 	addi	r2,r2,4000
  410f94:	1885883a 	add	r2,r3,r2
  410f98:	10800017 	ldw	r2,0(r2)
  410f9c:	1000683a 	jmp	r2
  410fa0:	00410fb4 	movhi	at,1086
  410fa4:	00410fc4 	movi	at,1087
  410fa8:	00410fd4 	movui	at,1087
  410fac:	00410fd4 	movui	at,1087
  410fb0:	00410fd4 	movui	at,1087
	{
		case HW_UART_COM1:
			Hw_Uart_Open_COM1( BaudData, ISR_FuncPtr );
  410fb4:	e13ffe17 	ldw	r4,-8(fp)
  410fb8:	e17fff17 	ldw	r5,-4(fp)
  410fbc:	0410fec0 	call	410fec <Hw_Uart_Open_COM1>
			break;
  410fc0:	00000506 	br	410fd8 <Hw_Uart_Open+0x7c>
			
		case HW_UART_COM2:
			Hw_Uart_Open_COM2( BaudData, ISR_FuncPtr );
  410fc4:	e13ffe17 	ldw	r4,-8(fp)
  410fc8:	e17fff17 	ldw	r5,-4(fp)
  410fcc:	04110980 	call	411098 <Hw_Uart_Open_COM2>
			break;
  410fd0:	00000106 	br	410fd8 <Hw_Uart_Open+0x7c>

		case HW_UART_COM4:
			break;

		case HW_UART_COM5:
			break;			
  410fd4:	0001883a 	nop
	}
}
  410fd8:	e037883a 	mov	sp,fp
  410fdc:	dfc00117 	ldw	ra,4(sp)
  410fe0:	df000017 	ldw	fp,0(sp)
  410fe4:	dec00204 	addi	sp,sp,8
  410fe8:	f800283a 	ret

00410fec <Hw_Uart_Open_COM1>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Open_COM1( u32 BaudData, void (*ISR_FuncPtr)(char Ch) )
{	
  410fec:	defff904 	addi	sp,sp,-28
  410ff0:	dfc00615 	stw	ra,24(sp)
  410ff4:	df000515 	stw	fp,20(sp)
  410ff8:	df000504 	addi	fp,sp,20
  410ffc:	e13ffe15 	stw	r4,-8(fp)
  411000:	e17fff15 	stw	r5,-4(fp)
	u32 Reg;
	void *pBase = (void *)UART_0_BASE;
  411004:	008010b4 	movhi	r2,66
  411008:	10863804 	addi	r2,r2,6368
  41100c:	e0bffc15 	stw	r2,-16(fp)


	Hw_Uart_Ch[HW_UART_COM1].Port 		 = HW_UART_COM1;
  411010:	008010b4 	movhi	r2,66
  411014:	10a0bc04 	addi	r2,r2,-32016
  411018:	10000015 	stw	zero,0(r2)
	Hw_Uart_Ch[HW_UART_COM1].Baud 		 = BaudData;
  41101c:	008010b4 	movhi	r2,66
  411020:	10a0bc04 	addi	r2,r2,-32016
  411024:	e0fffe17 	ldw	r3,-8(fp)
  411028:	10c00115 	stw	r3,4(r2)
	Hw_Uart_Ch[HW_UART_COM1].ISR_FuncPtr = ISR_FuncPtr;
  41102c:	008010b4 	movhi	r2,66
  411030:	10a0bc04 	addi	r2,r2,-32016
  411034:	e0ffff17 	ldw	r3,-4(fp)
  411038:	10c00215 	stw	r3,8(r2)
	Hw_Uart_Ch[HW_UART_COM1].pBase       = pBase;
  41103c:	008010b4 	movhi	r2,66
  411040:	10a0bc04 	addi	r2,r2,-32016
  411044:	e0fffc17 	ldw	r3,-16(fp)
  411048:	10c00315 	stw	r3,12(r2)


	//-- 인터럽트 활성화
	//
	Reg = ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  41104c:	00802004 	movi	r2,128
  411050:	e0bffd15 	stw	r2,-12(fp)


	IOWR_ALTERA_AVALON_UART_CONTROL(pBase, Reg);
  411054:	e0bffc17 	ldw	r2,-16(fp)
  411058:	10800304 	addi	r2,r2,12
  41105c:	e0fffd17 	ldw	r3,-12(fp)
  411060:	10c00035 	stwio	r3,0(r2)


	//-- 인터럽트 연결
	//
    alt_ic_isr_register( UART_0_IRQ_INTERRUPT_CONTROLLER_ID, UART_0_IRQ, Hw_Uart_ISR_Handler, (void *)&Hw_Uart_Ch[HW_UART_COM1], 0x0);
  411064:	d8000015 	stw	zero,0(sp)
  411068:	0009883a 	mov	r4,zero
  41106c:	01400044 	movi	r5,1
  411070:	01801074 	movhi	r6,65
  411074:	31837004 	addi	r6,r6,3520
  411078:	01c010b4 	movhi	r7,66
  41107c:	39e0bc04 	addi	r7,r7,-32016
  411080:	0413f140 	call	413f14 <alt_ic_isr_register>
}
  411084:	e037883a 	mov	sp,fp
  411088:	dfc00117 	ldw	ra,4(sp)
  41108c:	df000017 	ldw	fp,0(sp)
  411090:	dec00204 	addi	sp,sp,8
  411094:	f800283a 	ret

00411098 <Hw_Uart_Open_COM2>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Open_COM2( u32 BaudData, void (*ISR_FuncPtr)(char Ch) )
{	
  411098:	defffd04 	addi	sp,sp,-12
  41109c:	df000215 	stw	fp,8(sp)
  4110a0:	df000204 	addi	fp,sp,8
  4110a4:	e13ffe15 	stw	r4,-8(fp)
  4110a8:	e17fff15 	stw	r5,-4(fp)

	Hw_Uart_Ch[HW_UART_COM2].Baud 		 = BaudData;
  4110ac:	008010b4 	movhi	r2,66
  4110b0:	10a0bc04 	addi	r2,r2,-32016
  4110b4:	e0fffe17 	ldw	r3,-8(fp)
  4110b8:	10c00515 	stw	r3,20(r2)
	Hw_Uart_Ch[HW_UART_COM2].ISR_FuncPtr = ISR_FuncPtr;
  4110bc:	008010b4 	movhi	r2,66
  4110c0:	10a0bc04 	addi	r2,r2,-32016
  4110c4:	e0ffff17 	ldw	r3,-4(fp)
  4110c8:	10c00615 	stw	r3,24(r2)
}
  4110cc:	e037883a 	mov	sp,fp
  4110d0:	df000017 	ldw	fp,0(sp)
  4110d4:	dec00104 	addi	sp,sp,4
  4110d8:	f800283a 	ret

004110dc <Hw_Uart_SetReceiveFuncISR>:
			: 시리얼 포트에서 데이터 수신시 실행할 함수 설정 .
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_SetReceiveFuncISR( u8 Ch, void (*ISR_FuncPtr)(char Ch) )
{
  4110dc:	defffd04 	addi	sp,sp,-12
  4110e0:	df000215 	stw	fp,8(sp)
  4110e4:	df000204 	addi	fp,sp,8
  4110e8:	2005883a 	mov	r2,r4
  4110ec:	e17fff15 	stw	r5,-4(fp)
  4110f0:	e0bffe05 	stb	r2,-8(fp)
	Hw_Uart_Ch[Ch].ISR_FuncPtr = ISR_FuncPtr;
  4110f4:	e0fffe03 	ldbu	r3,-8(fp)
  4110f8:	008010b4 	movhi	r2,66
  4110fc:	10a0bc04 	addi	r2,r2,-32016
  411100:	1806913a 	slli	r3,r3,4
  411104:	18c00204 	addi	r3,r3,8
  411108:	10c5883a 	add	r2,r2,r3
  41110c:	e0ffff17 	ldw	r3,-4(fp)
  411110:	10c00015 	stw	r3,0(r2)
}
  411114:	e037883a 	mov	sp,fp
  411118:	df000017 	ldw	fp,0(sp)
  41111c:	dec00104 	addi	sp,sp,4
  411120:	f800283a 	ret

00411124 <Hw_Uart_Getch>:
			: 시리얼 포트에서 문자 1바이트 읽는다.
     ARG
     RET
---------------------------------------------------------------------------*/
u8 Hw_Uart_Getch( u8 Ch )
{
  411124:	defffc04 	addi	sp,sp,-16
  411128:	dfc00315 	stw	ra,12(sp)
  41112c:	df000215 	stw	fp,8(sp)
  411130:	df000204 	addi	fp,sp,8
  411134:	2005883a 	mov	r2,r4
  411138:	e0bfff05 	stb	r2,-4(fp)
	u8 Uart_GetData = 0;
  41113c:	e03ffe05 	stb	zero,-8(fp)

	while( 1 )
	{
		// 버퍼에 데이터 들어올때까지 기다린다.
		if( HW_UART_Q_VAILD(Ch) > 0 ) break;
  411140:	e0bfff03 	ldbu	r2,-4(fp)
  411144:	1009883a 	mov	r4,r2
  411148:	04114a40 	call	4114a4 <HW_UART_Q_VAILD>
  41114c:	10000126 	beq	r2,zero,411154 <Hw_Uart_Getch+0x30>
  411150:	00000106 	br	411158 <Hw_Uart_Getch+0x34>
	}
  411154:	003ffa06 	br	411140 <_gp+0xffff1470>

	Hw_Uart_Q_Pop( Ch, &Uart_GetData );
  411158:	e0bfff03 	ldbu	r2,-4(fp)
  41115c:	1009883a 	mov	r4,r2
  411160:	e17ffe04 	addi	r5,fp,-8
  411164:	04116700 	call	411670 <Hw_Uart_Q_Pop>

	return Uart_GetData;
  411168:	e0bffe03 	ldbu	r2,-8(fp)
}
  41116c:	e037883a 	mov	sp,fp
  411170:	dfc00117 	ldw	ra,4(sp)
  411174:	df000017 	ldw	fp,0(sp)
  411178:	dec00204 	addi	sp,sp,8
  41117c:	f800283a 	ret

00411180 <Hw_Uart_Putch>:
			: 시리얼 포트로 문자 1바이트 전송
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_Putch( u8 Ch,  char Uart_PutData )
{
  411180:	defffc04 	addi	sp,sp,-16
  411184:	df000315 	stw	fp,12(sp)
  411188:	df000304 	addi	fp,sp,12
  41118c:	2007883a 	mov	r3,r4
  411190:	2805883a 	mov	r2,r5
  411194:	e0fffe05 	stb	r3,-8(fp)
  411198:	e0bfff05 	stb	r2,-4(fp)
	u32 Reg;


	switch( Ch )
  41119c:	e0bffe03 	ldbu	r2,-8(fp)
  4111a0:	10c001a8 	cmpgeui	r3,r2,6
  4111a4:	1800271e 	bne	r3,zero,411244 <Hw_Uart_Putch+0xc4>
  4111a8:	100690ba 	slli	r3,r2,2
  4111ac:	00801074 	movhi	r2,65
  4111b0:	10847004 	addi	r2,r2,4544
  4111b4:	1885883a 	add	r2,r3,r2
  4111b8:	10800017 	ldw	r2,0(r2)
  4111bc:	1000683a 	jmp	r2
  4111c0:	004111d8 	cmpnei	at,zero,1095
  4111c4:	00411240 	call	41124 <__alt_mem_epcs_flash_controller_0+0x20124>
  4111c8:	00411240 	call	41124 <__alt_mem_epcs_flash_controller_0+0x20124>
  4111cc:	00411240 	call	41124 <__alt_mem_epcs_flash_controller_0+0x20124>
  4111d0:	00411240 	call	41124 <__alt_mem_epcs_flash_controller_0+0x20124>
  4111d4:	00411240 	call	41124 <__alt_mem_epcs_flash_controller_0+0x20124>
	{
		case HW_UART_COM1:
			while(1)
			{
				Reg = IORD_ALTERA_AVALON_UART_STATUS( Hw_Uart_Ch[Ch].pBase );
  4111d8:	e0fffe03 	ldbu	r3,-8(fp)
  4111dc:	008010b4 	movhi	r2,66
  4111e0:	10a0bc04 	addi	r2,r2,-32016
  4111e4:	1806913a 	slli	r3,r3,4
  4111e8:	18c00304 	addi	r3,r3,12
  4111ec:	10c5883a 	add	r2,r2,r3
  4111f0:	10800017 	ldw	r2,0(r2)
  4111f4:	10800204 	addi	r2,r2,8
  4111f8:	10800037 	ldwio	r2,0(r2)
  4111fc:	e0bffd15 	stw	r2,-12(fp)
				if( Reg & ALTERA_AVALON_UART_STATUS_TRDY_MSK )
  411200:	e0bffd17 	ldw	r2,-12(fp)
  411204:	1080100c 	andi	r2,r2,64
  411208:	10000c26 	beq	r2,zero,41123c <Hw_Uart_Putch+0xbc>
				{
					IOWR_ALTERA_AVALON_UART_TXDATA( Hw_Uart_Ch[Ch].pBase, Uart_PutData );
  41120c:	e0fffe03 	ldbu	r3,-8(fp)
  411210:	008010b4 	movhi	r2,66
  411214:	10a0bc04 	addi	r2,r2,-32016
  411218:	1806913a 	slli	r3,r3,4
  41121c:	18c00304 	addi	r3,r3,12
  411220:	10c5883a 	add	r2,r2,r3
  411224:	10800017 	ldw	r2,0(r2)
  411228:	10800104 	addi	r2,r2,4
  41122c:	e0ffff07 	ldb	r3,-4(fp)
  411230:	10c00035 	stwio	r3,0(r2)
					break;
  411234:	0001883a 	nop
				}
			}
			break;
  411238:	00000206 	br	411244 <Hw_Uart_Putch+0xc4>
				if( Reg & ALTERA_AVALON_UART_STATUS_TRDY_MSK )
				{
					IOWR_ALTERA_AVALON_UART_TXDATA( Hw_Uart_Ch[Ch].pBase, Uart_PutData );
					break;
				}
			}
  41123c:	003fe606 	br	4111d8 <_gp+0xffff1508>

		case HW_UART_COM5:
			break;		

		case HW_UART_VCOM:
			break;	
  411240:	0001883a 	nop
	}	
}
  411244:	e037883a 	mov	sp,fp
  411248:	df000017 	ldw	fp,0(sp)
  41124c:	dec00104 	addi	sp,sp,4
  411250:	f800283a 	ret

00411254 <Hw_Uart_PrintEx>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_PrintEx( u8 Ch, char *UartPrintData )
{
  411254:	defffc04 	addi	sp,sp,-16
  411258:	dfc00315 	stw	ra,12(sp)
  41125c:	df000215 	stw	fp,8(sp)
  411260:	df000204 	addi	fp,sp,8
  411264:	2005883a 	mov	r2,r4
  411268:	e17fff15 	stw	r5,-4(fp)
  41126c:	e0bffe05 	stb	r2,-8(fp)
	while( *UartPrintData != '\0' )
  411270:	00000c06 	br	4112a4 <Hw_Uart_PrintEx+0x50>
	{
		Hw_Uart_Putch( Ch, *UartPrintData );
  411274:	e0fffe03 	ldbu	r3,-8(fp)
  411278:	e0bfff17 	ldw	r2,-4(fp)
  41127c:	10800003 	ldbu	r2,0(r2)
  411280:	10803fcc 	andi	r2,r2,255
  411284:	1080201c 	xori	r2,r2,128
  411288:	10bfe004 	addi	r2,r2,-128
  41128c:	1809883a 	mov	r4,r3
  411290:	100b883a 	mov	r5,r2
  411294:	04111800 	call	411180 <Hw_Uart_Putch>
		UartPrintData++;
  411298:	e0bfff17 	ldw	r2,-4(fp)
  41129c:	10800044 	addi	r2,r2,1
  4112a0:	e0bfff15 	stw	r2,-4(fp)
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_PrintEx( u8 Ch, char *UartPrintData )
{
	while( *UartPrintData != '\0' )
  4112a4:	e0bfff17 	ldw	r2,-4(fp)
  4112a8:	10800003 	ldbu	r2,0(r2)
  4112ac:	10803fcc 	andi	r2,r2,255
  4112b0:	1080201c 	xori	r2,r2,128
  4112b4:	10bfe004 	addi	r2,r2,-128
  4112b8:	103fee1e 	bne	r2,zero,411274 <_gp+0xffff15a4>
	{
		Hw_Uart_Putch( Ch, *UartPrintData );
		UartPrintData++;
	}        
}
  4112bc:	e037883a 	mov	sp,fp
  4112c0:	dfc00117 	ldw	ra,4(sp)
  4112c4:	df000017 	ldw	fp,0(sp)
  4112c8:	dec00204 	addi	sp,sp,8
  4112cc:	f800283a 	ret

004112d0 <Hw_Uart_Printf>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_Printf( u8 Ch,  char *format, ... )
{
  4112d0:	deffc704 	addi	sp,sp,-228
  4112d4:	dfc03615 	stw	ra,216(sp)
  4112d8:	df003515 	stw	fp,212(sp)
  4112dc:	df003504 	addi	fp,sp,212
  4112e0:	2005883a 	mov	r2,r4
  4112e4:	e1800215 	stw	r6,8(fp)
  4112e8:	e1c00315 	stw	r7,12(fp)
  4112ec:	e17fff15 	stw	r5,-4(fp)
  4112f0:	e0bffe05 	stb	r2,-8(fp)
	char Str[200];
	
	va_list ap;
	
	va_start( ap, format );
  4112f4:	e0800204 	addi	r2,fp,8
  4112f8:	e0bffd15 	stw	r2,-12(fp)

	//vsprintf( Str, format, ap );	

	Lb_vsprintf(Str, format, ap );
  4112fc:	e0bffd17 	ldw	r2,-12(fp)
  411300:	e13fcb04 	addi	r4,fp,-212
  411304:	e17fff17 	ldw	r5,-4(fp)
  411308:	100d883a 	mov	r6,r2
  41130c:	04136f40 	call	4136f4 <vsprintf>
	va_end(ap);
	
	
	
	
	Hw_Uart_PrintEx( Ch, Str );
  411310:	e0bffe03 	ldbu	r2,-8(fp)
  411314:	1009883a 	mov	r4,r2
  411318:	e17fcb04 	addi	r5,fp,-212
  41131c:	04112540 	call	411254 <Hw_Uart_PrintEx>
}
  411320:	e037883a 	mov	sp,fp
  411324:	dfc00117 	ldw	ra,4(sp)
  411328:	df000017 	ldw	fp,0(sp)
  41132c:	dec00404 	addi	sp,sp,16
  411330:	f800283a 	ret

00411334 <Hw_Uart_GetchNoWait>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
u8 Hw_Uart_GetchNoWait( u8 Ch, u8 *cReturn )
{
  411334:	defffc04 	addi	sp,sp,-16
  411338:	dfc00315 	stw	ra,12(sp)
  41133c:	df000215 	stw	fp,8(sp)
  411340:	df000204 	addi	fp,sp,8
  411344:	2005883a 	mov	r2,r4
  411348:	e17fff15 	stw	r5,-4(fp)
  41134c:	e0bffe05 	stb	r2,-8(fp)
	// 버퍼에 데이터 없으면 실패로 종료.
	if( HW_UART_Q_VAILD(Ch) == 0 )
  411350:	e0bffe03 	ldbu	r2,-8(fp)
  411354:	1009883a 	mov	r4,r2
  411358:	04114a40 	call	4114a4 <HW_UART_Q_VAILD>
  41135c:	1000021e 	bne	r2,zero,411368 <Hw_Uart_GetchNoWait+0x34>
	{
		return FALSE;
  411360:	0005883a 	mov	r2,zero
  411364:	00000506 	br	41137c <Hw_Uart_GetchNoWait+0x48>
	}
		   
	Hw_Uart_Q_Pop( Ch, cReturn );
  411368:	e0bffe03 	ldbu	r2,-8(fp)
  41136c:	1009883a 	mov	r4,r2
  411370:	e17fff17 	ldw	r5,-4(fp)
  411374:	04116700 	call	411670 <Hw_Uart_Q_Pop>
	
	return TRUE;
  411378:	00800044 	movi	r2,1
}
  41137c:	e037883a 	mov	sp,fp
  411380:	dfc00117 	ldw	ra,4(sp)
  411384:	df000017 	ldw	fp,0(sp)
  411388:	dec00204 	addi	sp,sp,8
  41138c:	f800283a 	ret

00411390 <Hw_Uart_Q_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Q_Init( void )
{
  411390:	defffe04 	addi	sp,sp,-8
  411394:	df000115 	stw	fp,4(sp)
  411398:	df000104 	addi	fp,sp,4
	u8 i;

	for( i=0; i<HW_UART_Q_CH_MAX; i++ )
  41139c:	e03fff05 	stb	zero,-4(fp)
  4113a0:	00001406 	br	4113f4 <Hw_Uart_Q_Init+0x64>
	{
		Hw_Uart_Q_Start[i] = Hw_Uart_Q_End[i] = 0;
  4113a4:	e13fff03 	ldbu	r4,-4(fp)
  4113a8:	e0bfff03 	ldbu	r2,-4(fp)
  4113ac:	00c010b4 	movhi	r3,66
  4113b0:	18e11184 	addi	r3,r3,-31674
  4113b4:	108b883a 	add	r5,r2,r2
  4113b8:	1947883a 	add	r3,r3,r5
  4113bc:	1800000d 	sth	zero,0(r3)
  4113c0:	00c010b4 	movhi	r3,66
  4113c4:	18e11184 	addi	r3,r3,-31674
  4113c8:	1085883a 	add	r2,r2,r2
  4113cc:	1885883a 	add	r2,r3,r2
  4113d0:	10c0000b 	ldhu	r3,0(r2)
  4113d4:	008010b4 	movhi	r2,66
  4113d8:	10a11504 	addi	r2,r2,-31660
  4113dc:	2109883a 	add	r4,r4,r4
  4113e0:	1105883a 	add	r2,r2,r4
  4113e4:	10c0000d 	sth	r3,0(r2)
---------------------------------------------------------------------------*/
void Hw_Uart_Q_Init( void )
{
	u8 i;

	for( i=0; i<HW_UART_Q_CH_MAX; i++ )
  4113e8:	e0bfff03 	ldbu	r2,-4(fp)
  4113ec:	10800044 	addi	r2,r2,1
  4113f0:	e0bfff05 	stb	r2,-4(fp)
  4113f4:	e0bfff03 	ldbu	r2,-4(fp)
  4113f8:	108001f0 	cmpltui	r2,r2,7
  4113fc:	103fe91e 	bne	r2,zero,4113a4 <_gp+0xffff16d4>
	{
		Hw_Uart_Q_Start[i] = Hw_Uart_Q_End[i] = 0;
	}
}
  411400:	e037883a 	mov	sp,fp
  411404:	df000017 	ldw	fp,0(sp)
  411408:	dec00104 	addi	sp,sp,4
  41140c:	f800283a 	ret

00411410 <HW_UART_Q_SIZE>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 HW_UART_Q_SIZE( u8 Ch )
{
  411410:	defffe04 	addi	sp,sp,-8
  411414:	df000115 	stw	fp,4(sp)
  411418:	df000104 	addi	fp,sp,4
  41141c:	2005883a 	mov	r2,r4
  411420:	e0bfff05 	stb	r2,-4(fp)
	return (Hw_Uart_Q_Start[Ch] - Hw_Uart_Q_End[Ch] + HW_UART_Q_BUFFER_MAX) % HW_UART_Q_BUFFER_MAX;
  411424:	e0ffff03 	ldbu	r3,-4(fp)
  411428:	008010b4 	movhi	r2,66
  41142c:	10a11504 	addi	r2,r2,-31660
  411430:	18c7883a 	add	r3,r3,r3
  411434:	10c5883a 	add	r2,r2,r3
  411438:	1080000b 	ldhu	r2,0(r2)
  41143c:	113fffcc 	andi	r4,r2,65535
  411440:	2120001c 	xori	r4,r4,32768
  411444:	21200004 	addi	r4,r4,-32768
  411448:	e0ffff03 	ldbu	r3,-4(fp)
  41144c:	008010b4 	movhi	r2,66
  411450:	10a11184 	addi	r2,r2,-31674
  411454:	18c7883a 	add	r3,r3,r3
  411458:	10c5883a 	add	r2,r2,r3
  41145c:	1080000b 	ldhu	r2,0(r2)
  411460:	10bfffcc 	andi	r2,r2,65535
  411464:	10a0001c 	xori	r2,r2,32768
  411468:	10a00004 	addi	r2,r2,-32768
  41146c:	2085c83a 	sub	r2,r4,r2
  411470:	10c00804 	addi	r3,r2,32
  411474:	00a00034 	movhi	r2,32768
  411478:	108007c4 	addi	r2,r2,31
  41147c:	1884703a 	and	r2,r3,r2
  411480:	1000040e 	bge	r2,zero,411494 <HW_UART_Q_SIZE+0x84>
  411484:	10bfffc4 	addi	r2,r2,-1
  411488:	00fff804 	movi	r3,-32
  41148c:	10c4b03a 	or	r2,r2,r3
  411490:	10800044 	addi	r2,r2,1
}
  411494:	e037883a 	mov	sp,fp
  411498:	df000017 	ldw	fp,0(sp)
  41149c:	dec00104 	addi	sp,sp,4
  4114a0:	f800283a 	ret

004114a4 <HW_UART_Q_VAILD>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 HW_UART_Q_VAILD( u8 Ch )
{
  4114a4:	defffd04 	addi	sp,sp,-12
  4114a8:	dfc00215 	stw	ra,8(sp)
  4114ac:	df000115 	stw	fp,4(sp)
  4114b0:	df000104 	addi	fp,sp,4
  4114b4:	2005883a 	mov	r2,r4
  4114b8:	e0bfff05 	stb	r2,-4(fp)
	return HW_UART_Q_SIZE(Ch);
  4114bc:	e0bfff03 	ldbu	r2,-4(fp)
  4114c0:	1009883a 	mov	r4,r2
  4114c4:	04114100 	call	411410 <HW_UART_Q_SIZE>
}
  4114c8:	e037883a 	mov	sp,fp
  4114cc:	dfc00117 	ldw	ra,4(sp)
  4114d0:	df000017 	ldw	fp,0(sp)
  4114d4:	dec00204 	addi	sp,sp,8
  4114d8:	f800283a 	ret

004114dc <Hw_Uart_Q_PushReady>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 Hw_Uart_Q_PushReady( u8 Ch )
{
  4114dc:	defffe04 	addi	sp,sp,-8
  4114e0:	df000115 	stw	fp,4(sp)
  4114e4:	df000104 	addi	fp,sp,4
  4114e8:	2005883a 	mov	r2,r4
  4114ec:	e0bfff05 	stb	r2,-4(fp)
	if( Hw_Uart_Q_Size[Ch] < HW_UART_Q_BUFFER_MAX )	return TRUE;
  4114f0:	e0ffff03 	ldbu	r3,-4(fp)
  4114f4:	008010b4 	movhi	r2,66
  4114f8:	10a10e04 	addi	r2,r2,-31688
  4114fc:	18c7883a 	add	r3,r3,r3
  411500:	10c5883a 	add	r2,r2,r3
  411504:	1080000b 	ldhu	r2,0(r2)
  411508:	10bfffcc 	andi	r2,r2,65535
  41150c:	10a0001c 	xori	r2,r2,32768
  411510:	10a00004 	addi	r2,r2,-32768
  411514:	10800808 	cmpgei	r2,r2,32
  411518:	1000021e 	bne	r2,zero,411524 <Hw_Uart_Q_PushReady+0x48>
  41151c:	00800044 	movi	r2,1
  411520:	00000106 	br	411528 <Hw_Uart_Q_PushReady+0x4c>
	else                                  			return FALSE;
  411524:	0005883a 	mov	r2,zero
}
  411528:	e037883a 	mov	sp,fp
  41152c:	df000017 	ldw	fp,0(sp)
  411530:	dec00104 	addi	sp,sp,4
  411534:	f800283a 	ret

00411538 <Hw_Uart_Q_Push>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u8 Hw_Uart_Q_Push( u8 Ch, u8  *PushData )
{
  411538:	defff904 	addi	sp,sp,-28
  41153c:	dfc00615 	stw	ra,24(sp)
  411540:	df000515 	stw	fp,20(sp)
  411544:	dc800415 	stw	r18,16(sp)
  411548:	dc400315 	stw	r17,12(sp)
  41154c:	dc000215 	stw	r16,8(sp)
  411550:	df000504 	addi	fp,sp,20
  411554:	2005883a 	mov	r2,r4
  411558:	e17ffc15 	stw	r5,-16(fp)
  41155c:	e0bffb05 	stb	r2,-20(fp)

	if (HW_UART_Q_SIZE(Ch) == (HW_UART_Q_BUFFER_MAX-1)) return FALSE;
  411560:	e0bffb03 	ldbu	r2,-20(fp)
  411564:	1009883a 	mov	r4,r2
  411568:	04114100 	call	411410 <HW_UART_Q_SIZE>
  41156c:	108007d8 	cmpnei	r2,r2,31
  411570:	1000021e 	bne	r2,zero,41157c <Hw_Uart_Q_Push+0x44>
  411574:	0005883a 	mov	r2,zero
  411578:	00003506 	br	411650 <Hw_Uart_Q_Push+0x118>

	Hw_Uart_Q_Buffer[Ch][Hw_Uart_Q_Start[Ch]++]  = *PushData;
  41157c:	e17ffb03 	ldbu	r5,-20(fp)
  411580:	e0bffb03 	ldbu	r2,-20(fp)
  411584:	00c010b4 	movhi	r3,66
  411588:	18e11504 	addi	r3,r3,-31660
  41158c:	1089883a 	add	r4,r2,r2
  411590:	1907883a 	add	r3,r3,r4
  411594:	1900000b 	ldhu	r4,0(r3)
  411598:	2007883a 	mov	r3,r4
  41159c:	18c00044 	addi	r3,r3,1
  4115a0:	180d883a 	mov	r6,r3
  4115a4:	00c010b4 	movhi	r3,66
  4115a8:	18e11504 	addi	r3,r3,-31660
  4115ac:	1085883a 	add	r2,r2,r2
  4115b0:	1885883a 	add	r2,r3,r2
  4115b4:	1180000d 	sth	r6,0(r2)
  4115b8:	24bfffcc 	andi	r18,r4,65535
  4115bc:	94a0001c 	xori	r18,r18,32768
  4115c0:	94a00004 	addi	r18,r18,-32768
  4115c4:	e0bffc17 	ldw	r2,-16(fp)
  4115c8:	14400003 	ldbu	r17,0(r2)
  4115cc:	040010b4 	movhi	r16,66
  4115d0:	8420d404 	addi	r16,r16,-31920
  4115d4:	2809883a 	mov	r4,r5
  4115d8:	01400844 	movi	r5,33
  4115dc:	0411f000 	call	411f00 <__mulsi3>
  4115e0:	1485883a 	add	r2,r2,r18
  4115e4:	8085883a 	add	r2,r16,r2
  4115e8:	14400005 	stb	r17,0(r2)
	Hw_Uart_Q_Start[Ch] 						%= HW_UART_Q_BUFFER_MAX;
  4115ec:	e0fffb03 	ldbu	r3,-20(fp)
  4115f0:	e13ffb03 	ldbu	r4,-20(fp)
  4115f4:	008010b4 	movhi	r2,66
  4115f8:	10a11504 	addi	r2,r2,-31660
  4115fc:	2109883a 	add	r4,r4,r4
  411600:	1105883a 	add	r2,r2,r4
  411604:	1080000b 	ldhu	r2,0(r2)
  411608:	113fffcc 	andi	r4,r2,65535
  41160c:	2120001c 	xori	r4,r4,32768
  411610:	21200004 	addi	r4,r4,-32768
  411614:	00a00034 	movhi	r2,32768
  411618:	108007c4 	addi	r2,r2,31
  41161c:	2084703a 	and	r2,r4,r2
  411620:	1000040e 	bge	r2,zero,411634 <Hw_Uart_Q_Push+0xfc>
  411624:	10bfffc4 	addi	r2,r2,-1
  411628:	013ff804 	movi	r4,-32
  41162c:	1104b03a 	or	r2,r2,r4
  411630:	10800044 	addi	r2,r2,1
  411634:	1009883a 	mov	r4,r2
  411638:	008010b4 	movhi	r2,66
  41163c:	10a11504 	addi	r2,r2,-31660
  411640:	18c7883a 	add	r3,r3,r3
  411644:	10c5883a 	add	r2,r2,r3
  411648:	1100000d 	sth	r4,0(r2)

	return TRUE;
  41164c:	00800044 	movi	r2,1
}
  411650:	e6fffd04 	addi	sp,fp,-12
  411654:	dfc00417 	ldw	ra,16(sp)
  411658:	df000317 	ldw	fp,12(sp)
  41165c:	dc800217 	ldw	r18,8(sp)
  411660:	dc400117 	ldw	r17,4(sp)
  411664:	dc000017 	ldw	r16,0(sp)
  411668:	dec00504 	addi	sp,sp,20
  41166c:	f800283a 	ret

00411670 <Hw_Uart_Q_Pop>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u8 Hw_Uart_Q_Pop( u8 Ch, u8 *pData )
{
  411670:	defffa04 	addi	sp,sp,-24
  411674:	dfc00515 	stw	ra,20(sp)
  411678:	df000415 	stw	fp,16(sp)
  41167c:	dc400315 	stw	r17,12(sp)
  411680:	dc000215 	stw	r16,8(sp)
  411684:	df000404 	addi	fp,sp,16
  411688:	2005883a 	mov	r2,r4
  41168c:	e17ffd15 	stw	r5,-12(fp)
  411690:	e0bffc05 	stb	r2,-16(fp)
	if (HW_UART_Q_SIZE(Ch) == 0) return FALSE;
  411694:	e0bffc03 	ldbu	r2,-16(fp)
  411698:	1009883a 	mov	r4,r2
  41169c:	04114100 	call	411410 <HW_UART_Q_SIZE>
  4116a0:	1000021e 	bne	r2,zero,4116ac <Hw_Uart_Q_Pop+0x3c>
  4116a4:	0005883a 	mov	r2,zero
  4116a8:	00003506 	br	411780 <Hw_Uart_Q_Pop+0x110>

	*pData = Hw_Uart_Q_Buffer[Ch][Hw_Uart_Q_End[Ch]++];
  4116ac:	e17ffc03 	ldbu	r5,-16(fp)
  4116b0:	e0bffc03 	ldbu	r2,-16(fp)
  4116b4:	00c010b4 	movhi	r3,66
  4116b8:	18e11184 	addi	r3,r3,-31674
  4116bc:	1089883a 	add	r4,r2,r2
  4116c0:	1907883a 	add	r3,r3,r4
  4116c4:	1900000b 	ldhu	r4,0(r3)
  4116c8:	2007883a 	mov	r3,r4
  4116cc:	18c00044 	addi	r3,r3,1
  4116d0:	180d883a 	mov	r6,r3
  4116d4:	00c010b4 	movhi	r3,66
  4116d8:	18e11184 	addi	r3,r3,-31674
  4116dc:	1085883a 	add	r2,r2,r2
  4116e0:	1885883a 	add	r2,r3,r2
  4116e4:	1180000d 	sth	r6,0(r2)
  4116e8:	247fffcc 	andi	r17,r4,65535
  4116ec:	8c60001c 	xori	r17,r17,32768
  4116f0:	8c600004 	addi	r17,r17,-32768
  4116f4:	040010b4 	movhi	r16,66
  4116f8:	8420d404 	addi	r16,r16,-31920
  4116fc:	2809883a 	mov	r4,r5
  411700:	01400844 	movi	r5,33
  411704:	0411f000 	call	411f00 <__mulsi3>
  411708:	1445883a 	add	r2,r2,r17
  41170c:	8085883a 	add	r2,r16,r2
  411710:	10c00003 	ldbu	r3,0(r2)
  411714:	e0bffd17 	ldw	r2,-12(fp)
  411718:	10c00005 	stb	r3,0(r2)

	Hw_Uart_Q_End[Ch] %= HW_UART_Q_BUFFER_MAX;
  41171c:	e0fffc03 	ldbu	r3,-16(fp)
  411720:	e13ffc03 	ldbu	r4,-16(fp)
  411724:	008010b4 	movhi	r2,66
  411728:	10a11184 	addi	r2,r2,-31674
  41172c:	2109883a 	add	r4,r4,r4
  411730:	1105883a 	add	r2,r2,r4
  411734:	1080000b 	ldhu	r2,0(r2)
  411738:	113fffcc 	andi	r4,r2,65535
  41173c:	2120001c 	xori	r4,r4,32768
  411740:	21200004 	addi	r4,r4,-32768
  411744:	00a00034 	movhi	r2,32768
  411748:	108007c4 	addi	r2,r2,31
  41174c:	2084703a 	and	r2,r4,r2
  411750:	1000040e 	bge	r2,zero,411764 <Hw_Uart_Q_Pop+0xf4>
  411754:	10bfffc4 	addi	r2,r2,-1
  411758:	013ff804 	movi	r4,-32
  41175c:	1104b03a 	or	r2,r2,r4
  411760:	10800044 	addi	r2,r2,1
  411764:	1009883a 	mov	r4,r2
  411768:	008010b4 	movhi	r2,66
  41176c:	10a11184 	addi	r2,r2,-31674
  411770:	18c7883a 	add	r3,r3,r3
  411774:	10c5883a 	add	r2,r2,r3
  411778:	1100000d 	sth	r4,0(r2)

    return TRUE;
  41177c:	00800044 	movi	r2,1
}
  411780:	e6fffe04 	addi	sp,fp,-8
  411784:	dfc00317 	ldw	ra,12(sp)
  411788:	df000217 	ldw	fp,8(sp)
  41178c:	dc400117 	ldw	r17,4(sp)
  411790:	dc000017 	ldw	r16,0(sp)
  411794:	dec00404 	addi	sp,sp,16
  411798:	f800283a 	ret

0041179c <Hw_Led_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_Init( void )
{
  41179c:	defffe04 	addi	sp,sp,-8
  4117a0:	dfc00115 	stw	ra,4(sp)
  4117a4:	df000015 	stw	fp,0(sp)
  4117a8:	d839883a 	mov	fp,sp

	//-- 방향 출력으로 설정
	//


	Hw_Led_Off(0);
  4117ac:	0009883a 	mov	r4,zero
  4117b0:	04118300 	call	411830 <Hw_Led_Off>
	Hw_Led_Off(1);	
  4117b4:	01000044 	movi	r4,1
  4117b8:	04118300 	call	411830 <Hw_Led_Off>
}
  4117bc:	e037883a 	mov	sp,fp
  4117c0:	dfc00117 	ldw	ra,4(sp)
  4117c4:	df000017 	ldw	fp,0(sp)
  4117c8:	dec00204 	addi	sp,sp,8
  4117cc:	f800283a 	ret

004117d0 <Hw_Led_On>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_On( u8 Ch )
{	
  4117d0:	defffd04 	addi	sp,sp,-12
  4117d4:	df000215 	stw	fp,8(sp)
  4117d8:	df000204 	addi	fp,sp,8
  4117dc:	2005883a 	mov	r2,r4
  4117e0:	e0bfff05 	stb	r2,-4(fp)
	u32 Data;


	Data = IORD_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE);
  4117e4:	008010b4 	movhi	r2,66
  4117e8:	10864804 	addi	r2,r2,6432
  4117ec:	10800037 	ldwio	r2,0(r2)
  4117f0:	e0bffe15 	stw	r2,-8(fp)
	SET_BIT(Data, Ch);
  4117f4:	e0bfff03 	ldbu	r2,-4(fp)
  4117f8:	00c00044 	movi	r3,1
  4117fc:	1884983a 	sll	r2,r3,r2
  411800:	1007883a 	mov	r3,r2
  411804:	e0bffe17 	ldw	r2,-8(fp)
  411808:	10c4b03a 	or	r2,r2,r3
  41180c:	e0bffe15 	stw	r2,-8(fp)
	IOWR_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE, Data);
  411810:	e0fffe17 	ldw	r3,-8(fp)
  411814:	008010b4 	movhi	r2,66
  411818:	10864804 	addi	r2,r2,6432
  41181c:	10c00035 	stwio	r3,0(r2)
}
  411820:	e037883a 	mov	sp,fp
  411824:	df000017 	ldw	fp,0(sp)
  411828:	dec00104 	addi	sp,sp,4
  41182c:	f800283a 	ret

00411830 <Hw_Led_Off>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_Off( u8 Ch )
{
  411830:	defffd04 	addi	sp,sp,-12
  411834:	df000215 	stw	fp,8(sp)
  411838:	df000204 	addi	fp,sp,8
  41183c:	2005883a 	mov	r2,r4
  411840:	e0bfff05 	stb	r2,-4(fp)
	u32 Data;

	Data = IORD_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE);
  411844:	008010b4 	movhi	r2,66
  411848:	10864804 	addi	r2,r2,6432
  41184c:	10800037 	ldwio	r2,0(r2)
  411850:	e0bffe15 	stw	r2,-8(fp)
	CLR_BIT(Data, Ch);
  411854:	e0bfff03 	ldbu	r2,-4(fp)
  411858:	00c00044 	movi	r3,1
  41185c:	1884983a 	sll	r2,r3,r2
  411860:	0084303a 	nor	r2,zero,r2
  411864:	1007883a 	mov	r3,r2
  411868:	e0bffe17 	ldw	r2,-8(fp)
  41186c:	10c4703a 	and	r2,r2,r3
  411870:	e0bffe15 	stw	r2,-8(fp)
	IOWR_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE, Data);
  411874:	e0fffe17 	ldw	r3,-8(fp)
  411878:	008010b4 	movhi	r2,66
  41187c:	10864804 	addi	r2,r2,6432
  411880:	10c00035 	stwio	r3,0(r2)
}
  411884:	e037883a 	mov	sp,fp
  411888:	df000017 	ldw	fp,0(sp)
  41188c:	dec00104 	addi	sp,sp,4
  411890:	f800283a 	ret

00411894 <Hw_Led_Toggle>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_Toggle( u8 Ch )
{
  411894:	defffd04 	addi	sp,sp,-12
  411898:	df000215 	stw	fp,8(sp)
  41189c:	df000204 	addi	fp,sp,8
  4118a0:	2005883a 	mov	r2,r4
  4118a4:	e0bfff05 	stb	r2,-4(fp)
	u32 Data;


	Data = IORD_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE);
  4118a8:	008010b4 	movhi	r2,66
  4118ac:	10864804 	addi	r2,r2,6432
  4118b0:	10800037 	ldwio	r2,0(r2)
  4118b4:	e0bffe15 	stw	r2,-8(fp)
	TGL_BIT(Data, Ch);
  4118b8:	e0bfff03 	ldbu	r2,-4(fp)
  4118bc:	00c00044 	movi	r3,1
  4118c0:	1884983a 	sll	r2,r3,r2
  4118c4:	1007883a 	mov	r3,r2
  4118c8:	e0bffe17 	ldw	r2,-8(fp)
  4118cc:	10c4f03a 	xor	r2,r2,r3
  4118d0:	e0bffe15 	stw	r2,-8(fp)
	IOWR_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE, Data);
  4118d4:	e0fffe17 	ldw	r3,-8(fp)
  4118d8:	008010b4 	movhi	r2,66
  4118dc:	10864804 	addi	r2,r2,6432
  4118e0:	10c00035 	stwio	r3,0(r2)
}
  4118e4:	e037883a 	mov	sp,fp
  4118e8:	df000017 	ldw	fp,0(sp)
  4118ec:	dec00104 	addi	sp,sp,4
  4118f0:	f800283a 	ret

004118f4 <Hw_Led_Wait>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_Wait( u32 delay )
{
  4118f4:	defffd04 	addi	sp,sp,-12
  4118f8:	df000215 	stw	fp,8(sp)
  4118fc:	df000204 	addi	fp,sp,8
  411900:	e13fff15 	stw	r4,-4(fp)
    volatile u32 i;
    for ( i = 0 ; i < delay ; i++ ){ };
  411904:	e03ffe15 	stw	zero,-8(fp)
  411908:	00000306 	br	411918 <Hw_Led_Wait+0x24>
  41190c:	e0bffe17 	ldw	r2,-8(fp)
  411910:	10800044 	addi	r2,r2,1
  411914:	e0bffe15 	stw	r2,-8(fp)
  411918:	e0fffe17 	ldw	r3,-8(fp)
  41191c:	e0bfff17 	ldw	r2,-4(fp)
  411920:	18bffa36 	bltu	r3,r2,41190c <_gp+0xffff1c3c>
}
  411924:	e037883a 	mov	sp,fp
  411928:	df000017 	ldw	fp,0(sp)
  41192c:	dec00104 	addi	sp,sp,4
  411930:	f800283a 	ret

00411934 <Hw_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Init( void )
{
  411934:	defffe04 	addi	sp,sp,-8
  411938:	dfc00115 	stw	ra,4(sp)
  41193c:	df000015 	stw	fp,0(sp)
  411940:	d839883a 	mov	fp,sp
	Hw_ISR_Init();
  411944:	04108140 	call	410814 <Hw_ISR_Init>
	Hw_Led_Init();
  411948:	041179c0 	call	41179c <Hw_Led_Init>
	Hw_Uart_Init();
  41194c:	0410e980 	call	410e98 <Hw_Uart_Init>

	Enable_ISR();
}
  411950:	e037883a 	mov	sp,fp
  411954:	dfc00117 	ldw	ra,4(sp)
  411958:	df000017 	ldw	fp,0(sp)
  41195c:	dec00204 	addi	sp,sp,8
  411960:	f800283a 	ret

00411964 <Hw_Wait>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Wait( u32 delay )
{
  411964:	defffd04 	addi	sp,sp,-12
  411968:	df000215 	stw	fp,8(sp)
  41196c:	df000204 	addi	fp,sp,8
  411970:	e13fff15 	stw	r4,-4(fp)
    volatile u32 i;
    for ( i = 0 ; i < delay ; i++ ){ };
  411974:	e03ffe15 	stw	zero,-8(fp)
  411978:	00000306 	br	411988 <Hw_Wait+0x24>
  41197c:	e0bffe17 	ldw	r2,-8(fp)
  411980:	10800044 	addi	r2,r2,1
  411984:	e0bffe15 	stw	r2,-8(fp)
  411988:	e0fffe17 	ldw	r3,-8(fp)
  41198c:	e0bfff17 	ldw	r2,-4(fp)
  411990:	18bffa36 	bltu	r3,r2,41197c <_gp+0xffff1cac>
}
  411994:	e037883a 	mov	sp,fp
  411998:	df000017 	ldw	fp,0(sp)
  41199c:	dec00104 	addi	sp,sp,4
  4119a0:	f800283a 	ret

004119a4 <Hw_Wait_Usec>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Wait_Usec( u32 usec )
{
  4119a4:	defffd04 	addi	sp,sp,-12
  4119a8:	dfc00215 	stw	ra,8(sp)
  4119ac:	df000115 	stw	fp,4(sp)
  4119b0:	df000104 	addi	fp,sp,4
  4119b4:	e13fff15 	stw	r4,-4(fp)
    Hw_Wait( usec * 83 );
  4119b8:	e13fff17 	ldw	r4,-4(fp)
  4119bc:	014014c4 	movi	r5,83
  4119c0:	0411f000 	call	411f00 <__mulsi3>
  4119c4:	1009883a 	mov	r4,r2
  4119c8:	04119640 	call	411964 <Hw_Wait>
}
  4119cc:	e037883a 	mov	sp,fp
  4119d0:	dfc00117 	ldw	ra,4(sp)
  4119d4:	df000017 	ldw	fp,0(sp)
  4119d8:	dec00204 	addi	sp,sp,8
  4119dc:	f800283a 	ret

004119e0 <millis>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 millis( void )
{
  4119e0:	defffe04 	addi	sp,sp,-8
  4119e4:	dfc00115 	stw	ra,4(sp)
  4119e8:	df000015 	stw	fp,0(sp)
  4119ec:	d839883a 	mov	fp,sp
	return alt_timestamp()/1000;
  4119f0:	041544c0 	call	41544c <alt_timestamp>
  4119f4:	1009883a 	mov	r4,r2
  4119f8:	0140fa04 	movi	r5,1000
  4119fc:	0411ef00 	call	411ef0 <__udivsi3>
}
  411a00:	e037883a 	mov	sp,fp
  411a04:	dfc00117 	ldw	ra,4(sp)
  411a08:	df000017 	ldw	fp,0(sp)
  411a0c:	dec00204 	addi	sp,sp,8
  411a10:	f800283a 	ret

00411a14 <micros>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 micros( void )
{
  411a14:	defffe04 	addi	sp,sp,-8
  411a18:	dfc00115 	stw	ra,4(sp)
  411a1c:	df000015 	stw	fp,0(sp)
  411a20:	d839883a 	mov	fp,sp
	return alt_timestamp();
  411a24:	041544c0 	call	41544c <alt_timestamp>
}
  411a28:	e037883a 	mov	sp,fp
  411a2c:	dfc00117 	ldw	ra,4(sp)
  411a30:	df000017 	ldw	fp,0(sp)
  411a34:	dec00204 	addi	sp,sp,8
  411a38:	f800283a 	ret

00411a3c <delay>:




void delay(volatile unsigned int timeCount)
{
  411a3c:	defffe04 	addi	sp,sp,-8
  411a40:	df000115 	stw	fp,4(sp)
  411a44:	df000104 	addi	fp,sp,4
  411a48:	e13fff15 	stw	r4,-4(fp)
    while(timeCount --);
  411a4c:	0001883a 	nop
  411a50:	e0bfff17 	ldw	r2,-4(fp)
  411a54:	10ffffc4 	addi	r3,r2,-1
  411a58:	e0ffff15 	stw	r3,-4(fp)
  411a5c:	103ffc1e 	bne	r2,zero,411a50 <_gp+0xffff1d80>
}
  411a60:	e037883a 	mov	sp,fp
  411a64:	df000017 	ldw	fp,0(sp)
  411a68:	dec00104 	addi	sp,sp,4
  411a6c:	f800283a 	ret

00411a70 <delay_second>:

void delay_second(void)
{
  411a70:	defffe04 	addi	sp,sp,-8
  411a74:	dfc00115 	stw	ra,4(sp)
  411a78:	df000015 	stw	fp,0(sp)
  411a7c:	d839883a 	mov	fp,sp
    delay(806596);
  411a80:	01000334 	movhi	r4,12
  411a84:	2113b104 	addi	r4,r4,20164
  411a88:	0411a3c0 	call	411a3c <delay>
}
  411a8c:	e037883a 	mov	sp,fp
  411a90:	dfc00117 	ldw	ra,4(sp)
  411a94:	df000017 	ldw	fp,0(sp)
  411a98:	dec00204 	addi	sp,sp,8
  411a9c:	f800283a 	ret

00411aa0 <Uart1_ISR>:




void Uart1_ISR(char Ch)
{
  411aa0:	defffd04 	addi	sp,sp,-12
  411aa4:	dfc00215 	stw	ra,8(sp)
  411aa8:	df000115 	stw	fp,4(sp)
  411aac:	df000104 	addi	fp,sp,4
  411ab0:	2005883a 	mov	r2,r4
  411ab4:	e0bfff05 	stb	r2,-4(fp)
	Lb_printf("Received : %c\n", Ch);
  411ab8:	e0bfff07 	ldb	r2,-4(fp)
  411abc:	01001074 	movhi	r4,65
  411ac0:	211db904 	addi	r4,r4,30436
  411ac4:	100b883a 	mov	r5,r2
  411ac8:	0412fa00 	call	412fa0 <printf>
	Hw_Led_Toggle(7);
  411acc:	010001c4 	movi	r4,7
  411ad0:	04118940 	call	411894 <Hw_Led_Toggle>
}
  411ad4:	e037883a 	mov	sp,fp
  411ad8:	dfc00117 	ldw	ra,4(sp)
  411adc:	df000017 	ldw	fp,0(sp)
  411ae0:	dec00204 	addi	sp,sp,8
  411ae4:	f800283a 	ret

00411ae8 <main>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
int main(void)
{
  411ae8:	deffeb04 	addi	sp,sp,-84
  411aec:	dfc01415 	stw	ra,80(sp)
  411af0:	df001315 	stw	fp,76(sp)
  411af4:	dcc01215 	stw	r19,72(sp)
  411af8:	dc801115 	stw	r18,68(sp)
  411afc:	dc401015 	stw	r17,64(sp)
  411b00:	dc000f15 	stw	r16,60(sp)
  411b04:	df001304 	addi	fp,sp,76
	s16 M_Speed_L;
	s16 M_Speed_R;
	f32 M_Handle;


	Main_Init();
  411b08:	0411da80 	call	411da8 <Main_Init>


	Lb_printf( "Start\n" );
  411b0c:	01001074 	movhi	r4,65
  411b10:	211dbd04 	addi	r4,r4,30452
  411b14:	041306c0 	call	41306c <puts>

	i = 0;
  411b18:	e03ff015 	stw	zero,-64(fp)

	while (1)
	{
		if( (millis()-tTimer[0]) >= 500 )
  411b1c:	04119e00 	call	4119e0 <millis>
  411b20:	1007883a 	mov	r3,r2
  411b24:	e0bff417 	ldw	r2,-48(fp)
  411b28:	1885c83a 	sub	r2,r3,r2
  411b2c:	10807d30 	cmpltui	r2,r2,500
  411b30:	1000041e 	bne	r2,zero,411b44 <main+0x5c>
		{
			tTimer[0] = millis();
  411b34:	04119e00 	call	4119e0 <millis>
  411b38:	e0bff415 	stw	r2,-48(fp)
			Hw_Led_Toggle(0);
  411b3c:	0009883a 	mov	r4,zero
  411b40:	04118940 	call	411894 <Hw_Led_Toggle>
		}

		if( (millis()-tTimer[1]) >= 500 )
  411b44:	04119e00 	call	4119e0 <millis>
  411b48:	1007883a 	mov	r3,r2
  411b4c:	e0bff517 	ldw	r2,-44(fp)
  411b50:	1885c83a 	sub	r2,r3,r2
  411b54:	10807d30 	cmpltui	r2,r2,500
  411b58:	1000021e 	bne	r2,zero,411b64 <main+0x7c>
		{
			tTimer[1] = millis();
  411b5c:	04119e00 	call	4119e0 <millis>
  411b60:	e0bff515 	stw	r2,-44(fp)
			*/

		}


		if( MSP_GetReceived() == TRUE )
  411b64:	041032c0 	call	41032c <MSP_GetReceived>
  411b68:	10803fcc 	andi	r2,r2,255
  411b6c:	10800058 	cmpnei	r2,r2,1
  411b70:	1000741e 	bne	r2,zero,411d44 <main+0x25c>
		{
			tTimer[2] = millis();
  411b74:	04119e00 	call	4119e0 <millis>
  411b78:	e0bff615 	stw	r2,-40(fp)

			Lb_printf( "MSP Received : %d, R:%d, P:%d, Y:%d, T:%d\n",
					MSP_Get_CmdPtr()->Cmd,
  411b7c:	04105c80 	call	4105c8 <MSP_Get_CmdPtr>
  411b80:	10800003 	ldbu	r2,0(r2)

		if( MSP_GetReceived() == TRUE )
		{
			tTimer[2] = millis();

			Lb_printf( "MSP Received : %d, R:%d, P:%d, Y:%d, T:%d\n",
  411b84:	14c03fcc 	andi	r19,r2,255
					MSP_Get_CmdPtr()->Cmd,
					MSP_Get_CmdRcPtr()->Roll,
  411b88:	04106100 	call	410610 <MSP_Get_CmdRcPtr>
  411b8c:	1080000b 	ldhu	r2,0(r2)

		if( MSP_GetReceived() == TRUE )
		{
			tTimer[2] = millis();

			Lb_printf( "MSP Received : %d, R:%d, P:%d, Y:%d, T:%d\n",
  411b90:	14bfffcc 	andi	r18,r2,65535
  411b94:	94a0001c 	xori	r18,r18,32768
  411b98:	94a00004 	addi	r18,r18,-32768
					MSP_Get_CmdPtr()->Cmd,
					MSP_Get_CmdRcPtr()->Roll,
					MSP_Get_CmdRcPtr()->Pitch,
  411b9c:	04106100 	call	410610 <MSP_Get_CmdRcPtr>
  411ba0:	1080008b 	ldhu	r2,2(r2)

		if( MSP_GetReceived() == TRUE )
		{
			tTimer[2] = millis();

			Lb_printf( "MSP Received : %d, R:%d, P:%d, Y:%d, T:%d\n",
  411ba4:	147fffcc 	andi	r17,r2,65535
  411ba8:	8c60001c 	xori	r17,r17,32768
  411bac:	8c600004 	addi	r17,r17,-32768
					MSP_Get_CmdPtr()->Cmd,
					MSP_Get_CmdRcPtr()->Roll,
					MSP_Get_CmdRcPtr()->Pitch,
					MSP_Get_CmdRcPtr()->Yaw,
  411bb0:	04106100 	call	410610 <MSP_Get_CmdRcPtr>
  411bb4:	1080010b 	ldhu	r2,4(r2)

		if( MSP_GetReceived() == TRUE )
		{
			tTimer[2] = millis();

			Lb_printf( "MSP Received : %d, R:%d, P:%d, Y:%d, T:%d\n",
  411bb8:	143fffcc 	andi	r16,r2,65535
  411bbc:	8420001c 	xori	r16,r16,32768
  411bc0:	84200004 	addi	r16,r16,-32768
					MSP_Get_CmdPtr()->Cmd,
					MSP_Get_CmdRcPtr()->Roll,
					MSP_Get_CmdRcPtr()->Pitch,
					MSP_Get_CmdRcPtr()->Yaw,
					MSP_Get_CmdRcPtr()->Throthle);
  411bc4:	04106100 	call	410610 <MSP_Get_CmdRcPtr>
  411bc8:	1080018b 	ldhu	r2,6(r2)

		if( MSP_GetReceived() == TRUE )
		{
			tTimer[2] = millis();

			Lb_printf( "MSP Received : %d, R:%d, P:%d, Y:%d, T:%d\n",
  411bcc:	10bfffcc 	andi	r2,r2,65535
  411bd0:	10a0001c 	xori	r2,r2,32768
  411bd4:	10a00004 	addi	r2,r2,-32768
  411bd8:	dc000015 	stw	r16,0(sp)
  411bdc:	d8800115 	stw	r2,4(sp)
  411be0:	01001074 	movhi	r4,65
  411be4:	211dbf04 	addi	r4,r4,30460
  411be8:	980b883a 	mov	r5,r19
  411bec:	900d883a 	mov	r6,r18
  411bf0:	880f883a 	mov	r7,r17
  411bf4:	0412fa00 	call	412fa0 <printf>
					MSP_Get_CmdRcPtr()->Roll,
					MSP_Get_CmdRcPtr()->Pitch,
					MSP_Get_CmdRcPtr()->Yaw,
					MSP_Get_CmdRcPtr()->Throthle);

			M_Speed  = MSP_Get_CmdRcPtr()->Throthle*255/1000;
  411bf8:	04106100 	call	410610 <MSP_Get_CmdRcPtr>
  411bfc:	1080018b 	ldhu	r2,6(r2)
  411c00:	10bfffcc 	andi	r2,r2,65535
  411c04:	10a0001c 	xori	r2,r2,32768
  411c08:	10a00004 	addi	r2,r2,-32768
  411c0c:	1009883a 	mov	r4,r2
  411c10:	01403fc4 	movi	r5,255
  411c14:	0411f000 	call	411f00 <__mulsi3>
  411c18:	1009883a 	mov	r4,r2
  411c1c:	0140fa04 	movi	r5,1000
  411c20:	0411e400 	call	411e40 <__divsi3>
  411c24:	e0bff10d 	sth	r2,-60(fp)
			M_Handle = MSP_Get_CmdRcPtr()->Roll;
  411c28:	04106100 	call	410610 <MSP_Get_CmdRcPtr>
  411c2c:	1080000b 	ldhu	r2,0(r2)
  411c30:	10bfffcc 	andi	r2,r2,65535
  411c34:	10a0001c 	xori	r2,r2,32768
  411c38:	10a00004 	addi	r2,r2,-32768
  411c3c:	1009883a 	mov	r4,r2
  411c40:	0412dcc0 	call	412dcc <__floatsisf>
  411c44:	1007883a 	mov	r3,r2
  411c48:	e0fff215 	stw	r3,-56(fp)
			M_Handle = M_Handle/3;
  411c4c:	e13ff217 	ldw	r4,-56(fp)
  411c50:	01501034 	movhi	r5,16448
  411c54:	04124080 	call	412408 <__divsf3>
  411c58:	1007883a 	mov	r3,r2
  411c5c:	e0fff215 	stw	r3,-56(fp)

			M_Speed_L = M_Speed - M_Handle;
  411c60:	e0bff10f 	ldh	r2,-60(fp)
  411c64:	1009883a 	mov	r4,r2
  411c68:	0412dcc0 	call	412dcc <__floatsisf>
  411c6c:	1007883a 	mov	r3,r2
  411c70:	1809883a 	mov	r4,r3
  411c74:	e17ff217 	ldw	r5,-56(fp)
  411c78:	04128580 	call	412858 <__subsf3>
  411c7c:	1007883a 	mov	r3,r2
  411c80:	1805883a 	mov	r2,r3
  411c84:	1009883a 	mov	r4,r2
  411c88:	0412d540 	call	412d54 <__fixsfsi>
  411c8c:	e0bfef0d 	sth	r2,-68(fp)
			M_Speed_R = M_Speed + M_Handle;
  411c90:	e0bff10f 	ldh	r2,-60(fp)
  411c94:	1009883a 	mov	r4,r2
  411c98:	0412dcc0 	call	412dcc <__floatsisf>
  411c9c:	1007883a 	mov	r3,r2
  411ca0:	1809883a 	mov	r4,r3
  411ca4:	e17ff217 	ldw	r5,-56(fp)
  411ca8:	0411f280 	call	411f28 <__addsf3>
  411cac:	1007883a 	mov	r3,r2
  411cb0:	1805883a 	mov	r2,r3
  411cb4:	1009883a 	mov	r4,r2
  411cb8:	0412d540 	call	412d54 <__fixsfsi>
  411cbc:	e0bfef8d 	sth	r2,-66(fp)

			if( M_Speed_L < 0  ) M_Speed_L = 0;
  411cc0:	e0bfef0f 	ldh	r2,-68(fp)
  411cc4:	1000010e 	bge	r2,zero,411ccc <main+0x1e4>
  411cc8:	e03fef0d 	sth	zero,-68(fp)
			if( M_Speed_L > 255) M_Speed_L = 255;
  411ccc:	e0bfef0f 	ldh	r2,-68(fp)
  411cd0:	10804010 	cmplti	r2,r2,256
  411cd4:	1000021e 	bne	r2,zero,411ce0 <main+0x1f8>
  411cd8:	00803fc4 	movi	r2,255
  411cdc:	e0bfef0d 	sth	r2,-68(fp)
			if( M_Speed_R < 0  ) M_Speed_R = 0;
  411ce0:	e0bfef8f 	ldh	r2,-66(fp)
  411ce4:	1000010e 	bge	r2,zero,411cec <main+0x204>
  411ce8:	e03fef8d 	sth	zero,-66(fp)
			if( M_Speed_R > 255) M_Speed_R = 255;
  411cec:	e0bfef8f 	ldh	r2,-66(fp)
  411cf0:	10804010 	cmplti	r2,r2,256
  411cf4:	1000021e 	bne	r2,zero,411d00 <main+0x218>
  411cf8:	00803fc4 	movi	r2,255
  411cfc:	e0bfef8d 	sth	r2,-66(fp)


			IOWR(IP_PWM_0_BASE, 0, 0);
  411d00:	0007883a 	mov	r3,zero
  411d04:	008010b4 	movhi	r2,66
  411d08:	10850004 	addi	r2,r2,5120
  411d0c:	10c00035 	stwio	r3,0(r2)
			IOWR(IP_PWM_0_BASE, 1, M_Speed_L);
  411d10:	e0ffef0f 	ldh	r3,-68(fp)
  411d14:	008010b4 	movhi	r2,66
  411d18:	10850104 	addi	r2,r2,5124
  411d1c:	10c00035 	stwio	r3,0(r2)
			IOWR(IP_PWM_0_BASE, 2, 0);
  411d20:	0007883a 	mov	r3,zero
  411d24:	008010b4 	movhi	r2,66
  411d28:	10850204 	addi	r2,r2,5128
  411d2c:	10c00035 	stwio	r3,0(r2)
			IOWR(IP_PWM_0_BASE, 3, M_Speed_R);
  411d30:	e0ffef8f 	ldh	r3,-66(fp)
  411d34:	008010b4 	movhi	r2,66
  411d38:	10850304 	addi	r2,r2,5132
  411d3c:	10c00035 	stwio	r3,0(r2)
  411d40:	00001806 	br	411da4 <main+0x2bc>

		}
		else
		{
			if( (millis()-tTimer[2]) >= 1000 )
  411d44:	04119e00 	call	4119e0 <millis>
  411d48:	1007883a 	mov	r3,r2
  411d4c:	e0bff617 	ldw	r2,-40(fp)
  411d50:	1885c83a 	sub	r2,r3,r2
  411d54:	1080fa30 	cmpltui	r2,r2,1000
  411d58:	1000121e 	bne	r2,zero,411da4 <main+0x2bc>
			{
				IOWR(IP_PWM_0_BASE, 0, 0);
  411d5c:	0007883a 	mov	r3,zero
  411d60:	008010b4 	movhi	r2,66
  411d64:	10850004 	addi	r2,r2,5120
  411d68:	10c00035 	stwio	r3,0(r2)
				IOWR(IP_PWM_0_BASE, 1, 0);
  411d6c:	0007883a 	mov	r3,zero
  411d70:	008010b4 	movhi	r2,66
  411d74:	10850104 	addi	r2,r2,5124
  411d78:	10c00035 	stwio	r3,0(r2)
				IOWR(IP_PWM_0_BASE, 2, 0);
  411d7c:	0007883a 	mov	r3,zero
  411d80:	008010b4 	movhi	r2,66
  411d84:	10850204 	addi	r2,r2,5128
  411d88:	10c00035 	stwio	r3,0(r2)
				IOWR(IP_PWM_0_BASE, 3, 0);
  411d8c:	0007883a 	mov	r3,zero
  411d90:	008010b4 	movhi	r2,66
  411d94:	10850304 	addi	r2,r2,5132
  411d98:	10c00035 	stwio	r3,0(r2)
				tTimer[2] = millis();
  411d9c:	04119e00 	call	4119e0 <millis>
  411da0:	e0bff615 	stw	r2,-40(fp)
			}
		}
	}
  411da4:	003f5d06 	br	411b1c <_gp+0xffff1e4c>

00411da8 <Main_Init>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Main_Init( void )
{
  411da8:	defffe04 	addi	sp,sp,-8
  411dac:	dfc00115 	stw	ra,4(sp)
  411db0:	df000015 	stw	fp,0(sp)
  411db4:	d839883a 	mov	fp,sp
	Hw_Init();
  411db8:	04119340 	call	411934 <Hw_Init>
	Ap_Init();
  411dbc:	04102680 	call	410268 <Ap_Init>
}
  411dc0:	e037883a 	mov	sp,fp
  411dc4:	dfc00117 	ldw	ra,4(sp)
  411dc8:	df000017 	ldw	fp,0(sp)
  411dcc:	dec00204 	addi	sp,sp,8
  411dd0:	f800283a 	ret

00411dd4 <udivmodsi4>:
  411dd4:	2900182e 	bgeu	r5,r4,411e38 <udivmodsi4+0x64>
  411dd8:	28001716 	blt	r5,zero,411e38 <udivmodsi4+0x64>
  411ddc:	00800804 	movi	r2,32
  411de0:	00c00044 	movi	r3,1
  411de4:	00000206 	br	411df0 <udivmodsi4+0x1c>
  411de8:	10001126 	beq	r2,zero,411e30 <udivmodsi4+0x5c>
  411dec:	28000516 	blt	r5,zero,411e04 <udivmodsi4+0x30>
  411df0:	294b883a 	add	r5,r5,r5
  411df4:	10bfffc4 	addi	r2,r2,-1
  411df8:	18c7883a 	add	r3,r3,r3
  411dfc:	293ffa36 	bltu	r5,r4,411de8 <_gp+0xffff2118>
  411e00:	18000b26 	beq	r3,zero,411e30 <udivmodsi4+0x5c>
  411e04:	0005883a 	mov	r2,zero
  411e08:	21400236 	bltu	r4,r5,411e14 <udivmodsi4+0x40>
  411e0c:	2149c83a 	sub	r4,r4,r5
  411e10:	10c4b03a 	or	r2,r2,r3
  411e14:	1806d07a 	srli	r3,r3,1
  411e18:	280ad07a 	srli	r5,r5,1
  411e1c:	183ffa1e 	bne	r3,zero,411e08 <_gp+0xffff2138>
  411e20:	3000011e 	bne	r6,zero,411e28 <udivmodsi4+0x54>
  411e24:	f800283a 	ret
  411e28:	2005883a 	mov	r2,r4
  411e2c:	f800283a 	ret
  411e30:	0005883a 	mov	r2,zero
  411e34:	003ffa06 	br	411e20 <_gp+0xffff2150>
  411e38:	00c00044 	movi	r3,1
  411e3c:	003ff106 	br	411e04 <_gp+0xffff2134>

00411e40 <__divsi3>:
  411e40:	defffe04 	addi	sp,sp,-8
  411e44:	dfc00115 	stw	ra,4(sp)
  411e48:	dc000015 	stw	r16,0(sp)
  411e4c:	20000b16 	blt	r4,zero,411e7c <__divsi3+0x3c>
  411e50:	0021883a 	mov	r16,zero
  411e54:	28000c16 	blt	r5,zero,411e88 <__divsi3+0x48>
  411e58:	000d883a 	mov	r6,zero
  411e5c:	0411dd40 	call	411dd4 <udivmodsi4>
  411e60:	0407c83a 	sub	r3,zero,r16
  411e64:	1884f03a 	xor	r2,r3,r2
  411e68:	1405883a 	add	r2,r2,r16
  411e6c:	dfc00117 	ldw	ra,4(sp)
  411e70:	dc000017 	ldw	r16,0(sp)
  411e74:	dec00204 	addi	sp,sp,8
  411e78:	f800283a 	ret
  411e7c:	0109c83a 	sub	r4,zero,r4
  411e80:	04000044 	movi	r16,1
  411e84:	283ff40e 	bge	r5,zero,411e58 <_gp+0xffff2188>
  411e88:	014bc83a 	sub	r5,zero,r5
  411e8c:	8400005c 	xori	r16,r16,1
  411e90:	003ff106 	br	411e58 <_gp+0xffff2188>

00411e94 <__modsi3>:
  411e94:	defffd04 	addi	sp,sp,-12
  411e98:	dfc00215 	stw	ra,8(sp)
  411e9c:	dc400115 	stw	r17,4(sp)
  411ea0:	dc000015 	stw	r16,0(sp)
  411ea4:	20000c16 	blt	r4,zero,411ed8 <__modsi3+0x44>
  411ea8:	0023883a 	mov	r17,zero
  411eac:	0021883a 	mov	r16,zero
  411eb0:	28000d16 	blt	r5,zero,411ee8 <__modsi3+0x54>
  411eb4:	01800044 	movi	r6,1
  411eb8:	0411dd40 	call	411dd4 <udivmodsi4>
  411ebc:	1404f03a 	xor	r2,r2,r16
  411ec0:	8885883a 	add	r2,r17,r2
  411ec4:	dfc00217 	ldw	ra,8(sp)
  411ec8:	dc400117 	ldw	r17,4(sp)
  411ecc:	dc000017 	ldw	r16,0(sp)
  411ed0:	dec00304 	addi	sp,sp,12
  411ed4:	f800283a 	ret
  411ed8:	0109c83a 	sub	r4,zero,r4
  411edc:	04400044 	movi	r17,1
  411ee0:	043fffc4 	movi	r16,-1
  411ee4:	283ff30e 	bge	r5,zero,411eb4 <_gp+0xffff21e4>
  411ee8:	014bc83a 	sub	r5,zero,r5
  411eec:	003ff106 	br	411eb4 <_gp+0xffff21e4>

00411ef0 <__udivsi3>:
  411ef0:	000d883a 	mov	r6,zero
  411ef4:	0411dd41 	jmpi	411dd4 <udivmodsi4>

00411ef8 <__umodsi3>:
  411ef8:	01800044 	movi	r6,1
  411efc:	0411dd41 	jmpi	411dd4 <udivmodsi4>

00411f00 <__mulsi3>:
  411f00:	0005883a 	mov	r2,zero
  411f04:	20000726 	beq	r4,zero,411f24 <__mulsi3+0x24>
  411f08:	20c0004c 	andi	r3,r4,1
  411f0c:	2008d07a 	srli	r4,r4,1
  411f10:	18000126 	beq	r3,zero,411f18 <__mulsi3+0x18>
  411f14:	1145883a 	add	r2,r2,r5
  411f18:	294b883a 	add	r5,r5,r5
  411f1c:	203ffa1e 	bne	r4,zero,411f08 <_gp+0xffff2238>
  411f20:	f800283a 	ret
  411f24:	f800283a 	ret

00411f28 <__addsf3>:
  411f28:	defffc04 	addi	sp,sp,-16
  411f2c:	2004d7fa 	srli	r2,r4,31
  411f30:	280ed5fa 	srli	r7,r5,23
  411f34:	dc000015 	stw	r16,0(sp)
  411f38:	01802034 	movhi	r6,128
  411f3c:	2020d5fa 	srli	r16,r4,23
  411f40:	31bfffc4 	addi	r6,r6,-1
  411f44:	2810d7fa 	srli	r8,r5,31
  411f48:	3108703a 	and	r4,r6,r4
  411f4c:	dc800215 	stw	r18,8(sp)
  411f50:	314c703a 	and	r6,r6,r5
  411f54:	84003fcc 	andi	r16,r16,255
  411f58:	200690fa 	slli	r3,r4,3
  411f5c:	dfc00315 	stw	ra,12(sp)
  411f60:	39003fcc 	andi	r4,r7,255
  411f64:	dc400115 	stw	r17,4(sp)
  411f68:	14803fcc 	andi	r18,r2,255
  411f6c:	300c90fa 	slli	r6,r6,3
  411f70:	810bc83a 	sub	r5,r16,r4
  411f74:	92004826 	beq	r18,r8,412098 <__addsf3+0x170>
  411f78:	01406c0e 	bge	zero,r5,41212c <__addsf3+0x204>
  411f7c:	20001e1e 	bne	r4,zero,411ff8 <__addsf3+0xd0>
  411f80:	3000611e 	bne	r6,zero,412108 <__addsf3+0x1e0>
  411f84:	188001cc 	andi	r2,r3,7
  411f88:	10000426 	beq	r2,zero,411f9c <__addsf3+0x74>
  411f8c:	190003cc 	andi	r4,r3,15
  411f90:	00800104 	movi	r2,4
  411f94:	20800126 	beq	r4,r2,411f9c <__addsf3+0x74>
  411f98:	18c00104 	addi	r3,r3,4
  411f9c:	1901002c 	andhi	r4,r3,1024
  411fa0:	9005883a 	mov	r2,r18
  411fa4:	20003426 	beq	r4,zero,412078 <__addsf3+0x150>
  411fa8:	81400044 	addi	r5,r16,1
  411fac:	01003fc4 	movi	r4,255
  411fb0:	29006926 	beq	r5,r4,412158 <__addsf3+0x230>
  411fb4:	180691ba 	slli	r3,r3,6
  411fb8:	1808d27a 	srli	r4,r3,9
  411fbc:	29403fcc 	andi	r5,r5,255
  411fc0:	280a95fa 	slli	r5,r5,23
  411fc4:	10803fcc 	andi	r2,r2,255
  411fc8:	00c02034 	movhi	r3,128
  411fcc:	100497fa 	slli	r2,r2,31
  411fd0:	18ffffc4 	addi	r3,r3,-1
  411fd4:	20c6703a 	and	r3,r4,r3
  411fd8:	1946b03a 	or	r3,r3,r5
  411fdc:	1884b03a 	or	r2,r3,r2
  411fe0:	dfc00317 	ldw	ra,12(sp)
  411fe4:	dc800217 	ldw	r18,8(sp)
  411fe8:	dc400117 	ldw	r17,4(sp)
  411fec:	dc000017 	ldw	r16,0(sp)
  411ff0:	dec00404 	addi	sp,sp,16
  411ff4:	f800283a 	ret
  411ff8:	00803fc4 	movi	r2,255
  411ffc:	80bfe126 	beq	r16,r2,411f84 <_gp+0xffff22b4>
  412000:	31810034 	orhi	r6,r6,1024
  412004:	008006c4 	movi	r2,27
  412008:	11405b0e 	bge	r2,r5,412178 <__addsf3+0x250>
  41200c:	01400044 	movi	r5,1
  412010:	1947c83a 	sub	r3,r3,r5
  412014:	1881002c 	andhi	r2,r3,1024
  412018:	10001426 	beq	r2,zero,41206c <__addsf3+0x144>
  41201c:	04410034 	movhi	r17,1024
  412020:	8c7fffc4 	addi	r17,r17,-1
  412024:	1c62703a 	and	r17,r3,r17
  412028:	8809883a 	mov	r4,r17
  41202c:	0412f000 	call	412f00 <__clzsi2>
  412030:	10bffec4 	addi	r2,r2,-5
  412034:	88a2983a 	sll	r17,r17,r2
  412038:	14004a16 	blt	r2,r16,412164 <__addsf3+0x23c>
  41203c:	140bc83a 	sub	r5,r2,r16
  412040:	00c007c4 	movi	r3,31
  412044:	1947c83a 	sub	r3,r3,r5
  412048:	88c6983a 	sll	r3,r17,r3
  41204c:	29400044 	addi	r5,r5,1
  412050:	8962d83a 	srl	r17,r17,r5
  412054:	1806c03a 	cmpne	r3,r3,zero
  412058:	0021883a 	mov	r16,zero
  41205c:	1c46b03a 	or	r3,r3,r17
  412060:	003fc806 	br	411f84 <_gp+0xffff22b4>
  412064:	1000e526 	beq	r2,zero,4123fc <__addsf3+0x4d4>
  412068:	1007883a 	mov	r3,r2
  41206c:	188001cc 	andi	r2,r3,7
  412070:	103fc61e 	bne	r2,zero,411f8c <_gp+0xffff22bc>
  412074:	9005883a 	mov	r2,r18
  412078:	01003fc4 	movi	r4,255
  41207c:	1806d0fa 	srli	r3,r3,3
  412080:	81001a26 	beq	r16,r4,4120ec <__addsf3+0x1c4>
  412084:	01002034 	movhi	r4,128
  412088:	213fffc4 	addi	r4,r4,-1
  41208c:	800b883a 	mov	r5,r16
  412090:	1908703a 	and	r4,r3,r4
  412094:	003fc906 	br	411fbc <_gp+0xffff22ec>
  412098:	01403e0e 	bge	zero,r5,412194 <__addsf3+0x26c>
  41209c:	20001e26 	beq	r4,zero,412118 <__addsf3+0x1f0>
  4120a0:	01003fc4 	movi	r4,255
  4120a4:	813fb726 	beq	r16,r4,411f84 <_gp+0xffff22b4>
  4120a8:	31810034 	orhi	r6,r6,1024
  4120ac:	010006c4 	movi	r4,27
  4120b0:	2140570e 	bge	r4,r5,412210 <__addsf3+0x2e8>
  4120b4:	01400044 	movi	r5,1
  4120b8:	1947883a 	add	r3,r3,r5
  4120bc:	1901002c 	andhi	r4,r3,1024
  4120c0:	203fea26 	beq	r4,zero,41206c <_gp+0xffff239c>
  4120c4:	84000044 	addi	r16,r16,1
  4120c8:	01003fc4 	movi	r4,255
  4120cc:	81007526 	beq	r16,r4,4122a4 <__addsf3+0x37c>
  4120d0:	00bf0034 	movhi	r2,64512
  4120d4:	10bfffc4 	addi	r2,r2,-1
  4120d8:	1900004c 	andi	r4,r3,1
  4120dc:	1886703a 	and	r3,r3,r2
  4120e0:	1806d07a 	srli	r3,r3,1
  4120e4:	1906b03a 	or	r3,r3,r4
  4120e8:	003fa606 	br	411f84 <_gp+0xffff22b4>
  4120ec:	18001a26 	beq	r3,zero,412158 <__addsf3+0x230>
  4120f0:	19001034 	orhi	r4,r3,64
  4120f4:	00c02034 	movhi	r3,128
  4120f8:	18ffffc4 	addi	r3,r3,-1
  4120fc:	017fffc4 	movi	r5,-1
  412100:	20c8703a 	and	r4,r4,r3
  412104:	003fad06 	br	411fbc <_gp+0xffff22ec>
  412108:	297fffc4 	addi	r5,r5,-1
  41210c:	28002c1e 	bne	r5,zero,4121c0 <__addsf3+0x298>
  412110:	1987c83a 	sub	r3,r3,r6
  412114:	003fbf06 	br	412014 <_gp+0xffff2344>
  412118:	303f9a26 	beq	r6,zero,411f84 <_gp+0xffff22b4>
  41211c:	297fffc4 	addi	r5,r5,-1
  412120:	28004b1e 	bne	r5,zero,412250 <__addsf3+0x328>
  412124:	1987883a 	add	r3,r3,r6
  412128:	003fe406 	br	4120bc <_gp+0xffff23ec>
  41212c:	2800271e 	bne	r5,zero,4121cc <__addsf3+0x2a4>
  412130:	80800044 	addi	r2,r16,1
  412134:	10803fcc 	andi	r2,r2,255
  412138:	01000044 	movi	r4,1
  41213c:	2080520e 	bge	r4,r2,412288 <__addsf3+0x360>
  412140:	19a3c83a 	sub	r17,r3,r6
  412144:	8881002c 	andhi	r2,r17,1024
  412148:	10002c26 	beq	r2,zero,4121fc <__addsf3+0x2d4>
  41214c:	30e3c83a 	sub	r17,r6,r3
  412150:	4025883a 	mov	r18,r8
  412154:	003fb406 	br	412028 <_gp+0xffff2358>
  412158:	017fffc4 	movi	r5,-1
  41215c:	0009883a 	mov	r4,zero
  412160:	003f9606 	br	411fbc <_gp+0xffff22ec>
  412164:	00ff0034 	movhi	r3,64512
  412168:	18ffffc4 	addi	r3,r3,-1
  41216c:	80a1c83a 	sub	r16,r16,r2
  412170:	88c6703a 	and	r3,r17,r3
  412174:	003f8306 	br	411f84 <_gp+0xffff22b4>
  412178:	00800804 	movi	r2,32
  41217c:	1145c83a 	sub	r2,r2,r5
  412180:	3084983a 	sll	r2,r6,r2
  412184:	314cd83a 	srl	r6,r6,r5
  412188:	100ac03a 	cmpne	r5,r2,zero
  41218c:	298ab03a 	or	r5,r5,r6
  412190:	003f9f06 	br	412010 <_gp+0xffff2340>
  412194:	2800451e 	bne	r5,zero,4122ac <__addsf3+0x384>
  412198:	81000044 	addi	r4,r16,1
  41219c:	21c03fcc 	andi	r7,r4,255
  4121a0:	01400044 	movi	r5,1
  4121a4:	29c02d0e 	bge	r5,r7,41225c <__addsf3+0x334>
  4121a8:	01403fc4 	movi	r5,255
  4121ac:	21403c26 	beq	r4,r5,4122a0 <__addsf3+0x378>
  4121b0:	30c7883a 	add	r3,r6,r3
  4121b4:	1806d07a 	srli	r3,r3,1
  4121b8:	2021883a 	mov	r16,r4
  4121bc:	003f7106 	br	411f84 <_gp+0xffff22b4>
  4121c0:	00803fc4 	movi	r2,255
  4121c4:	80bf8f1e 	bne	r16,r2,412004 <_gp+0xffff2334>
  4121c8:	003f6e06 	br	411f84 <_gp+0xffff22b4>
  4121cc:	80001726 	beq	r16,zero,41222c <__addsf3+0x304>
  4121d0:	00803fc4 	movi	r2,255
  4121d4:	20801a26 	beq	r4,r2,412240 <__addsf3+0x318>
  4121d8:	014bc83a 	sub	r5,zero,r5
  4121dc:	18c10034 	orhi	r3,r3,1024
  4121e0:	008006c4 	movi	r2,27
  4121e4:	1140430e 	bge	r2,r5,4122f4 <__addsf3+0x3cc>
  4121e8:	00c00044 	movi	r3,1
  4121ec:	30c7c83a 	sub	r3,r6,r3
  4121f0:	2021883a 	mov	r16,r4
  4121f4:	4025883a 	mov	r18,r8
  4121f8:	003f8606 	br	412014 <_gp+0xffff2344>
  4121fc:	883f8a1e 	bne	r17,zero,412028 <_gp+0xffff2358>
  412200:	0007883a 	mov	r3,zero
  412204:	0005883a 	mov	r2,zero
  412208:	0021883a 	mov	r16,zero
  41220c:	003f9a06 	br	412078 <_gp+0xffff23a8>
  412210:	01000804 	movi	r4,32
  412214:	2149c83a 	sub	r4,r4,r5
  412218:	3108983a 	sll	r4,r6,r4
  41221c:	314cd83a 	srl	r6,r6,r5
  412220:	200ac03a 	cmpne	r5,r4,zero
  412224:	298ab03a 	or	r5,r5,r6
  412228:	003fa306 	br	4120b8 <_gp+0xffff23e8>
  41222c:	18000426 	beq	r3,zero,412240 <__addsf3+0x318>
  412230:	014a303a 	nor	r5,zero,r5
  412234:	283fed26 	beq	r5,zero,4121ec <_gp+0xffff251c>
  412238:	00803fc4 	movi	r2,255
  41223c:	20bfe81e 	bne	r4,r2,4121e0 <_gp+0xffff2510>
  412240:	3007883a 	mov	r3,r6
  412244:	2021883a 	mov	r16,r4
  412248:	4025883a 	mov	r18,r8
  41224c:	003f4d06 	br	411f84 <_gp+0xffff22b4>
  412250:	01003fc4 	movi	r4,255
  412254:	813f951e 	bne	r16,r4,4120ac <_gp+0xffff23dc>
  412258:	003f4a06 	br	411f84 <_gp+0xffff22b4>
  41225c:	8000471e 	bne	r16,zero,41237c <__addsf3+0x454>
  412260:	18006126 	beq	r3,zero,4123e8 <__addsf3+0x4c0>
  412264:	303f4726 	beq	r6,zero,411f84 <_gp+0xffff22b4>
  412268:	1987883a 	add	r3,r3,r6
  41226c:	1881002c 	andhi	r2,r3,1024
  412270:	103f7e26 	beq	r2,zero,41206c <_gp+0xffff239c>
  412274:	00bf0034 	movhi	r2,64512
  412278:	10bfffc4 	addi	r2,r2,-1
  41227c:	2821883a 	mov	r16,r5
  412280:	1886703a 	and	r3,r3,r2
  412284:	003f3f06 	br	411f84 <_gp+0xffff22b4>
  412288:	8000141e 	bne	r16,zero,4122dc <__addsf3+0x3b4>
  41228c:	1800311e 	bne	r3,zero,412354 <__addsf3+0x42c>
  412290:	30004626 	beq	r6,zero,4123ac <__addsf3+0x484>
  412294:	3007883a 	mov	r3,r6
  412298:	4025883a 	mov	r18,r8
  41229c:	003f3906 	br	411f84 <_gp+0xffff22b4>
  4122a0:	2021883a 	mov	r16,r4
  4122a4:	0007883a 	mov	r3,zero
  4122a8:	003f7306 	br	412078 <_gp+0xffff23a8>
  4122ac:	8000181e 	bne	r16,zero,412310 <__addsf3+0x3e8>
  4122b0:	18002f26 	beq	r3,zero,412370 <__addsf3+0x448>
  4122b4:	014a303a 	nor	r5,zero,r5
  4122b8:	28000526 	beq	r5,zero,4122d0 <__addsf3+0x3a8>
  4122bc:	01c03fc4 	movi	r7,255
  4122c0:	21c02b26 	beq	r4,r7,412370 <__addsf3+0x448>
  4122c4:	01c006c4 	movi	r7,27
  4122c8:	3940400e 	bge	r7,r5,4123cc <__addsf3+0x4a4>
  4122cc:	00c00044 	movi	r3,1
  4122d0:	1987883a 	add	r3,r3,r6
  4122d4:	2021883a 	mov	r16,r4
  4122d8:	003f7806 	br	4120bc <_gp+0xffff23ec>
  4122dc:	1800111e 	bne	r3,zero,412324 <__addsf3+0x3fc>
  4122e0:	30003526 	beq	r6,zero,4123b8 <__addsf3+0x490>
  4122e4:	3007883a 	mov	r3,r6
  4122e8:	4025883a 	mov	r18,r8
  4122ec:	04003fc4 	movi	r16,255
  4122f0:	003f2406 	br	411f84 <_gp+0xffff22b4>
  4122f4:	00800804 	movi	r2,32
  4122f8:	1145c83a 	sub	r2,r2,r5
  4122fc:	1884983a 	sll	r2,r3,r2
  412300:	194ad83a 	srl	r5,r3,r5
  412304:	1006c03a 	cmpne	r3,r2,zero
  412308:	1946b03a 	or	r3,r3,r5
  41230c:	003fb706 	br	4121ec <_gp+0xffff251c>
  412310:	01c03fc4 	movi	r7,255
  412314:	21c01626 	beq	r4,r7,412370 <__addsf3+0x448>
  412318:	014bc83a 	sub	r5,zero,r5
  41231c:	18c10034 	orhi	r3,r3,1024
  412320:	003fe806 	br	4122c4 <_gp+0xffff25f4>
  412324:	30001f26 	beq	r6,zero,4123a4 <__addsf3+0x47c>
  412328:	1806d0fa 	srli	r3,r3,3
  41232c:	1880102c 	andhi	r2,r3,64
  412330:	10000526 	beq	r2,zero,412348 <__addsf3+0x420>
  412334:	300cd0fa 	srli	r6,r6,3
  412338:	3080102c 	andhi	r2,r6,64
  41233c:	1000021e 	bne	r2,zero,412348 <__addsf3+0x420>
  412340:	3007883a 	mov	r3,r6
  412344:	4025883a 	mov	r18,r8
  412348:	180690fa 	slli	r3,r3,3
  41234c:	04003fc4 	movi	r16,255
  412350:	003f0c06 	br	411f84 <_gp+0xffff22b4>
  412354:	303f0b26 	beq	r6,zero,411f84 <_gp+0xffff22b4>
  412358:	1985c83a 	sub	r2,r3,r6
  41235c:	1101002c 	andhi	r4,r2,1024
  412360:	203f4026 	beq	r4,zero,412064 <_gp+0xffff2394>
  412364:	30c7c83a 	sub	r3,r6,r3
  412368:	4025883a 	mov	r18,r8
  41236c:	003f0506 	br	411f84 <_gp+0xffff22b4>
  412370:	3007883a 	mov	r3,r6
  412374:	2021883a 	mov	r16,r4
  412378:	003f0206 	br	411f84 <_gp+0xffff22b4>
  41237c:	18001c26 	beq	r3,zero,4123f0 <__addsf3+0x4c8>
  412380:	30000826 	beq	r6,zero,4123a4 <__addsf3+0x47c>
  412384:	1806d0fa 	srli	r3,r3,3
  412388:	1880102c 	andhi	r2,r3,64
  41238c:	103fee26 	beq	r2,zero,412348 <_gp+0xffff2678>
  412390:	300cd0fa 	srli	r6,r6,3
  412394:	3080102c 	andhi	r2,r6,64
  412398:	103feb1e 	bne	r2,zero,412348 <_gp+0xffff2678>
  41239c:	3007883a 	mov	r3,r6
  4123a0:	003fe906 	br	412348 <_gp+0xffff2678>
  4123a4:	04003fc4 	movi	r16,255
  4123a8:	003ef606 	br	411f84 <_gp+0xffff22b4>
  4123ac:	8007883a 	mov	r3,r16
  4123b0:	0005883a 	mov	r2,zero
  4123b4:	003f3006 	br	412078 <_gp+0xffff23a8>
  4123b8:	00c10034 	movhi	r3,1024
  4123bc:	0005883a 	mov	r2,zero
  4123c0:	18fffe04 	addi	r3,r3,-8
  4123c4:	04003fc4 	movi	r16,255
  4123c8:	003f2b06 	br	412078 <_gp+0xffff23a8>
  4123cc:	01c00804 	movi	r7,32
  4123d0:	394fc83a 	sub	r7,r7,r5
  4123d4:	19ce983a 	sll	r7,r3,r7
  4123d8:	194ad83a 	srl	r5,r3,r5
  4123dc:	3806c03a 	cmpne	r3,r7,zero
  4123e0:	1946b03a 	or	r3,r3,r5
  4123e4:	003fba06 	br	4122d0 <_gp+0xffff2600>
  4123e8:	3007883a 	mov	r3,r6
  4123ec:	003ee506 	br	411f84 <_gp+0xffff22b4>
  4123f0:	3007883a 	mov	r3,r6
  4123f4:	04003fc4 	movi	r16,255
  4123f8:	003ee206 	br	411f84 <_gp+0xffff22b4>
  4123fc:	0007883a 	mov	r3,zero
  412400:	0005883a 	mov	r2,zero
  412404:	003f1c06 	br	412078 <_gp+0xffff23a8>

00412408 <__divsf3>:
  412408:	defff504 	addi	sp,sp,-44
  41240c:	dd000515 	stw	r20,20(sp)
  412410:	2028d5fa 	srli	r20,r4,23
  412414:	dd400615 	stw	r21,24(sp)
  412418:	202ad7fa 	srli	r21,r4,31
  41241c:	00c02034 	movhi	r3,128
  412420:	dcc00415 	stw	r19,16(sp)
  412424:	dc800315 	stw	r18,12(sp)
  412428:	18ffffc4 	addi	r3,r3,-1
  41242c:	dfc00a15 	stw	ra,40(sp)
  412430:	df000915 	stw	fp,36(sp)
  412434:	ddc00815 	stw	r23,32(sp)
  412438:	dd800715 	stw	r22,28(sp)
  41243c:	dc400215 	stw	r17,8(sp)
  412440:	dc000115 	stw	r16,4(sp)
  412444:	a5003fcc 	andi	r20,r20,255
  412448:	1924703a 	and	r18,r3,r4
  41244c:	acc03fcc 	andi	r19,r21,255
  412450:	a0004d26 	beq	r20,zero,412588 <__divsf3+0x180>
  412454:	00803fc4 	movi	r2,255
  412458:	a0802e26 	beq	r20,r2,412514 <__divsf3+0x10c>
  41245c:	91002034 	orhi	r4,r18,128
  412460:	202490fa 	slli	r18,r4,3
  412464:	a53fe044 	addi	r20,r20,-127
  412468:	0021883a 	mov	r16,zero
  41246c:	002f883a 	mov	r23,zero
  412470:	2804d5fa 	srli	r2,r5,23
  412474:	282cd7fa 	srli	r22,r5,31
  412478:	00c02034 	movhi	r3,128
  41247c:	18ffffc4 	addi	r3,r3,-1
  412480:	10803fcc 	andi	r2,r2,255
  412484:	1962703a 	and	r17,r3,r5
  412488:	b7003fcc 	andi	fp,r22,255
  41248c:	10004526 	beq	r2,zero,4125a4 <__divsf3+0x19c>
  412490:	00c03fc4 	movi	r3,255
  412494:	10c04026 	beq	r2,r3,412598 <__divsf3+0x190>
  412498:	88c02034 	orhi	r3,r17,128
  41249c:	182290fa 	slli	r17,r3,3
  4124a0:	10bfe044 	addi	r2,r2,-127
  4124a4:	0009883a 	mov	r4,zero
  4124a8:	2420b03a 	or	r16,r4,r16
  4124ac:	802090ba 	slli	r16,r16,2
  4124b0:	01c01074 	movhi	r7,65
  4124b4:	39c93504 	addi	r7,r7,9428
  4124b8:	81e1883a 	add	r16,r16,r7
  4124bc:	80c00017 	ldw	r3,0(r16)
  4124c0:	ad8af03a 	xor	r5,r21,r22
  4124c4:	280d883a 	mov	r6,r5
  4124c8:	a085c83a 	sub	r2,r20,r2
  4124cc:	29403fcc 	andi	r5,r5,255
  4124d0:	1800683a 	jmp	r3
  4124d4:	004126e0 	cmpeqi	at,zero,1179
  4124d8:	00412688 	cmpgei	at,zero,1178
  4124dc:	004126ac 	andhi	at,zero,1178
  4124e0:	00412674 	movhi	at,1177
  4124e4:	004126ac 	andhi	at,zero,1178
  4124e8:	00412524 	muli	at,zero,1172
  4124ec:	004126ac 	andhi	at,zero,1178
  4124f0:	00412674 	movhi	at,1177
  4124f4:	00412688 	cmpgei	at,zero,1178
  4124f8:	00412688 	cmpgei	at,zero,1178
  4124fc:	00412524 	muli	at,zero,1172
  412500:	00412674 	movhi	at,1177
  412504:	00412778 	rdprs	at,zero,1181
  412508:	00412778 	rdprs	at,zero,1181
  41250c:	00412778 	rdprs	at,zero,1181
  412510:	004126b8 	rdprs	at,zero,1178
  412514:	9000531e 	bne	r18,zero,412664 <__divsf3+0x25c>
  412518:	04000204 	movi	r16,8
  41251c:	05c00084 	movi	r23,2
  412520:	003fd306 	br	412470 <_gp+0xffff27a0>
  412524:	00c02034 	movhi	r3,128
  412528:	000d883a 	mov	r6,zero
  41252c:	18ffffc4 	addi	r3,r3,-1
  412530:	013fffc4 	movi	r4,-1
  412534:	21003fcc 	andi	r4,r4,255
  412538:	200895fa 	slli	r4,r4,23
  41253c:	30803fcc 	andi	r2,r6,255
  412540:	01802034 	movhi	r6,128
  412544:	31bfffc4 	addi	r6,r6,-1
  412548:	100497fa 	slli	r2,r2,31
  41254c:	1986703a 	and	r3,r3,r6
  412550:	1906b03a 	or	r3,r3,r4
  412554:	1884b03a 	or	r2,r3,r2
  412558:	dfc00a17 	ldw	ra,40(sp)
  41255c:	df000917 	ldw	fp,36(sp)
  412560:	ddc00817 	ldw	r23,32(sp)
  412564:	dd800717 	ldw	r22,28(sp)
  412568:	dd400617 	ldw	r21,24(sp)
  41256c:	dd000517 	ldw	r20,20(sp)
  412570:	dcc00417 	ldw	r19,16(sp)
  412574:	dc800317 	ldw	r18,12(sp)
  412578:	dc400217 	ldw	r17,8(sp)
  41257c:	dc000117 	ldw	r16,4(sp)
  412580:	dec00b04 	addi	sp,sp,44
  412584:	f800283a 	ret
  412588:	90002b1e 	bne	r18,zero,412638 <__divsf3+0x230>
  41258c:	04000104 	movi	r16,4
  412590:	05c00044 	movi	r23,1
  412594:	003fb606 	br	412470 <_gp+0xffff27a0>
  412598:	8800251e 	bne	r17,zero,412630 <__divsf3+0x228>
  41259c:	01000084 	movi	r4,2
  4125a0:	00000206 	br	4125ac <__divsf3+0x1a4>
  4125a4:	88001a1e 	bne	r17,zero,412610 <__divsf3+0x208>
  4125a8:	01000044 	movi	r4,1
  4125ac:	2420b03a 	or	r16,r4,r16
  4125b0:	802090ba 	slli	r16,r16,2
  4125b4:	00c01074 	movhi	r3,65
  4125b8:	18c97404 	addi	r3,r3,9680
  4125bc:	80e1883a 	add	r16,r16,r3
  4125c0:	80c00017 	ldw	r3,0(r16)
  4125c4:	ad8af03a 	xor	r5,r21,r22
  4125c8:	a085c83a 	sub	r2,r20,r2
  4125cc:	1800683a 	jmp	r3
  4125d0:	00412688 	cmpgei	at,zero,1178
  4125d4:	00412688 	cmpgei	at,zero,1178
  4125d8:	004127d8 	cmpnei	at,zero,1183
  4125dc:	00412670 	cmpltui	at,zero,1177
  4125e0:	004127d8 	cmpnei	at,zero,1183
  4125e4:	00412524 	muli	at,zero,1172
  4125e8:	004127d8 	cmpnei	at,zero,1183
  4125ec:	00412670 	cmpltui	at,zero,1177
  4125f0:	00412688 	cmpgei	at,zero,1178
  4125f4:	00412688 	cmpgei	at,zero,1178
  4125f8:	00412524 	muli	at,zero,1172
  4125fc:	00412670 	cmpltui	at,zero,1177
  412600:	00412778 	rdprs	at,zero,1181
  412604:	00412778 	rdprs	at,zero,1181
  412608:	00412778 	rdprs	at,zero,1181
  41260c:	004127a4 	muli	at,zero,1182
  412610:	8809883a 	mov	r4,r17
  412614:	0412f000 	call	412f00 <__clzsi2>
  412618:	10fffec4 	addi	r3,r2,-5
  41261c:	88e2983a 	sll	r17,r17,r3
  412620:	00ffe284 	movi	r3,-118
  412624:	1885c83a 	sub	r2,r3,r2
  412628:	0009883a 	mov	r4,zero
  41262c:	003f9e06 	br	4124a8 <_gp+0xffff27d8>
  412630:	010000c4 	movi	r4,3
  412634:	003f9c06 	br	4124a8 <_gp+0xffff27d8>
  412638:	9009883a 	mov	r4,r18
  41263c:	d9400015 	stw	r5,0(sp)
  412640:	0412f000 	call	412f00 <__clzsi2>
  412644:	10fffec4 	addi	r3,r2,-5
  412648:	053fe284 	movi	r20,-118
  41264c:	90e4983a 	sll	r18,r18,r3
  412650:	a0a9c83a 	sub	r20,r20,r2
  412654:	0021883a 	mov	r16,zero
  412658:	002f883a 	mov	r23,zero
  41265c:	d9400017 	ldw	r5,0(sp)
  412660:	003f8306 	br	412470 <_gp+0xffff27a0>
  412664:	04000304 	movi	r16,12
  412668:	05c000c4 	movi	r23,3
  41266c:	003f8006 	br	412470 <_gp+0xffff27a0>
  412670:	0023883a 	mov	r17,zero
  412674:	e027883a 	mov	r19,fp
  412678:	202f883a 	mov	r23,r4
  41267c:	00c00084 	movi	r3,2
  412680:	980b883a 	mov	r5,r19
  412684:	b8c0501e 	bne	r23,r3,4127c8 <__divsf3+0x3c0>
  412688:	2980004c 	andi	r6,r5,1
  41268c:	013fffc4 	movi	r4,-1
  412690:	0007883a 	mov	r3,zero
  412694:	003fa706 	br	412534 <_gp+0xffff2864>
  412698:	013fe084 	movi	r4,-126
  41269c:	2089c83a 	sub	r4,r4,r2
  4126a0:	00c006c4 	movi	r3,27
  4126a4:	1900500e 	bge	r3,r4,4127e8 <__divsf3+0x3e0>
  4126a8:	9980004c 	andi	r6,r19,1
  4126ac:	0009883a 	mov	r4,zero
  4126b0:	0007883a 	mov	r3,zero
  4126b4:	003f9f06 	br	412534 <_gp+0xffff2864>
  4126b8:	9080102c 	andhi	r2,r18,64
  4126bc:	10000226 	beq	r2,zero,4126c8 <__divsf3+0x2c0>
  4126c0:	8880102c 	andhi	r2,r17,64
  4126c4:	10003a26 	beq	r2,zero,4127b0 <__divsf3+0x3a8>
  4126c8:	00802034 	movhi	r2,128
  4126cc:	90c01034 	orhi	r3,r18,64
  4126d0:	10bfffc4 	addi	r2,r2,-1
  4126d4:	a80d883a 	mov	r6,r21
  4126d8:	1886703a 	and	r3,r3,r2
  4126dc:	003f9406 	br	412530 <_gp+0xffff2860>
  4126e0:	9006917a 	slli	r3,r18,5
  4126e4:	8822917a 	slli	r17,r17,5
  4126e8:	1c402936 	bltu	r3,r17,412790 <__divsf3+0x388>
  4126ec:	1c47c83a 	sub	r3,r3,r17
  4126f0:	2827883a 	mov	r19,r5
  4126f4:	01800684 	movi	r6,26
  4126f8:	01000044 	movi	r4,1
  4126fc:	180f883a 	mov	r7,r3
  412700:	2109883a 	add	r4,r4,r4
  412704:	18c7883a 	add	r3,r3,r3
  412708:	38000116 	blt	r7,zero,412710 <__divsf3+0x308>
  41270c:	1c400236 	bltu	r3,r17,412718 <__divsf3+0x310>
  412710:	1c47c83a 	sub	r3,r3,r17
  412714:	21000054 	ori	r4,r4,1
  412718:	31bfffc4 	addi	r6,r6,-1
  41271c:	303ff71e 	bne	r6,zero,4126fc <_gp+0xffff2a2c>
  412720:	1806c03a 	cmpne	r3,r3,zero
  412724:	1922b03a 	or	r17,r3,r4
  412728:	11001fc4 	addi	r4,r2,127
  41272c:	013fda0e 	bge	zero,r4,412698 <_gp+0xffff29c8>
  412730:	88c001cc 	andi	r3,r17,7
  412734:	18000426 	beq	r3,zero,412748 <__divsf3+0x340>
  412738:	894003cc 	andi	r5,r17,15
  41273c:	00c00104 	movi	r3,4
  412740:	28c00126 	beq	r5,r3,412748 <__divsf3+0x340>
  412744:	88e3883a 	add	r17,r17,r3
  412748:	88c2002c 	andhi	r3,r17,2048
  41274c:	18000426 	beq	r3,zero,412760 <__divsf3+0x358>
  412750:	11002004 	addi	r4,r2,128
  412754:	00be0034 	movhi	r2,63488
  412758:	10bfffc4 	addi	r2,r2,-1
  41275c:	88a2703a 	and	r17,r17,r2
  412760:	00803f84 	movi	r2,254
  412764:	1100060e 	bge	r2,r4,412780 <__divsf3+0x378>
  412768:	9980004c 	andi	r6,r19,1
  41276c:	013fffc4 	movi	r4,-1
  412770:	0007883a 	mov	r3,zero
  412774:	003f6f06 	br	412534 <_gp+0xffff2864>
  412778:	9023883a 	mov	r17,r18
  41277c:	003fbf06 	br	41267c <_gp+0xffff29ac>
  412780:	880691ba 	slli	r3,r17,6
  412784:	9980004c 	andi	r6,r19,1
  412788:	1806d27a 	srli	r3,r3,9
  41278c:	003f6906 	br	412534 <_gp+0xffff2864>
  412790:	10bfffc4 	addi	r2,r2,-1
  412794:	2827883a 	mov	r19,r5
  412798:	018006c4 	movi	r6,27
  41279c:	0009883a 	mov	r4,zero
  4127a0:	003fd606 	br	4126fc <_gp+0xffff2a2c>
  4127a4:	9080102c 	andhi	r2,r18,64
  4127a8:	0023883a 	mov	r17,zero
  4127ac:	103fc626 	beq	r2,zero,4126c8 <_gp+0xffff29f8>
  4127b0:	00802034 	movhi	r2,128
  4127b4:	88c01034 	orhi	r3,r17,64
  4127b8:	10bfffc4 	addi	r2,r2,-1
  4127bc:	b00d883a 	mov	r6,r22
  4127c0:	1886703a 	and	r3,r3,r2
  4127c4:	003f5a06 	br	412530 <_gp+0xffff2860>
  4127c8:	00c000c4 	movi	r3,3
  4127cc:	b8c01c26 	beq	r23,r3,412840 <__divsf3+0x438>
  4127d0:	00c00044 	movi	r3,1
  4127d4:	b8ffd41e 	bne	r23,r3,412728 <_gp+0xffff2a58>
  4127d8:	2980004c 	andi	r6,r5,1
  4127dc:	0009883a 	mov	r4,zero
  4127e0:	0007883a 	mov	r3,zero
  4127e4:	003f5306 	br	412534 <_gp+0xffff2864>
  4127e8:	10802784 	addi	r2,r2,158
  4127ec:	8884983a 	sll	r2,r17,r2
  4127f0:	8908d83a 	srl	r4,r17,r4
  4127f4:	1022c03a 	cmpne	r17,r2,zero
  4127f8:	8908b03a 	or	r4,r17,r4
  4127fc:	208001cc 	andi	r2,r4,7
  412800:	10000426 	beq	r2,zero,412814 <__divsf3+0x40c>
  412804:	20c003cc 	andi	r3,r4,15
  412808:	00800104 	movi	r2,4
  41280c:	18800126 	beq	r3,r2,412814 <__divsf3+0x40c>
  412810:	2089883a 	add	r4,r4,r2
  412814:	2081002c 	andhi	r2,r4,1024
  412818:	10000426 	beq	r2,zero,41282c <__divsf3+0x424>
  41281c:	9980004c 	andi	r6,r19,1
  412820:	01000044 	movi	r4,1
  412824:	0007883a 	mov	r3,zero
  412828:	003f4206 	br	412534 <_gp+0xffff2864>
  41282c:	200691ba 	slli	r3,r4,6
  412830:	9980004c 	andi	r6,r19,1
  412834:	0009883a 	mov	r4,zero
  412838:	1806d27a 	srli	r3,r3,9
  41283c:	003f3d06 	br	412534 <_gp+0xffff2864>
  412840:	00802034 	movhi	r2,128
  412844:	88c01034 	orhi	r3,r17,64
  412848:	10bfffc4 	addi	r2,r2,-1
  41284c:	9980004c 	andi	r6,r19,1
  412850:	1886703a 	and	r3,r3,r2
  412854:	003f3606 	br	412530 <_gp+0xffff2860>

00412858 <__subsf3>:
  412858:	defffc04 	addi	sp,sp,-16
  41285c:	280ed5fa 	srli	r7,r5,23
  412860:	02002034 	movhi	r8,128
  412864:	280d883a 	mov	r6,r5
  412868:	423fffc4 	addi	r8,r8,-1
  41286c:	200ad5fa 	srli	r5,r4,23
  412870:	dc400115 	stw	r17,4(sp)
  412874:	2022d7fa 	srli	r17,r4,31
  412878:	4108703a 	and	r4,r8,r4
  41287c:	dc000015 	stw	r16,0(sp)
  412880:	4190703a 	and	r8,r8,r6
  412884:	200690fa 	slli	r3,r4,3
  412888:	dfc00315 	stw	ra,12(sp)
  41288c:	dc800215 	stw	r18,8(sp)
  412890:	39c03fcc 	andi	r7,r7,255
  412894:	01003fc4 	movi	r4,255
  412898:	8805883a 	mov	r2,r17
  41289c:	2c003fcc 	andi	r16,r5,255
  4128a0:	8c403fcc 	andi	r17,r17,255
  4128a4:	300cd7fa 	srli	r6,r6,31
  4128a8:	401090fa 	slli	r8,r8,3
  4128ac:	39006126 	beq	r7,r4,412a34 <__subsf3+0x1dc>
  4128b0:	3180005c 	xori	r6,r6,1
  4128b4:	89804926 	beq	r17,r6,4129dc <__subsf3+0x184>
  4128b8:	81c5c83a 	sub	r2,r16,r7
  4128bc:	0080710e 	bge	zero,r2,412a84 <__subsf3+0x22c>
  4128c0:	38001e1e 	bne	r7,zero,41293c <__subsf3+0xe4>
  4128c4:	4000651e 	bne	r8,zero,412a5c <__subsf3+0x204>
  4128c8:	188001cc 	andi	r2,r3,7
  4128cc:	10000426 	beq	r2,zero,4128e0 <__subsf3+0x88>
  4128d0:	190003cc 	andi	r4,r3,15
  4128d4:	00800104 	movi	r2,4
  4128d8:	20800126 	beq	r4,r2,4128e0 <__subsf3+0x88>
  4128dc:	18c00104 	addi	r3,r3,4
  4128e0:	1901002c 	andhi	r4,r3,1024
  4128e4:	8880004c 	andi	r2,r17,1
  4128e8:	20003426 	beq	r4,zero,4129bc <__subsf3+0x164>
  4128ec:	81400044 	addi	r5,r16,1
  4128f0:	01003fc4 	movi	r4,255
  4128f4:	29006e26 	beq	r5,r4,412ab0 <__subsf3+0x258>
  4128f8:	180691ba 	slli	r3,r3,6
  4128fc:	1808d27a 	srli	r4,r3,9
  412900:	29403fcc 	andi	r5,r5,255
  412904:	280a95fa 	slli	r5,r5,23
  412908:	10803fcc 	andi	r2,r2,255
  41290c:	00c02034 	movhi	r3,128
  412910:	100497fa 	slli	r2,r2,31
  412914:	18ffffc4 	addi	r3,r3,-1
  412918:	20c6703a 	and	r3,r4,r3
  41291c:	1946b03a 	or	r3,r3,r5
  412920:	1884b03a 	or	r2,r3,r2
  412924:	dfc00317 	ldw	ra,12(sp)
  412928:	dc800217 	ldw	r18,8(sp)
  41292c:	dc400117 	ldw	r17,4(sp)
  412930:	dc000017 	ldw	r16,0(sp)
  412934:	dec00404 	addi	sp,sp,16
  412938:	f800283a 	ret
  41293c:	01003fc4 	movi	r4,255
  412940:	813fe126 	beq	r16,r4,4128c8 <_gp+0xffff2bf8>
  412944:	42010034 	orhi	r8,r8,1024
  412948:	010006c4 	movi	r4,27
  41294c:	2080600e 	bge	r4,r2,412ad0 <__subsf3+0x278>
  412950:	02000044 	movi	r8,1
  412954:	1a07c83a 	sub	r3,r3,r8
  412958:	1881002c 	andhi	r2,r3,1024
  41295c:	10001426 	beq	r2,zero,4129b0 <__subsf3+0x158>
  412960:	04810034 	movhi	r18,1024
  412964:	94bfffc4 	addi	r18,r18,-1
  412968:	1ca4703a 	and	r18,r3,r18
  41296c:	9009883a 	mov	r4,r18
  412970:	0412f000 	call	412f00 <__clzsi2>
  412974:	10bffec4 	addi	r2,r2,-5
  412978:	90a4983a 	sll	r18,r18,r2
  41297c:	14004f16 	blt	r2,r16,412abc <__subsf3+0x264>
  412980:	140bc83a 	sub	r5,r2,r16
  412984:	00c007c4 	movi	r3,31
  412988:	1947c83a 	sub	r3,r3,r5
  41298c:	90c6983a 	sll	r3,r18,r3
  412990:	29400044 	addi	r5,r5,1
  412994:	9164d83a 	srl	r18,r18,r5
  412998:	1806c03a 	cmpne	r3,r3,zero
  41299c:	0021883a 	mov	r16,zero
  4129a0:	1c86b03a 	or	r3,r3,r18
  4129a4:	003fc806 	br	4128c8 <_gp+0xffff2bf8>
  4129a8:	1000e726 	beq	r2,zero,412d48 <__subsf3+0x4f0>
  4129ac:	1007883a 	mov	r3,r2
  4129b0:	188001cc 	andi	r2,r3,7
  4129b4:	103fc61e 	bne	r2,zero,4128d0 <_gp+0xffff2c00>
  4129b8:	8880004c 	andi	r2,r17,1
  4129bc:	01003fc4 	movi	r4,255
  4129c0:	1806d0fa 	srli	r3,r3,3
  4129c4:	81001e26 	beq	r16,r4,412a40 <__subsf3+0x1e8>
  4129c8:	01002034 	movhi	r4,128
  4129cc:	213fffc4 	addi	r4,r4,-1
  4129d0:	800b883a 	mov	r5,r16
  4129d4:	1908703a 	and	r4,r3,r4
  4129d8:	003fc906 	br	412900 <_gp+0xffff2c30>
  4129dc:	81c9c83a 	sub	r4,r16,r7
  4129e0:	0100420e 	bge	zero,r4,412aec <__subsf3+0x294>
  4129e4:	38002226 	beq	r7,zero,412a70 <__subsf3+0x218>
  4129e8:	01403fc4 	movi	r5,255
  4129ec:	817fb626 	beq	r16,r5,4128c8 <_gp+0xffff2bf8>
  4129f0:	42010034 	orhi	r8,r8,1024
  4129f4:	014006c4 	movi	r5,27
  4129f8:	2900580e 	bge	r5,r4,412b5c <__subsf3+0x304>
  4129fc:	01000044 	movi	r4,1
  412a00:	1907883a 	add	r3,r3,r4
  412a04:	1901002c 	andhi	r4,r3,1024
  412a08:	203fe926 	beq	r4,zero,4129b0 <_gp+0xffff2ce0>
  412a0c:	84000044 	addi	r16,r16,1
  412a10:	01003fc4 	movi	r4,255
  412a14:	81007626 	beq	r16,r4,412bf0 <__subsf3+0x398>
  412a18:	00bf0034 	movhi	r2,64512
  412a1c:	10bfffc4 	addi	r2,r2,-1
  412a20:	1900004c 	andi	r4,r3,1
  412a24:	1886703a 	and	r3,r3,r2
  412a28:	1806d07a 	srli	r3,r3,1
  412a2c:	1906b03a 	or	r3,r3,r4
  412a30:	003fa506 	br	4128c8 <_gp+0xffff2bf8>
  412a34:	403f9e26 	beq	r8,zero,4128b0 <_gp+0xffff2be0>
  412a38:	31803fcc 	andi	r6,r6,255
  412a3c:	003f9d06 	br	4128b4 <_gp+0xffff2be4>
  412a40:	18001b26 	beq	r3,zero,412ab0 <__subsf3+0x258>
  412a44:	19001034 	orhi	r4,r3,64
  412a48:	00c02034 	movhi	r3,128
  412a4c:	18ffffc4 	addi	r3,r3,-1
  412a50:	017fffc4 	movi	r5,-1
  412a54:	20c8703a 	and	r4,r4,r3
  412a58:	003fa906 	br	412900 <_gp+0xffff2c30>
  412a5c:	10bfffc4 	addi	r2,r2,-1
  412a60:	103fbc26 	beq	r2,zero,412954 <_gp+0xffff2c84>
  412a64:	01003fc4 	movi	r4,255
  412a68:	813fb71e 	bne	r16,r4,412948 <_gp+0xffff2c78>
  412a6c:	003f9606 	br	4128c8 <_gp+0xffff2bf8>
  412a70:	403f9526 	beq	r8,zero,4128c8 <_gp+0xffff2bf8>
  412a74:	213fffc4 	addi	r4,r4,-1
  412a78:	2000481e 	bne	r4,zero,412b9c <__subsf3+0x344>
  412a7c:	1a07883a 	add	r3,r3,r8
  412a80:	003fe006 	br	412a04 <_gp+0xffff2d34>
  412a84:	1000241e 	bne	r2,zero,412b18 <__subsf3+0x2c0>
  412a88:	80800044 	addi	r2,r16,1
  412a8c:	10803fcc 	andi	r2,r2,255
  412a90:	01000044 	movi	r4,1
  412a94:	20804f0e 	bge	r4,r2,412bd4 <__subsf3+0x37c>
  412a98:	1a25c83a 	sub	r18,r3,r8
  412a9c:	9081002c 	andhi	r2,r18,1024
  412aa0:	10002926 	beq	r2,zero,412b48 <__subsf3+0x2f0>
  412aa4:	40e5c83a 	sub	r18,r8,r3
  412aa8:	3023883a 	mov	r17,r6
  412aac:	003faf06 	br	41296c <_gp+0xffff2c9c>
  412ab0:	017fffc4 	movi	r5,-1
  412ab4:	0009883a 	mov	r4,zero
  412ab8:	003f9106 	br	412900 <_gp+0xffff2c30>
  412abc:	00ff0034 	movhi	r3,64512
  412ac0:	18ffffc4 	addi	r3,r3,-1
  412ac4:	80a1c83a 	sub	r16,r16,r2
  412ac8:	90c6703a 	and	r3,r18,r3
  412acc:	003f7e06 	br	4128c8 <_gp+0xffff2bf8>
  412ad0:	01000804 	movi	r4,32
  412ad4:	2089c83a 	sub	r4,r4,r2
  412ad8:	4108983a 	sll	r4,r8,r4
  412adc:	4090d83a 	srl	r8,r8,r2
  412ae0:	2004c03a 	cmpne	r2,r4,zero
  412ae4:	1210b03a 	or	r8,r2,r8
  412ae8:	003f9a06 	br	412954 <_gp+0xffff2c84>
  412aec:	2000421e 	bne	r4,zero,412bf8 <__subsf3+0x3a0>
  412af0:	81000044 	addi	r4,r16,1
  412af4:	21803fcc 	andi	r6,r4,255
  412af8:	01400044 	movi	r5,1
  412afc:	29802a0e 	bge	r5,r6,412ba8 <__subsf3+0x350>
  412b00:	01403fc4 	movi	r5,255
  412b04:	21403926 	beq	r4,r5,412bec <__subsf3+0x394>
  412b08:	40c7883a 	add	r3,r8,r3
  412b0c:	1806d07a 	srli	r3,r3,1
  412b10:	2021883a 	mov	r16,r4
  412b14:	003f6c06 	br	4128c8 <_gp+0xffff2bf8>
  412b18:	80001726 	beq	r16,zero,412b78 <__subsf3+0x320>
  412b1c:	01003fc4 	movi	r4,255
  412b20:	39001a26 	beq	r7,r4,412b8c <__subsf3+0x334>
  412b24:	0085c83a 	sub	r2,zero,r2
  412b28:	18c10034 	orhi	r3,r3,1024
  412b2c:	010006c4 	movi	r4,27
  412b30:	2080430e 	bge	r4,r2,412c40 <__subsf3+0x3e8>
  412b34:	00c00044 	movi	r3,1
  412b38:	40c7c83a 	sub	r3,r8,r3
  412b3c:	3821883a 	mov	r16,r7
  412b40:	3023883a 	mov	r17,r6
  412b44:	003f8406 	br	412958 <_gp+0xffff2c88>
  412b48:	903f881e 	bne	r18,zero,41296c <_gp+0xffff2c9c>
  412b4c:	0007883a 	mov	r3,zero
  412b50:	0005883a 	mov	r2,zero
  412b54:	0021883a 	mov	r16,zero
  412b58:	003f9806 	br	4129bc <_gp+0xffff2cec>
  412b5c:	01400804 	movi	r5,32
  412b60:	290bc83a 	sub	r5,r5,r4
  412b64:	414a983a 	sll	r5,r8,r5
  412b68:	4110d83a 	srl	r8,r8,r4
  412b6c:	2808c03a 	cmpne	r4,r5,zero
  412b70:	2208b03a 	or	r4,r4,r8
  412b74:	003fa206 	br	412a00 <_gp+0xffff2d30>
  412b78:	18000426 	beq	r3,zero,412b8c <__subsf3+0x334>
  412b7c:	0084303a 	nor	r2,zero,r2
  412b80:	103fed26 	beq	r2,zero,412b38 <_gp+0xffff2e68>
  412b84:	01003fc4 	movi	r4,255
  412b88:	393fe81e 	bne	r7,r4,412b2c <_gp+0xffff2e5c>
  412b8c:	4007883a 	mov	r3,r8
  412b90:	3821883a 	mov	r16,r7
  412b94:	3023883a 	mov	r17,r6
  412b98:	003f4b06 	br	4128c8 <_gp+0xffff2bf8>
  412b9c:	01403fc4 	movi	r5,255
  412ba0:	817f941e 	bne	r16,r5,4129f4 <_gp+0xffff2d24>
  412ba4:	003f4806 	br	4128c8 <_gp+0xffff2bf8>
  412ba8:	8000471e 	bne	r16,zero,412cc8 <__subsf3+0x470>
  412bac:	18006126 	beq	r3,zero,412d34 <__subsf3+0x4dc>
  412bb0:	403f4526 	beq	r8,zero,4128c8 <_gp+0xffff2bf8>
  412bb4:	1a07883a 	add	r3,r3,r8
  412bb8:	1881002c 	andhi	r2,r3,1024
  412bbc:	103f7c26 	beq	r2,zero,4129b0 <_gp+0xffff2ce0>
  412bc0:	00bf0034 	movhi	r2,64512
  412bc4:	10bfffc4 	addi	r2,r2,-1
  412bc8:	2821883a 	mov	r16,r5
  412bcc:	1886703a 	and	r3,r3,r2
  412bd0:	003f3d06 	br	4128c8 <_gp+0xffff2bf8>
  412bd4:	8000141e 	bne	r16,zero,412c28 <__subsf3+0x3d0>
  412bd8:	1800311e 	bne	r3,zero,412ca0 <__subsf3+0x448>
  412bdc:	40004626 	beq	r8,zero,412cf8 <__subsf3+0x4a0>
  412be0:	4007883a 	mov	r3,r8
  412be4:	3023883a 	mov	r17,r6
  412be8:	003f3706 	br	4128c8 <_gp+0xffff2bf8>
  412bec:	2021883a 	mov	r16,r4
  412bf0:	0007883a 	mov	r3,zero
  412bf4:	003f7106 	br	4129bc <_gp+0xffff2cec>
  412bf8:	8000181e 	bne	r16,zero,412c5c <__subsf3+0x404>
  412bfc:	18002f26 	beq	r3,zero,412cbc <__subsf3+0x464>
  412c00:	0108303a 	nor	r4,zero,r4
  412c04:	20000526 	beq	r4,zero,412c1c <__subsf3+0x3c4>
  412c08:	01403fc4 	movi	r5,255
  412c0c:	39402b26 	beq	r7,r5,412cbc <__subsf3+0x464>
  412c10:	014006c4 	movi	r5,27
  412c14:	2900400e 	bge	r5,r4,412d18 <__subsf3+0x4c0>
  412c18:	00c00044 	movi	r3,1
  412c1c:	1a07883a 	add	r3,r3,r8
  412c20:	3821883a 	mov	r16,r7
  412c24:	003f7706 	br	412a04 <_gp+0xffff2d34>
  412c28:	1800111e 	bne	r3,zero,412c70 <__subsf3+0x418>
  412c2c:	40003526 	beq	r8,zero,412d04 <__subsf3+0x4ac>
  412c30:	4007883a 	mov	r3,r8
  412c34:	3023883a 	mov	r17,r6
  412c38:	04003fc4 	movi	r16,255
  412c3c:	003f2206 	br	4128c8 <_gp+0xffff2bf8>
  412c40:	01000804 	movi	r4,32
  412c44:	2089c83a 	sub	r4,r4,r2
  412c48:	1908983a 	sll	r4,r3,r4
  412c4c:	1884d83a 	srl	r2,r3,r2
  412c50:	2006c03a 	cmpne	r3,r4,zero
  412c54:	1886b03a 	or	r3,r3,r2
  412c58:	003fb706 	br	412b38 <_gp+0xffff2e68>
  412c5c:	01403fc4 	movi	r5,255
  412c60:	39401626 	beq	r7,r5,412cbc <__subsf3+0x464>
  412c64:	0109c83a 	sub	r4,zero,r4
  412c68:	18c10034 	orhi	r3,r3,1024
  412c6c:	003fe806 	br	412c10 <_gp+0xffff2f40>
  412c70:	40001f26 	beq	r8,zero,412cf0 <__subsf3+0x498>
  412c74:	1806d0fa 	srli	r3,r3,3
  412c78:	1880102c 	andhi	r2,r3,64
  412c7c:	10000526 	beq	r2,zero,412c94 <__subsf3+0x43c>
  412c80:	4010d0fa 	srli	r8,r8,3
  412c84:	4080102c 	andhi	r2,r8,64
  412c88:	1000021e 	bne	r2,zero,412c94 <__subsf3+0x43c>
  412c8c:	4007883a 	mov	r3,r8
  412c90:	3023883a 	mov	r17,r6
  412c94:	180690fa 	slli	r3,r3,3
  412c98:	04003fc4 	movi	r16,255
  412c9c:	003f0a06 	br	4128c8 <_gp+0xffff2bf8>
  412ca0:	403f0926 	beq	r8,zero,4128c8 <_gp+0xffff2bf8>
  412ca4:	1a05c83a 	sub	r2,r3,r8
  412ca8:	1101002c 	andhi	r4,r2,1024
  412cac:	203f3e26 	beq	r4,zero,4129a8 <_gp+0xffff2cd8>
  412cb0:	40c7c83a 	sub	r3,r8,r3
  412cb4:	3023883a 	mov	r17,r6
  412cb8:	003f0306 	br	4128c8 <_gp+0xffff2bf8>
  412cbc:	4007883a 	mov	r3,r8
  412cc0:	3821883a 	mov	r16,r7
  412cc4:	003f0006 	br	4128c8 <_gp+0xffff2bf8>
  412cc8:	18001c26 	beq	r3,zero,412d3c <__subsf3+0x4e4>
  412ccc:	40000826 	beq	r8,zero,412cf0 <__subsf3+0x498>
  412cd0:	1806d0fa 	srli	r3,r3,3
  412cd4:	1880102c 	andhi	r2,r3,64
  412cd8:	103fee26 	beq	r2,zero,412c94 <_gp+0xffff2fc4>
  412cdc:	4010d0fa 	srli	r8,r8,3
  412ce0:	4080102c 	andhi	r2,r8,64
  412ce4:	103feb1e 	bne	r2,zero,412c94 <_gp+0xffff2fc4>
  412ce8:	4007883a 	mov	r3,r8
  412cec:	003fe906 	br	412c94 <_gp+0xffff2fc4>
  412cf0:	04003fc4 	movi	r16,255
  412cf4:	003ef406 	br	4128c8 <_gp+0xffff2bf8>
  412cf8:	8007883a 	mov	r3,r16
  412cfc:	0005883a 	mov	r2,zero
  412d00:	003f2e06 	br	4129bc <_gp+0xffff2cec>
  412d04:	00c10034 	movhi	r3,1024
  412d08:	0005883a 	mov	r2,zero
  412d0c:	18fffe04 	addi	r3,r3,-8
  412d10:	04003fc4 	movi	r16,255
  412d14:	003f2906 	br	4129bc <_gp+0xffff2cec>
  412d18:	01400804 	movi	r5,32
  412d1c:	290bc83a 	sub	r5,r5,r4
  412d20:	194a983a 	sll	r5,r3,r5
  412d24:	1908d83a 	srl	r4,r3,r4
  412d28:	2806c03a 	cmpne	r3,r5,zero
  412d2c:	1906b03a 	or	r3,r3,r4
  412d30:	003fba06 	br	412c1c <_gp+0xffff2f4c>
  412d34:	4007883a 	mov	r3,r8
  412d38:	003ee306 	br	4128c8 <_gp+0xffff2bf8>
  412d3c:	4007883a 	mov	r3,r8
  412d40:	04003fc4 	movi	r16,255
  412d44:	003ee006 	br	4128c8 <_gp+0xffff2bf8>
  412d48:	0007883a 	mov	r3,zero
  412d4c:	0005883a 	mov	r2,zero
  412d50:	003f1a06 	br	4129bc <_gp+0xffff2cec>

00412d54 <__fixsfsi>:
  412d54:	2006d5fa 	srli	r3,r4,23
  412d58:	00802034 	movhi	r2,128
  412d5c:	10bfffc4 	addi	r2,r2,-1
  412d60:	18c03fcc 	andi	r3,r3,255
  412d64:	01401f84 	movi	r5,126
  412d68:	1104703a 	and	r2,r2,r4
  412d6c:	2008d7fa 	srli	r4,r4,31
  412d70:	28c0110e 	bge	r5,r3,412db8 <__fixsfsi+0x64>
  412d74:	01402744 	movi	r5,157
  412d78:	28c00b16 	blt	r5,r3,412da8 <__fixsfsi+0x54>
  412d7c:	01402544 	movi	r5,149
  412d80:	10802034 	orhi	r2,r2,128
  412d84:	28c00e16 	blt	r5,r3,412dc0 <__fixsfsi+0x6c>
  412d88:	01402584 	movi	r5,150
  412d8c:	28c7c83a 	sub	r3,r5,r3
  412d90:	10c6d83a 	srl	r3,r2,r3
  412d94:	21003fcc 	andi	r4,r4,255
  412d98:	0105c83a 	sub	r2,zero,r4
  412d9c:	1886f03a 	xor	r3,r3,r2
  412da0:	1905883a 	add	r2,r3,r4
  412da4:	f800283a 	ret
  412da8:	00a00034 	movhi	r2,32768
  412dac:	10bfffc4 	addi	r2,r2,-1
  412db0:	2085883a 	add	r2,r4,r2
  412db4:	f800283a 	ret
  412db8:	0005883a 	mov	r2,zero
  412dbc:	f800283a 	ret
  412dc0:	18ffda84 	addi	r3,r3,-150
  412dc4:	10c6983a 	sll	r3,r2,r3
  412dc8:	003ff206 	br	412d94 <_gp+0xffff30c4>

00412dcc <__floatsisf>:
  412dcc:	defffd04 	addi	sp,sp,-12
  412dd0:	dc000015 	stw	r16,0(sp)
  412dd4:	dfc00215 	stw	ra,8(sp)
  412dd8:	dc400115 	stw	r17,4(sp)
  412ddc:	2021883a 	mov	r16,r4
  412de0:	20003a26 	beq	r4,zero,412ecc <__floatsisf+0x100>
  412de4:	2022d7fa 	srli	r17,r4,31
  412de8:	88000126 	beq	r17,zero,412df0 <__floatsisf+0x24>
  412dec:	0121c83a 	sub	r16,zero,r4
  412df0:	8009883a 	mov	r4,r16
  412df4:	0412f000 	call	412f00 <__clzsi2>
  412df8:	00c02784 	movi	r3,158
  412dfc:	1887c83a 	sub	r3,r3,r2
  412e00:	01802584 	movi	r6,150
  412e04:	800b883a 	mov	r5,r16
  412e08:	30c01616 	blt	r6,r3,412e64 <__floatsisf+0x98>
  412e0c:	01000204 	movi	r4,8
  412e10:	2080020e 	bge	r4,r2,412e1c <__floatsisf+0x50>
  412e14:	10bffe04 	addi	r2,r2,-8
  412e18:	80a0983a 	sll	r16,r16,r2
  412e1c:	00802034 	movhi	r2,128
  412e20:	10bfffc4 	addi	r2,r2,-1
  412e24:	8809883a 	mov	r4,r17
  412e28:	80a0703a 	and	r16,r16,r2
  412e2c:	18803fcc 	andi	r2,r3,255
  412e30:	100695fa 	slli	r3,r2,23
  412e34:	20803fcc 	andi	r2,r4,255
  412e38:	100897fa 	slli	r4,r2,31
  412e3c:	00802034 	movhi	r2,128
  412e40:	10bfffc4 	addi	r2,r2,-1
  412e44:	8084703a 	and	r2,r16,r2
  412e48:	10c4b03a 	or	r2,r2,r3
  412e4c:	1104b03a 	or	r2,r2,r4
  412e50:	dfc00217 	ldw	ra,8(sp)
  412e54:	dc400117 	ldw	r17,4(sp)
  412e58:	dc000017 	ldw	r16,0(sp)
  412e5c:	dec00304 	addi	sp,sp,12
  412e60:	f800283a 	ret
  412e64:	01002644 	movi	r4,153
  412e68:	20c01c16 	blt	r4,r3,412edc <__floatsisf+0x110>
  412e6c:	01000144 	movi	r4,5
  412e70:	2080020e 	bge	r4,r2,412e7c <__floatsisf+0xb0>
  412e74:	113ffec4 	addi	r4,r2,-5
  412e78:	290a983a 	sll	r5,r5,r4
  412e7c:	043f0034 	movhi	r16,64512
  412e80:	843fffc4 	addi	r16,r16,-1
  412e84:	298001cc 	andi	r6,r5,7
  412e88:	2c20703a 	and	r16,r5,r16
  412e8c:	30000426 	beq	r6,zero,412ea0 <__floatsisf+0xd4>
  412e90:	294003cc 	andi	r5,r5,15
  412e94:	01000104 	movi	r4,4
  412e98:	29000126 	beq	r5,r4,412ea0 <__floatsisf+0xd4>
  412e9c:	8121883a 	add	r16,r16,r4
  412ea0:	8101002c 	andhi	r4,r16,1024
  412ea4:	20000526 	beq	r4,zero,412ebc <__floatsisf+0xf0>
  412ea8:	00c027c4 	movi	r3,159
  412eac:	1887c83a 	sub	r3,r3,r2
  412eb0:	00bf0034 	movhi	r2,64512
  412eb4:	10bfffc4 	addi	r2,r2,-1
  412eb8:	80a0703a 	and	r16,r16,r2
  412ebc:	802091ba 	slli	r16,r16,6
  412ec0:	8809883a 	mov	r4,r17
  412ec4:	8020d27a 	srli	r16,r16,9
  412ec8:	003fd806 	br	412e2c <_gp+0xffff315c>
  412ecc:	0009883a 	mov	r4,zero
  412ed0:	0007883a 	mov	r3,zero
  412ed4:	0021883a 	mov	r16,zero
  412ed8:	003fd406 	br	412e2c <_gp+0xffff315c>
  412edc:	01800144 	movi	r6,5
  412ee0:	110006c4 	addi	r4,r2,27
  412ee4:	8108983a 	sll	r4,r16,r4
  412ee8:	308fc83a 	sub	r7,r6,r2
  412eec:	81cad83a 	srl	r5,r16,r7
  412ef0:	2008c03a 	cmpne	r4,r4,zero
  412ef4:	214ab03a 	or	r5,r4,r5
  412ef8:	30bfe00e 	bge	r6,r2,412e7c <_gp+0xffff31ac>
  412efc:	003fdd06 	br	412e74 <_gp+0xffff31a4>

00412f00 <__clzsi2>:
  412f00:	00bfffd4 	movui	r2,65535
  412f04:	11000b36 	bltu	r2,r4,412f34 <__clzsi2+0x34>
  412f08:	00803fc4 	movi	r2,255
  412f0c:	1100122e 	bgeu	r2,r4,412f58 <__clzsi2+0x58>
  412f10:	00c00204 	movi	r3,8
  412f14:	01400604 	movi	r5,24
  412f18:	20c8d83a 	srl	r4,r4,r3
  412f1c:	00801074 	movhi	r2,65
  412f20:	109dca04 	addi	r2,r2,30504
  412f24:	1109883a 	add	r4,r2,r4
  412f28:	20800003 	ldbu	r2,0(r4)
  412f2c:	2885c83a 	sub	r2,r5,r2
  412f30:	f800283a 	ret
  412f34:	00804034 	movhi	r2,256
  412f38:	10bfffc4 	addi	r2,r2,-1
  412f3c:	11000336 	bltu	r2,r4,412f4c <__clzsi2+0x4c>
  412f40:	00c00404 	movi	r3,16
  412f44:	180b883a 	mov	r5,r3
  412f48:	003ff306 	br	412f18 <_gp+0xffff3248>
  412f4c:	00c00604 	movi	r3,24
  412f50:	01400204 	movi	r5,8
  412f54:	003ff006 	br	412f18 <_gp+0xffff3248>
  412f58:	0007883a 	mov	r3,zero
  412f5c:	01400804 	movi	r5,32
  412f60:	003fed06 	br	412f18 <_gp+0xffff3248>

00412f64 <_printf_r>:
  412f64:	defffd04 	addi	sp,sp,-12
  412f68:	dfc00015 	stw	ra,0(sp)
  412f6c:	d9800115 	stw	r6,4(sp)
  412f70:	d9c00215 	stw	r7,8(sp)
  412f74:	20c00217 	ldw	r3,8(r4)
  412f78:	280d883a 	mov	r6,r5
  412f7c:	01401074 	movhi	r5,65
  412f80:	294dc604 	addi	r5,r5,14104
  412f84:	19400115 	stw	r5,4(r3)
  412f88:	21400217 	ldw	r5,8(r4)
  412f8c:	d9c00104 	addi	r7,sp,4
  412f90:	04131080 	call	413108 <___vfprintf_internal_r>
  412f94:	dfc00017 	ldw	ra,0(sp)
  412f98:	dec00304 	addi	sp,sp,12
  412f9c:	f800283a 	ret

00412fa0 <printf>:
  412fa0:	defffc04 	addi	sp,sp,-16
  412fa4:	dfc00015 	stw	ra,0(sp)
  412fa8:	d9400115 	stw	r5,4(sp)
  412fac:	d9800215 	stw	r6,8(sp)
  412fb0:	d9c00315 	stw	r7,12(sp)
  412fb4:	00801074 	movhi	r2,65
  412fb8:	109f3504 	addi	r2,r2,31956
  412fbc:	10800017 	ldw	r2,0(r2)
  412fc0:	200b883a 	mov	r5,r4
  412fc4:	01001074 	movhi	r4,65
  412fc8:	10c00217 	ldw	r3,8(r2)
  412fcc:	210dc604 	addi	r4,r4,14104
  412fd0:	d9800104 	addi	r6,sp,4
  412fd4:	19000115 	stw	r4,4(r3)
  412fd8:	11000217 	ldw	r4,8(r2)
  412fdc:	04136740 	call	413674 <__vfprintf_internal>
  412fe0:	dfc00017 	ldw	ra,0(sp)
  412fe4:	dec00404 	addi	sp,sp,16
  412fe8:	f800283a 	ret

00412fec <_puts_r>:
  412fec:	defffd04 	addi	sp,sp,-12
  412ff0:	dc000015 	stw	r16,0(sp)
  412ff4:	2021883a 	mov	r16,r4
  412ff8:	2809883a 	mov	r4,r5
  412ffc:	dfc00215 	stw	ra,8(sp)
  413000:	dc400115 	stw	r17,4(sp)
  413004:	2823883a 	mov	r17,r5
  413008:	04130800 	call	413080 <strlen>
  41300c:	81400217 	ldw	r5,8(r16)
  413010:	00c01074 	movhi	r3,65
  413014:	18cdc604 	addi	r3,r3,14104
  413018:	28c00115 	stw	r3,4(r5)
  41301c:	8009883a 	mov	r4,r16
  413020:	880d883a 	mov	r6,r17
  413024:	100f883a 	mov	r7,r2
  413028:	04137180 	call	413718 <__sfvwrite_small_dev>
  41302c:	00ffffc4 	movi	r3,-1
  413030:	10c00926 	beq	r2,r3,413058 <_puts_r+0x6c>
  413034:	81400217 	ldw	r5,8(r16)
  413038:	01801074 	movhi	r6,65
  41303c:	8009883a 	mov	r4,r16
  413040:	28800117 	ldw	r2,4(r5)
  413044:	319e0a04 	addi	r6,r6,30760
  413048:	01c00044 	movi	r7,1
  41304c:	103ee83a 	callr	r2
  413050:	10bfffe0 	cmpeqi	r2,r2,-1
  413054:	0085c83a 	sub	r2,zero,r2
  413058:	dfc00217 	ldw	ra,8(sp)
  41305c:	dc400117 	ldw	r17,4(sp)
  413060:	dc000017 	ldw	r16,0(sp)
  413064:	dec00304 	addi	sp,sp,12
  413068:	f800283a 	ret

0041306c <puts>:
  41306c:	00801074 	movhi	r2,65
  413070:	109f3504 	addi	r2,r2,31956
  413074:	200b883a 	mov	r5,r4
  413078:	11000017 	ldw	r4,0(r2)
  41307c:	0412fec1 	jmpi	412fec <_puts_r>

00413080 <strlen>:
  413080:	2005883a 	mov	r2,r4
  413084:	10c00007 	ldb	r3,0(r2)
  413088:	18000226 	beq	r3,zero,413094 <strlen+0x14>
  41308c:	10800044 	addi	r2,r2,1
  413090:	003ffc06 	br	413084 <_gp+0xffff33b4>
  413094:	1105c83a 	sub	r2,r2,r4
  413098:	f800283a 	ret

0041309c <print_repeat>:
  41309c:	defffb04 	addi	sp,sp,-20
  4130a0:	dc800315 	stw	r18,12(sp)
  4130a4:	dc400215 	stw	r17,8(sp)
  4130a8:	dc000115 	stw	r16,4(sp)
  4130ac:	dfc00415 	stw	ra,16(sp)
  4130b0:	2025883a 	mov	r18,r4
  4130b4:	2823883a 	mov	r17,r5
  4130b8:	d9800005 	stb	r6,0(sp)
  4130bc:	3821883a 	mov	r16,r7
  4130c0:	04000a0e 	bge	zero,r16,4130ec <print_repeat+0x50>
  4130c4:	88800117 	ldw	r2,4(r17)
  4130c8:	9009883a 	mov	r4,r18
  4130cc:	880b883a 	mov	r5,r17
  4130d0:	d80d883a 	mov	r6,sp
  4130d4:	01c00044 	movi	r7,1
  4130d8:	103ee83a 	callr	r2
  4130dc:	843fffc4 	addi	r16,r16,-1
  4130e0:	103ff726 	beq	r2,zero,4130c0 <_gp+0xffff33f0>
  4130e4:	00bfffc4 	movi	r2,-1
  4130e8:	00000106 	br	4130f0 <print_repeat+0x54>
  4130ec:	0005883a 	mov	r2,zero
  4130f0:	dfc00417 	ldw	ra,16(sp)
  4130f4:	dc800317 	ldw	r18,12(sp)
  4130f8:	dc400217 	ldw	r17,8(sp)
  4130fc:	dc000117 	ldw	r16,4(sp)
  413100:	dec00504 	addi	sp,sp,20
  413104:	f800283a 	ret

00413108 <___vfprintf_internal_r>:
  413108:	deffe304 	addi	sp,sp,-116
  41310c:	d8c00804 	addi	r3,sp,32
  413110:	df001b15 	stw	fp,108(sp)
  413114:	ddc01a15 	stw	r23,104(sp)
  413118:	dd801915 	stw	r22,100(sp)
  41311c:	dd401815 	stw	r21,96(sp)
  413120:	dd001715 	stw	r20,92(sp)
  413124:	dcc01615 	stw	r19,88(sp)
  413128:	dc801515 	stw	r18,84(sp)
  41312c:	dc401415 	stw	r17,80(sp)
  413130:	dc001315 	stw	r16,76(sp)
  413134:	dfc01c15 	stw	ra,112(sp)
  413138:	2029883a 	mov	r20,r4
  41313c:	2823883a 	mov	r17,r5
  413140:	3839883a 	mov	fp,r7
  413144:	d9800f15 	stw	r6,60(sp)
  413148:	0021883a 	mov	r16,zero
  41314c:	d8000e15 	stw	zero,56(sp)
  413150:	002f883a 	mov	r23,zero
  413154:	002b883a 	mov	r21,zero
  413158:	0027883a 	mov	r19,zero
  41315c:	0025883a 	mov	r18,zero
  413160:	d8000c15 	stw	zero,48(sp)
  413164:	d8000b15 	stw	zero,44(sp)
  413168:	002d883a 	mov	r22,zero
  41316c:	d8c00915 	stw	r3,36(sp)
  413170:	d8c00f17 	ldw	r3,60(sp)
  413174:	19000003 	ldbu	r4,0(r3)
  413178:	20803fcc 	andi	r2,r4,255
  41317c:	1080201c 	xori	r2,r2,128
  413180:	10bfe004 	addi	r2,r2,-128
  413184:	10012e26 	beq	r2,zero,413640 <___vfprintf_internal_r+0x538>
  413188:	01400044 	movi	r5,1
  41318c:	b1401426 	beq	r22,r5,4131e0 <___vfprintf_internal_r+0xd8>
  413190:	2d800216 	blt	r5,r22,41319c <___vfprintf_internal_r+0x94>
  413194:	b0000626 	beq	r22,zero,4131b0 <___vfprintf_internal_r+0xa8>
  413198:	00012506 	br	413630 <___vfprintf_internal_r+0x528>
  41319c:	01400084 	movi	r5,2
  4131a0:	b1401d26 	beq	r22,r5,413218 <___vfprintf_internal_r+0x110>
  4131a4:	014000c4 	movi	r5,3
  4131a8:	b1402b26 	beq	r22,r5,413258 <___vfprintf_internal_r+0x150>
  4131ac:	00012006 	br	413630 <___vfprintf_internal_r+0x528>
  4131b0:	01400944 	movi	r5,37
  4131b4:	11410d26 	beq	r2,r5,4135ec <___vfprintf_internal_r+0x4e4>
  4131b8:	88800117 	ldw	r2,4(r17)
  4131bc:	d9000005 	stb	r4,0(sp)
  4131c0:	880b883a 	mov	r5,r17
  4131c4:	a009883a 	mov	r4,r20
  4131c8:	d80d883a 	mov	r6,sp
  4131cc:	01c00044 	movi	r7,1
  4131d0:	103ee83a 	callr	r2
  4131d4:	1000e81e 	bne	r2,zero,413578 <___vfprintf_internal_r+0x470>
  4131d8:	84000044 	addi	r16,r16,1
  4131dc:	00011406 	br	413630 <___vfprintf_internal_r+0x528>
  4131e0:	01400c04 	movi	r5,48
  4131e4:	11410a26 	beq	r2,r5,413610 <___vfprintf_internal_r+0x508>
  4131e8:	01400944 	movi	r5,37
  4131ec:	11400a1e 	bne	r2,r5,413218 <___vfprintf_internal_r+0x110>
  4131f0:	d8800005 	stb	r2,0(sp)
  4131f4:	88800117 	ldw	r2,4(r17)
  4131f8:	a009883a 	mov	r4,r20
  4131fc:	880b883a 	mov	r5,r17
  413200:	d80d883a 	mov	r6,sp
  413204:	b00f883a 	mov	r7,r22
  413208:	103ee83a 	callr	r2
  41320c:	1000da1e 	bne	r2,zero,413578 <___vfprintf_internal_r+0x470>
  413210:	84000044 	addi	r16,r16,1
  413214:	00010506 	br	41362c <___vfprintf_internal_r+0x524>
  413218:	25bff404 	addi	r22,r4,-48
  41321c:	b5803fcc 	andi	r22,r22,255
  413220:	00c00244 	movi	r3,9
  413224:	1d800936 	bltu	r3,r22,41324c <___vfprintf_internal_r+0x144>
  413228:	00bfffc4 	movi	r2,-1
  41322c:	90800426 	beq	r18,r2,413240 <___vfprintf_internal_r+0x138>
  413230:	9009883a 	mov	r4,r18
  413234:	01400284 	movi	r5,10
  413238:	0411f000 	call	411f00 <__mulsi3>
  41323c:	00000106 	br	413244 <___vfprintf_internal_r+0x13c>
  413240:	0005883a 	mov	r2,zero
  413244:	15a5883a 	add	r18,r2,r22
  413248:	0000f206 	br	413614 <___vfprintf_internal_r+0x50c>
  41324c:	01400b84 	movi	r5,46
  413250:	1140f426 	beq	r2,r5,413624 <___vfprintf_internal_r+0x51c>
  413254:	05800084 	movi	r22,2
  413258:	213ff404 	addi	r4,r4,-48
  41325c:	20c03fcc 	andi	r3,r4,255
  413260:	01000244 	movi	r4,9
  413264:	20c00b36 	bltu	r4,r3,413294 <___vfprintf_internal_r+0x18c>
  413268:	00bfffc4 	movi	r2,-1
  41326c:	98800626 	beq	r19,r2,413288 <___vfprintf_internal_r+0x180>
  413270:	9809883a 	mov	r4,r19
  413274:	01400284 	movi	r5,10
  413278:	d8c01115 	stw	r3,68(sp)
  41327c:	0411f000 	call	411f00 <__mulsi3>
  413280:	d8c01117 	ldw	r3,68(sp)
  413284:	00000106 	br	41328c <___vfprintf_internal_r+0x184>
  413288:	0005883a 	mov	r2,zero
  41328c:	10e7883a 	add	r19,r2,r3
  413290:	0000e706 	br	413630 <___vfprintf_internal_r+0x528>
  413294:	01401b04 	movi	r5,108
  413298:	1140e026 	beq	r2,r5,41361c <___vfprintf_internal_r+0x514>
  41329c:	013fffc4 	movi	r4,-1
  4132a0:	99000226 	beq	r19,r4,4132ac <___vfprintf_internal_r+0x1a4>
  4132a4:	d8000b15 	stw	zero,44(sp)
  4132a8:	00000106 	br	4132b0 <___vfprintf_internal_r+0x1a8>
  4132ac:	04c00044 	movi	r19,1
  4132b0:	01001a44 	movi	r4,105
  4132b4:	11001626 	beq	r2,r4,413310 <___vfprintf_internal_r+0x208>
  4132b8:	20800916 	blt	r4,r2,4132e0 <___vfprintf_internal_r+0x1d8>
  4132bc:	010018c4 	movi	r4,99
  4132c0:	11009626 	beq	r2,r4,41351c <___vfprintf_internal_r+0x414>
  4132c4:	01001904 	movi	r4,100
  4132c8:	11001126 	beq	r2,r4,413310 <___vfprintf_internal_r+0x208>
  4132cc:	01001604 	movi	r4,88
  4132d0:	1100d61e 	bne	r2,r4,41362c <___vfprintf_internal_r+0x524>
  4132d4:	00c00044 	movi	r3,1
  4132d8:	d8c00e15 	stw	r3,56(sp)
  4132dc:	00001406 	br	413330 <___vfprintf_internal_r+0x228>
  4132e0:	01001cc4 	movi	r4,115
  4132e4:	1100a626 	beq	r2,r4,413580 <___vfprintf_internal_r+0x478>
  4132e8:	20800416 	blt	r4,r2,4132fc <___vfprintf_internal_r+0x1f4>
  4132ec:	01001bc4 	movi	r4,111
  4132f0:	1100ce1e 	bne	r2,r4,41362c <___vfprintf_internal_r+0x524>
  4132f4:	05400204 	movi	r21,8
  4132f8:	00000e06 	br	413334 <___vfprintf_internal_r+0x22c>
  4132fc:	01001d44 	movi	r4,117
  413300:	11000c26 	beq	r2,r4,413334 <___vfprintf_internal_r+0x22c>
  413304:	01001e04 	movi	r4,120
  413308:	11000926 	beq	r2,r4,413330 <___vfprintf_internal_r+0x228>
  41330c:	0000c706 	br	41362c <___vfprintf_internal_r+0x524>
  413310:	e0800104 	addi	r2,fp,4
  413314:	b8000726 	beq	r23,zero,413334 <___vfprintf_internal_r+0x22c>
  413318:	d8800d15 	stw	r2,52(sp)
  41331c:	e7000017 	ldw	fp,0(fp)
  413320:	e000080e 	bge	fp,zero,413344 <___vfprintf_internal_r+0x23c>
  413324:	0739c83a 	sub	fp,zero,fp
  413328:	02000044 	movi	r8,1
  41332c:	00000606 	br	413348 <___vfprintf_internal_r+0x240>
  413330:	05400404 	movi	r21,16
  413334:	e0c00104 	addi	r3,fp,4
  413338:	d8c00d15 	stw	r3,52(sp)
  41333c:	e7000017 	ldw	fp,0(fp)
  413340:	002f883a 	mov	r23,zero
  413344:	0011883a 	mov	r8,zero
  413348:	002d883a 	mov	r22,zero
  41334c:	dd87883a 	add	r3,sp,r22
  413350:	e0001a26 	beq	fp,zero,4133bc <___vfprintf_internal_r+0x2b4>
  413354:	e009883a 	mov	r4,fp
  413358:	a80b883a 	mov	r5,r21
  41335c:	d8c01115 	stw	r3,68(sp)
  413360:	da001215 	stw	r8,72(sp)
  413364:	0411ef00 	call	411ef0 <__udivsi3>
  413368:	a809883a 	mov	r4,r21
  41336c:	100b883a 	mov	r5,r2
  413370:	d8801015 	stw	r2,64(sp)
  413374:	0411f000 	call	411f00 <__mulsi3>
  413378:	e085c83a 	sub	r2,fp,r2
  41337c:	01000244 	movi	r4,9
  413380:	d8c01117 	ldw	r3,68(sp)
  413384:	d9801017 	ldw	r6,64(sp)
  413388:	da001217 	ldw	r8,72(sp)
  41338c:	20800216 	blt	r4,r2,413398 <___vfprintf_internal_r+0x290>
  413390:	17000c04 	addi	fp,r2,48
  413394:	00000506 	br	4133ac <___vfprintf_internal_r+0x2a4>
  413398:	d9400e17 	ldw	r5,56(sp)
  41339c:	28000226 	beq	r5,zero,4133a8 <___vfprintf_internal_r+0x2a0>
  4133a0:	17000dc4 	addi	fp,r2,55
  4133a4:	00000106 	br	4133ac <___vfprintf_internal_r+0x2a4>
  4133a8:	170015c4 	addi	fp,r2,87
  4133ac:	1f000005 	stb	fp,0(r3)
  4133b0:	b5800044 	addi	r22,r22,1
  4133b4:	3039883a 	mov	fp,r6
  4133b8:	003fe406 	br	41334c <_gp+0xffff367c>
  4133bc:	1ec5c83a 	sub	r2,r3,sp
  4133c0:	d8800a15 	stw	r2,40(sp)
  4133c4:	9885c83a 	sub	r2,r19,r2
  4133c8:	1839883a 	mov	fp,r3
  4133cc:	00800e0e 	bge	zero,r2,413408 <___vfprintf_internal_r+0x300>
  4133d0:	182d883a 	mov	r22,r3
  4133d4:	1885883a 	add	r2,r3,r2
  4133d8:	01000c04 	movi	r4,48
  4133dc:	d9400917 	ldw	r5,36(sp)
  4133e0:	b007883a 	mov	r3,r22
  4133e4:	b140052e 	bgeu	r22,r5,4133fc <___vfprintf_internal_r+0x2f4>
  4133e8:	b5800044 	addi	r22,r22,1
  4133ec:	19000005 	stb	r4,0(r3)
  4133f0:	b039883a 	mov	fp,r22
  4133f4:	b0bff91e 	bne	r22,r2,4133dc <_gp+0xffff370c>
  4133f8:	00000106 	br	413400 <___vfprintf_internal_r+0x2f8>
  4133fc:	b039883a 	mov	fp,r22
  413400:	b6edc83a 	sub	r22,r22,sp
  413404:	dd800a15 	stw	r22,40(sp)
  413408:	d8800a17 	ldw	r2,40(sp)
  41340c:	1207883a 	add	r3,r2,r8
  413410:	90edc83a 	sub	r22,r18,r3
  413414:	d8c00b17 	ldw	r3,44(sp)
  413418:	18001726 	beq	r3,zero,413478 <___vfprintf_internal_r+0x370>
  41341c:	40000a26 	beq	r8,zero,413448 <___vfprintf_internal_r+0x340>
  413420:	00800b44 	movi	r2,45
  413424:	d8800805 	stb	r2,32(sp)
  413428:	88800117 	ldw	r2,4(r17)
  41342c:	a009883a 	mov	r4,r20
  413430:	880b883a 	mov	r5,r17
  413434:	d9800804 	addi	r6,sp,32
  413438:	01c00044 	movi	r7,1
  41343c:	103ee83a 	callr	r2
  413440:	10004d1e 	bne	r2,zero,413578 <___vfprintf_internal_r+0x470>
  413444:	84000044 	addi	r16,r16,1
  413448:	0580070e 	bge	zero,r22,413468 <___vfprintf_internal_r+0x360>
  41344c:	a009883a 	mov	r4,r20
  413450:	880b883a 	mov	r5,r17
  413454:	01800c04 	movi	r6,48
  413458:	b00f883a 	mov	r7,r22
  41345c:	041309c0 	call	41309c <print_repeat>
  413460:	1000451e 	bne	r2,zero,413578 <___vfprintf_internal_r+0x470>
  413464:	85a1883a 	add	r16,r16,r22
  413468:	d9000a17 	ldw	r4,40(sp)
  41346c:	e007883a 	mov	r3,fp
  413470:	272dc83a 	sub	r22,r4,fp
  413474:	00002206 	br	413500 <___vfprintf_internal_r+0x3f8>
  413478:	0580090e 	bge	zero,r22,4134a0 <___vfprintf_internal_r+0x398>
  41347c:	a009883a 	mov	r4,r20
  413480:	880b883a 	mov	r5,r17
  413484:	01800804 	movi	r6,32
  413488:	b00f883a 	mov	r7,r22
  41348c:	da001215 	stw	r8,72(sp)
  413490:	041309c0 	call	41309c <print_repeat>
  413494:	da001217 	ldw	r8,72(sp)
  413498:	1000371e 	bne	r2,zero,413578 <___vfprintf_internal_r+0x470>
  41349c:	85a1883a 	add	r16,r16,r22
  4134a0:	403ff126 	beq	r8,zero,413468 <_gp+0xffff3798>
  4134a4:	00800b44 	movi	r2,45
  4134a8:	d8800805 	stb	r2,32(sp)
  4134ac:	88800117 	ldw	r2,4(r17)
  4134b0:	a009883a 	mov	r4,r20
  4134b4:	880b883a 	mov	r5,r17
  4134b8:	d9800804 	addi	r6,sp,32
  4134bc:	01c00044 	movi	r7,1
  4134c0:	103ee83a 	callr	r2
  4134c4:	10002c1e 	bne	r2,zero,413578 <___vfprintf_internal_r+0x470>
  4134c8:	84000044 	addi	r16,r16,1
  4134cc:	003fe606 	br	413468 <_gp+0xffff3798>
  4134d0:	18ffffc4 	addi	r3,r3,-1
  4134d4:	18800003 	ldbu	r2,0(r3)
  4134d8:	a009883a 	mov	r4,r20
  4134dc:	d8c01115 	stw	r3,68(sp)
  4134e0:	d8800805 	stb	r2,32(sp)
  4134e4:	88800117 	ldw	r2,4(r17)
  4134e8:	880b883a 	mov	r5,r17
  4134ec:	d9800804 	addi	r6,sp,32
  4134f0:	01c00044 	movi	r7,1
  4134f4:	103ee83a 	callr	r2
  4134f8:	d8c01117 	ldw	r3,68(sp)
  4134fc:	10001e1e 	bne	r2,zero,413578 <___vfprintf_internal_r+0x470>
  413500:	80c5c83a 	sub	r2,r16,r3
  413504:	1d89883a 	add	r4,r3,r22
  413508:	e085883a 	add	r2,fp,r2
  41350c:	013ff016 	blt	zero,r4,4134d0 <_gp+0xffff3800>
  413510:	1021883a 	mov	r16,r2
  413514:	df000d17 	ldw	fp,52(sp)
  413518:	00004406 	br	41362c <___vfprintf_internal_r+0x524>
  41351c:	01000044 	movi	r4,1
  413520:	2480080e 	bge	r4,r18,413544 <___vfprintf_internal_r+0x43c>
  413524:	95bfffc4 	addi	r22,r18,-1
  413528:	a009883a 	mov	r4,r20
  41352c:	880b883a 	mov	r5,r17
  413530:	01800804 	movi	r6,32
  413534:	b00f883a 	mov	r7,r22
  413538:	041309c0 	call	41309c <print_repeat>
  41353c:	10000e1e 	bne	r2,zero,413578 <___vfprintf_internal_r+0x470>
  413540:	85a1883a 	add	r16,r16,r22
  413544:	e0800017 	ldw	r2,0(fp)
  413548:	a009883a 	mov	r4,r20
  41354c:	880b883a 	mov	r5,r17
  413550:	d8800005 	stb	r2,0(sp)
  413554:	88800117 	ldw	r2,4(r17)
  413558:	d80d883a 	mov	r6,sp
  41355c:	01c00044 	movi	r7,1
  413560:	e5800104 	addi	r22,fp,4
  413564:	103ee83a 	callr	r2
  413568:	1000031e 	bne	r2,zero,413578 <___vfprintf_internal_r+0x470>
  41356c:	84000044 	addi	r16,r16,1
  413570:	b039883a 	mov	fp,r22
  413574:	00002d06 	br	41362c <___vfprintf_internal_r+0x524>
  413578:	00bfffc4 	movi	r2,-1
  41357c:	00003106 	br	413644 <___vfprintf_internal_r+0x53c>
  413580:	e5800017 	ldw	r22,0(fp)
  413584:	e0c00104 	addi	r3,fp,4
  413588:	d8c00a15 	stw	r3,40(sp)
  41358c:	b009883a 	mov	r4,r22
  413590:	04130800 	call	413080 <strlen>
  413594:	9091c83a 	sub	r8,r18,r2
  413598:	1039883a 	mov	fp,r2
  41359c:	0200090e 	bge	zero,r8,4135c4 <___vfprintf_internal_r+0x4bc>
  4135a0:	400f883a 	mov	r7,r8
  4135a4:	a009883a 	mov	r4,r20
  4135a8:	880b883a 	mov	r5,r17
  4135ac:	01800804 	movi	r6,32
  4135b0:	da001215 	stw	r8,72(sp)
  4135b4:	041309c0 	call	41309c <print_repeat>
  4135b8:	da001217 	ldw	r8,72(sp)
  4135bc:	103fee1e 	bne	r2,zero,413578 <_gp+0xffff38a8>
  4135c0:	8221883a 	add	r16,r16,r8
  4135c4:	88800117 	ldw	r2,4(r17)
  4135c8:	a009883a 	mov	r4,r20
  4135cc:	880b883a 	mov	r5,r17
  4135d0:	b00d883a 	mov	r6,r22
  4135d4:	e00f883a 	mov	r7,fp
  4135d8:	103ee83a 	callr	r2
  4135dc:	103fe61e 	bne	r2,zero,413578 <_gp+0xffff38a8>
  4135e0:	8721883a 	add	r16,r16,fp
  4135e4:	df000a17 	ldw	fp,40(sp)
  4135e8:	00001006 	br	41362c <___vfprintf_internal_r+0x524>
  4135ec:	05c00044 	movi	r23,1
  4135f0:	04ffffc4 	movi	r19,-1
  4135f4:	d8000e15 	stw	zero,56(sp)
  4135f8:	05400284 	movi	r21,10
  4135fc:	9825883a 	mov	r18,r19
  413600:	d8000c15 	stw	zero,48(sp)
  413604:	d8000b15 	stw	zero,44(sp)
  413608:	b82d883a 	mov	r22,r23
  41360c:	00000806 	br	413630 <___vfprintf_internal_r+0x528>
  413610:	dd800b15 	stw	r22,44(sp)
  413614:	05800084 	movi	r22,2
  413618:	00000506 	br	413630 <___vfprintf_internal_r+0x528>
  41361c:	00c00044 	movi	r3,1
  413620:	d8c00c15 	stw	r3,48(sp)
  413624:	058000c4 	movi	r22,3
  413628:	00000106 	br	413630 <___vfprintf_internal_r+0x528>
  41362c:	002d883a 	mov	r22,zero
  413630:	d8c00f17 	ldw	r3,60(sp)
  413634:	18c00044 	addi	r3,r3,1
  413638:	d8c00f15 	stw	r3,60(sp)
  41363c:	003ecc06 	br	413170 <_gp+0xffff34a0>
  413640:	8005883a 	mov	r2,r16
  413644:	dfc01c17 	ldw	ra,112(sp)
  413648:	df001b17 	ldw	fp,108(sp)
  41364c:	ddc01a17 	ldw	r23,104(sp)
  413650:	dd801917 	ldw	r22,100(sp)
  413654:	dd401817 	ldw	r21,96(sp)
  413658:	dd001717 	ldw	r20,92(sp)
  41365c:	dcc01617 	ldw	r19,88(sp)
  413660:	dc801517 	ldw	r18,84(sp)
  413664:	dc401417 	ldw	r17,80(sp)
  413668:	dc001317 	ldw	r16,76(sp)
  41366c:	dec01d04 	addi	sp,sp,116
  413670:	f800283a 	ret

00413674 <__vfprintf_internal>:
  413674:	2007883a 	mov	r3,r4
  413678:	01001074 	movhi	r4,65
  41367c:	211f3504 	addi	r4,r4,31956
  413680:	21000017 	ldw	r4,0(r4)
  413684:	2805883a 	mov	r2,r5
  413688:	300f883a 	mov	r7,r6
  41368c:	180b883a 	mov	r5,r3
  413690:	100d883a 	mov	r6,r2
  413694:	04131081 	jmpi	413108 <___vfprintf_internal_r>

00413698 <_vsprintf_r>:
  413698:	defff804 	addi	sp,sp,-32
  41369c:	00808204 	movi	r2,520
  4136a0:	d880000d 	sth	r2,0(sp)
  4136a4:	00a00034 	movhi	r2,32768
  4136a8:	10bfffc4 	addi	r2,r2,-1
  4136ac:	d8800515 	stw	r2,20(sp)
  4136b0:	d8800315 	stw	r2,12(sp)
  4136b4:	00bfffc4 	movi	r2,-1
  4136b8:	d880008d 	sth	r2,2(sp)
  4136bc:	00801074 	movhi	r2,65
  4136c0:	d9400415 	stw	r5,16(sp)
  4136c4:	d9400215 	stw	r5,8(sp)
  4136c8:	108df104 	addi	r2,r2,14276
  4136cc:	d80b883a 	mov	r5,sp
  4136d0:	dfc00715 	stw	ra,28(sp)
  4136d4:	d8800115 	stw	r2,4(sp)
  4136d8:	d8000615 	stw	zero,24(sp)
  4136dc:	041392c0 	call	41392c <___svfprintf_internal_r>
  4136e0:	d8c00417 	ldw	r3,16(sp)
  4136e4:	18000005 	stb	zero,0(r3)
  4136e8:	dfc00717 	ldw	ra,28(sp)
  4136ec:	dec00804 	addi	sp,sp,32
  4136f0:	f800283a 	ret

004136f4 <vsprintf>:
  4136f4:	2007883a 	mov	r3,r4
  4136f8:	01001074 	movhi	r4,65
  4136fc:	211f3504 	addi	r4,r4,31956
  413700:	21000017 	ldw	r4,0(r4)
  413704:	2805883a 	mov	r2,r5
  413708:	300f883a 	mov	r7,r6
  41370c:	180b883a 	mov	r5,r3
  413710:	100d883a 	mov	r6,r2
  413714:	04136981 	jmpi	413698 <_vsprintf_r>

00413718 <__sfvwrite_small_dev>:
  413718:	2880000b 	ldhu	r2,0(r5)
  41371c:	defffa04 	addi	sp,sp,-24
  413720:	dc000015 	stw	r16,0(sp)
  413724:	dfc00515 	stw	ra,20(sp)
  413728:	dd000415 	stw	r20,16(sp)
  41372c:	dcc00315 	stw	r19,12(sp)
  413730:	dc800215 	stw	r18,8(sp)
  413734:	dc400115 	stw	r17,4(sp)
  413738:	1080020c 	andi	r2,r2,8
  41373c:	2821883a 	mov	r16,r5
  413740:	10001726 	beq	r2,zero,4137a0 <__sfvwrite_small_dev+0x88>
  413744:	2880008f 	ldh	r2,2(r5)
  413748:	10001216 	blt	r2,zero,413794 <__sfvwrite_small_dev+0x7c>
  41374c:	2027883a 	mov	r19,r4
  413750:	3025883a 	mov	r18,r6
  413754:	3823883a 	mov	r17,r7
  413758:	05010004 	movi	r20,1024
  41375c:	04400b0e 	bge	zero,r17,41378c <__sfvwrite_small_dev+0x74>
  413760:	8140008f 	ldh	r5,2(r16)
  413764:	880f883a 	mov	r7,r17
  413768:	a440010e 	bge	r20,r17,413770 <__sfvwrite_small_dev+0x58>
  41376c:	01c10004 	movi	r7,1024
  413770:	9809883a 	mov	r4,r19
  413774:	900d883a 	mov	r6,r18
  413778:	0413ebc0 	call	413ebc <_write_r>
  41377c:	0080050e 	bge	zero,r2,413794 <__sfvwrite_small_dev+0x7c>
  413780:	88a3c83a 	sub	r17,r17,r2
  413784:	90a5883a 	add	r18,r18,r2
  413788:	003ff406 	br	41375c <_gp+0xffff3a8c>
  41378c:	0005883a 	mov	r2,zero
  413790:	00000406 	br	4137a4 <__sfvwrite_small_dev+0x8c>
  413794:	8080000b 	ldhu	r2,0(r16)
  413798:	10801014 	ori	r2,r2,64
  41379c:	8080000d 	sth	r2,0(r16)
  4137a0:	00bfffc4 	movi	r2,-1
  4137a4:	dfc00517 	ldw	ra,20(sp)
  4137a8:	dd000417 	ldw	r20,16(sp)
  4137ac:	dcc00317 	ldw	r19,12(sp)
  4137b0:	dc800217 	ldw	r18,8(sp)
  4137b4:	dc400117 	ldw	r17,4(sp)
  4137b8:	dc000017 	ldw	r16,0(sp)
  4137bc:	dec00604 	addi	sp,sp,24
  4137c0:	f800283a 	ret

004137c4 <__sfvwrite_small_str>:
  4137c4:	2880000b 	ldhu	r2,0(r5)
  4137c8:	defffd04 	addi	sp,sp,-12
  4137cc:	dc000015 	stw	r16,0(sp)
  4137d0:	dfc00215 	stw	ra,8(sp)
  4137d4:	dc400115 	stw	r17,4(sp)
  4137d8:	10c0020c 	andi	r3,r2,8
  4137dc:	2821883a 	mov	r16,r5
  4137e0:	18001926 	beq	r3,zero,413848 <__sfvwrite_small_str+0x84>
  4137e4:	28c0008f 	ldh	r3,2(r5)
  4137e8:	1800150e 	bge	r3,zero,413840 <__sfvwrite_small_str+0x7c>
  4137ec:	10c0800c 	andi	r3,r2,512
  4137f0:	18001326 	beq	r3,zero,413840 <__sfvwrite_small_str+0x7c>
  4137f4:	2c400517 	ldw	r17,20(r5)
  4137f8:	89c0030e 	bge	r17,r7,413808 <__sfvwrite_small_str+0x44>
  4137fc:	10c0200c 	andi	r3,r2,128
  413800:	18000326 	beq	r3,zero,413810 <__sfvwrite_small_str+0x4c>
  413804:	00000e06 	br	413840 <__sfvwrite_small_str+0x7c>
  413808:	3c40010e 	bge	r7,r17,413810 <__sfvwrite_small_str+0x4c>
  41380c:	3823883a 	mov	r17,r7
  413810:	81000417 	ldw	r4,16(r16)
  413814:	300b883a 	mov	r5,r6
  413818:	880d883a 	mov	r6,r17
  41381c:	04138600 	call	413860 <memmove>
  413820:	80800517 	ldw	r2,20(r16)
  413824:	1445c83a 	sub	r2,r2,r17
  413828:	80800515 	stw	r2,20(r16)
  41382c:	80800417 	ldw	r2,16(r16)
  413830:	1463883a 	add	r17,r2,r17
  413834:	84400415 	stw	r17,16(r16)
  413838:	0005883a 	mov	r2,zero
  41383c:	00000306 	br	41384c <__sfvwrite_small_str+0x88>
  413840:	10801014 	ori	r2,r2,64
  413844:	8080000d 	sth	r2,0(r16)
  413848:	00bfffc4 	movi	r2,-1
  41384c:	dfc00217 	ldw	ra,8(sp)
  413850:	dc400117 	ldw	r17,4(sp)
  413854:	dc000017 	ldw	r16,0(sp)
  413858:	dec00304 	addi	sp,sp,12
  41385c:	f800283a 	ret

00413860 <memmove>:
  413860:	2005883a 	mov	r2,r4
  413864:	29000d2e 	bgeu	r5,r4,41389c <memmove+0x3c>
  413868:	298f883a 	add	r7,r5,r6
  41386c:	21c00b2e 	bgeu	r4,r7,41389c <memmove+0x3c>
  413870:	3007883a 	mov	r3,r6
  413874:	017fffc4 	movi	r5,-1
  413878:	18ffffc4 	addi	r3,r3,-1
  41387c:	19400626 	beq	r3,r5,413898 <memmove+0x38>
  413880:	1989c83a 	sub	r4,r3,r6
  413884:	3909883a 	add	r4,r7,r4
  413888:	22000003 	ldbu	r8,0(r4)
  41388c:	10c9883a 	add	r4,r2,r3
  413890:	22000005 	stb	r8,0(r4)
  413894:	003ff806 	br	413878 <_gp+0xffff3ba8>
  413898:	f800283a 	ret
  41389c:	0007883a 	mov	r3,zero
  4138a0:	19800626 	beq	r3,r6,4138bc <memmove+0x5c>
  4138a4:	28c9883a 	add	r4,r5,r3
  4138a8:	21c00003 	ldbu	r7,0(r4)
  4138ac:	10c9883a 	add	r4,r2,r3
  4138b0:	18c00044 	addi	r3,r3,1
  4138b4:	21c00005 	stb	r7,0(r4)
  4138b8:	003ff906 	br	4138a0 <_gp+0xffff3bd0>
  4138bc:	f800283a 	ret

004138c0 <print_repeat>:
  4138c0:	defffb04 	addi	sp,sp,-20
  4138c4:	dc800315 	stw	r18,12(sp)
  4138c8:	dc400215 	stw	r17,8(sp)
  4138cc:	dc000115 	stw	r16,4(sp)
  4138d0:	dfc00415 	stw	ra,16(sp)
  4138d4:	2025883a 	mov	r18,r4
  4138d8:	2823883a 	mov	r17,r5
  4138dc:	d9800005 	stb	r6,0(sp)
  4138e0:	3821883a 	mov	r16,r7
  4138e4:	04000a0e 	bge	zero,r16,413910 <print_repeat+0x50>
  4138e8:	88800117 	ldw	r2,4(r17)
  4138ec:	9009883a 	mov	r4,r18
  4138f0:	880b883a 	mov	r5,r17
  4138f4:	d80d883a 	mov	r6,sp
  4138f8:	01c00044 	movi	r7,1
  4138fc:	103ee83a 	callr	r2
  413900:	843fffc4 	addi	r16,r16,-1
  413904:	103ff726 	beq	r2,zero,4138e4 <_gp+0xffff3c14>
  413908:	00bfffc4 	movi	r2,-1
  41390c:	00000106 	br	413914 <print_repeat+0x54>
  413910:	0005883a 	mov	r2,zero
  413914:	dfc00417 	ldw	ra,16(sp)
  413918:	dc800317 	ldw	r18,12(sp)
  41391c:	dc400217 	ldw	r17,8(sp)
  413920:	dc000117 	ldw	r16,4(sp)
  413924:	dec00504 	addi	sp,sp,20
  413928:	f800283a 	ret

0041392c <___svfprintf_internal_r>:
  41392c:	deffe304 	addi	sp,sp,-116
  413930:	d8c00804 	addi	r3,sp,32
  413934:	df001b15 	stw	fp,108(sp)
  413938:	ddc01a15 	stw	r23,104(sp)
  41393c:	dd801915 	stw	r22,100(sp)
  413940:	dd401815 	stw	r21,96(sp)
  413944:	dd001715 	stw	r20,92(sp)
  413948:	dcc01615 	stw	r19,88(sp)
  41394c:	dc801515 	stw	r18,84(sp)
  413950:	dc401415 	stw	r17,80(sp)
  413954:	dc001315 	stw	r16,76(sp)
  413958:	dfc01c15 	stw	ra,112(sp)
  41395c:	2029883a 	mov	r20,r4
  413960:	2823883a 	mov	r17,r5
  413964:	3839883a 	mov	fp,r7
  413968:	d9800f15 	stw	r6,60(sp)
  41396c:	0021883a 	mov	r16,zero
  413970:	d8000e15 	stw	zero,56(sp)
  413974:	002f883a 	mov	r23,zero
  413978:	002b883a 	mov	r21,zero
  41397c:	0027883a 	mov	r19,zero
  413980:	0025883a 	mov	r18,zero
  413984:	d8000c15 	stw	zero,48(sp)
  413988:	d8000b15 	stw	zero,44(sp)
  41398c:	002d883a 	mov	r22,zero
  413990:	d8c00915 	stw	r3,36(sp)
  413994:	d8c00f17 	ldw	r3,60(sp)
  413998:	19000003 	ldbu	r4,0(r3)
  41399c:	20803fcc 	andi	r2,r4,255
  4139a0:	1080201c 	xori	r2,r2,128
  4139a4:	10bfe004 	addi	r2,r2,-128
  4139a8:	10012e26 	beq	r2,zero,413e64 <___svfprintf_internal_r+0x538>
  4139ac:	01400044 	movi	r5,1
  4139b0:	b1401426 	beq	r22,r5,413a04 <___svfprintf_internal_r+0xd8>
  4139b4:	2d800216 	blt	r5,r22,4139c0 <___svfprintf_internal_r+0x94>
  4139b8:	b0000626 	beq	r22,zero,4139d4 <___svfprintf_internal_r+0xa8>
  4139bc:	00012506 	br	413e54 <___svfprintf_internal_r+0x528>
  4139c0:	01400084 	movi	r5,2
  4139c4:	b1401d26 	beq	r22,r5,413a3c <___svfprintf_internal_r+0x110>
  4139c8:	014000c4 	movi	r5,3
  4139cc:	b1402b26 	beq	r22,r5,413a7c <___svfprintf_internal_r+0x150>
  4139d0:	00012006 	br	413e54 <___svfprintf_internal_r+0x528>
  4139d4:	01400944 	movi	r5,37
  4139d8:	11410d26 	beq	r2,r5,413e10 <___svfprintf_internal_r+0x4e4>
  4139dc:	88800117 	ldw	r2,4(r17)
  4139e0:	d9000005 	stb	r4,0(sp)
  4139e4:	880b883a 	mov	r5,r17
  4139e8:	a009883a 	mov	r4,r20
  4139ec:	d80d883a 	mov	r6,sp
  4139f0:	01c00044 	movi	r7,1
  4139f4:	103ee83a 	callr	r2
  4139f8:	1000e81e 	bne	r2,zero,413d9c <___svfprintf_internal_r+0x470>
  4139fc:	84000044 	addi	r16,r16,1
  413a00:	00011406 	br	413e54 <___svfprintf_internal_r+0x528>
  413a04:	01400c04 	movi	r5,48
  413a08:	11410a26 	beq	r2,r5,413e34 <___svfprintf_internal_r+0x508>
  413a0c:	01400944 	movi	r5,37
  413a10:	11400a1e 	bne	r2,r5,413a3c <___svfprintf_internal_r+0x110>
  413a14:	d8800005 	stb	r2,0(sp)
  413a18:	88800117 	ldw	r2,4(r17)
  413a1c:	a009883a 	mov	r4,r20
  413a20:	880b883a 	mov	r5,r17
  413a24:	d80d883a 	mov	r6,sp
  413a28:	b00f883a 	mov	r7,r22
  413a2c:	103ee83a 	callr	r2
  413a30:	1000da1e 	bne	r2,zero,413d9c <___svfprintf_internal_r+0x470>
  413a34:	84000044 	addi	r16,r16,1
  413a38:	00010506 	br	413e50 <___svfprintf_internal_r+0x524>
  413a3c:	25bff404 	addi	r22,r4,-48
  413a40:	b5803fcc 	andi	r22,r22,255
  413a44:	00c00244 	movi	r3,9
  413a48:	1d800936 	bltu	r3,r22,413a70 <___svfprintf_internal_r+0x144>
  413a4c:	00bfffc4 	movi	r2,-1
  413a50:	90800426 	beq	r18,r2,413a64 <___svfprintf_internal_r+0x138>
  413a54:	9009883a 	mov	r4,r18
  413a58:	01400284 	movi	r5,10
  413a5c:	0411f000 	call	411f00 <__mulsi3>
  413a60:	00000106 	br	413a68 <___svfprintf_internal_r+0x13c>
  413a64:	0005883a 	mov	r2,zero
  413a68:	15a5883a 	add	r18,r2,r22
  413a6c:	0000f206 	br	413e38 <___svfprintf_internal_r+0x50c>
  413a70:	01400b84 	movi	r5,46
  413a74:	1140f426 	beq	r2,r5,413e48 <___svfprintf_internal_r+0x51c>
  413a78:	05800084 	movi	r22,2
  413a7c:	213ff404 	addi	r4,r4,-48
  413a80:	20c03fcc 	andi	r3,r4,255
  413a84:	01000244 	movi	r4,9
  413a88:	20c00b36 	bltu	r4,r3,413ab8 <___svfprintf_internal_r+0x18c>
  413a8c:	00bfffc4 	movi	r2,-1
  413a90:	98800626 	beq	r19,r2,413aac <___svfprintf_internal_r+0x180>
  413a94:	9809883a 	mov	r4,r19
  413a98:	01400284 	movi	r5,10
  413a9c:	d8c01115 	stw	r3,68(sp)
  413aa0:	0411f000 	call	411f00 <__mulsi3>
  413aa4:	d8c01117 	ldw	r3,68(sp)
  413aa8:	00000106 	br	413ab0 <___svfprintf_internal_r+0x184>
  413aac:	0005883a 	mov	r2,zero
  413ab0:	10e7883a 	add	r19,r2,r3
  413ab4:	0000e706 	br	413e54 <___svfprintf_internal_r+0x528>
  413ab8:	01401b04 	movi	r5,108
  413abc:	1140e026 	beq	r2,r5,413e40 <___svfprintf_internal_r+0x514>
  413ac0:	013fffc4 	movi	r4,-1
  413ac4:	99000226 	beq	r19,r4,413ad0 <___svfprintf_internal_r+0x1a4>
  413ac8:	d8000b15 	stw	zero,44(sp)
  413acc:	00000106 	br	413ad4 <___svfprintf_internal_r+0x1a8>
  413ad0:	04c00044 	movi	r19,1
  413ad4:	01001a44 	movi	r4,105
  413ad8:	11001626 	beq	r2,r4,413b34 <___svfprintf_internal_r+0x208>
  413adc:	20800916 	blt	r4,r2,413b04 <___svfprintf_internal_r+0x1d8>
  413ae0:	010018c4 	movi	r4,99
  413ae4:	11009626 	beq	r2,r4,413d40 <___svfprintf_internal_r+0x414>
  413ae8:	01001904 	movi	r4,100
  413aec:	11001126 	beq	r2,r4,413b34 <___svfprintf_internal_r+0x208>
  413af0:	01001604 	movi	r4,88
  413af4:	1100d61e 	bne	r2,r4,413e50 <___svfprintf_internal_r+0x524>
  413af8:	00c00044 	movi	r3,1
  413afc:	d8c00e15 	stw	r3,56(sp)
  413b00:	00001406 	br	413b54 <___svfprintf_internal_r+0x228>
  413b04:	01001cc4 	movi	r4,115
  413b08:	1100a626 	beq	r2,r4,413da4 <___svfprintf_internal_r+0x478>
  413b0c:	20800416 	blt	r4,r2,413b20 <___svfprintf_internal_r+0x1f4>
  413b10:	01001bc4 	movi	r4,111
  413b14:	1100ce1e 	bne	r2,r4,413e50 <___svfprintf_internal_r+0x524>
  413b18:	05400204 	movi	r21,8
  413b1c:	00000e06 	br	413b58 <___svfprintf_internal_r+0x22c>
  413b20:	01001d44 	movi	r4,117
  413b24:	11000c26 	beq	r2,r4,413b58 <___svfprintf_internal_r+0x22c>
  413b28:	01001e04 	movi	r4,120
  413b2c:	11000926 	beq	r2,r4,413b54 <___svfprintf_internal_r+0x228>
  413b30:	0000c706 	br	413e50 <___svfprintf_internal_r+0x524>
  413b34:	e0800104 	addi	r2,fp,4
  413b38:	b8000726 	beq	r23,zero,413b58 <___svfprintf_internal_r+0x22c>
  413b3c:	d8800d15 	stw	r2,52(sp)
  413b40:	e7000017 	ldw	fp,0(fp)
  413b44:	e000080e 	bge	fp,zero,413b68 <___svfprintf_internal_r+0x23c>
  413b48:	0739c83a 	sub	fp,zero,fp
  413b4c:	02000044 	movi	r8,1
  413b50:	00000606 	br	413b6c <___svfprintf_internal_r+0x240>
  413b54:	05400404 	movi	r21,16
  413b58:	e0c00104 	addi	r3,fp,4
  413b5c:	d8c00d15 	stw	r3,52(sp)
  413b60:	e7000017 	ldw	fp,0(fp)
  413b64:	002f883a 	mov	r23,zero
  413b68:	0011883a 	mov	r8,zero
  413b6c:	002d883a 	mov	r22,zero
  413b70:	dd87883a 	add	r3,sp,r22
  413b74:	e0001a26 	beq	fp,zero,413be0 <___svfprintf_internal_r+0x2b4>
  413b78:	e009883a 	mov	r4,fp
  413b7c:	a80b883a 	mov	r5,r21
  413b80:	d8c01115 	stw	r3,68(sp)
  413b84:	da001215 	stw	r8,72(sp)
  413b88:	0411ef00 	call	411ef0 <__udivsi3>
  413b8c:	a809883a 	mov	r4,r21
  413b90:	100b883a 	mov	r5,r2
  413b94:	d8801015 	stw	r2,64(sp)
  413b98:	0411f000 	call	411f00 <__mulsi3>
  413b9c:	e085c83a 	sub	r2,fp,r2
  413ba0:	01000244 	movi	r4,9
  413ba4:	d8c01117 	ldw	r3,68(sp)
  413ba8:	d9801017 	ldw	r6,64(sp)
  413bac:	da001217 	ldw	r8,72(sp)
  413bb0:	20800216 	blt	r4,r2,413bbc <___svfprintf_internal_r+0x290>
  413bb4:	17000c04 	addi	fp,r2,48
  413bb8:	00000506 	br	413bd0 <___svfprintf_internal_r+0x2a4>
  413bbc:	d9400e17 	ldw	r5,56(sp)
  413bc0:	28000226 	beq	r5,zero,413bcc <___svfprintf_internal_r+0x2a0>
  413bc4:	17000dc4 	addi	fp,r2,55
  413bc8:	00000106 	br	413bd0 <___svfprintf_internal_r+0x2a4>
  413bcc:	170015c4 	addi	fp,r2,87
  413bd0:	1f000005 	stb	fp,0(r3)
  413bd4:	b5800044 	addi	r22,r22,1
  413bd8:	3039883a 	mov	fp,r6
  413bdc:	003fe406 	br	413b70 <_gp+0xffff3ea0>
  413be0:	1ec5c83a 	sub	r2,r3,sp
  413be4:	d8800a15 	stw	r2,40(sp)
  413be8:	9885c83a 	sub	r2,r19,r2
  413bec:	1839883a 	mov	fp,r3
  413bf0:	00800e0e 	bge	zero,r2,413c2c <___svfprintf_internal_r+0x300>
  413bf4:	182d883a 	mov	r22,r3
  413bf8:	1885883a 	add	r2,r3,r2
  413bfc:	01000c04 	movi	r4,48
  413c00:	d9400917 	ldw	r5,36(sp)
  413c04:	b007883a 	mov	r3,r22
  413c08:	b140052e 	bgeu	r22,r5,413c20 <___svfprintf_internal_r+0x2f4>
  413c0c:	b5800044 	addi	r22,r22,1
  413c10:	19000005 	stb	r4,0(r3)
  413c14:	b039883a 	mov	fp,r22
  413c18:	b0bff91e 	bne	r22,r2,413c00 <_gp+0xffff3f30>
  413c1c:	00000106 	br	413c24 <___svfprintf_internal_r+0x2f8>
  413c20:	b039883a 	mov	fp,r22
  413c24:	b6edc83a 	sub	r22,r22,sp
  413c28:	dd800a15 	stw	r22,40(sp)
  413c2c:	d8800a17 	ldw	r2,40(sp)
  413c30:	1207883a 	add	r3,r2,r8
  413c34:	90edc83a 	sub	r22,r18,r3
  413c38:	d8c00b17 	ldw	r3,44(sp)
  413c3c:	18001726 	beq	r3,zero,413c9c <___svfprintf_internal_r+0x370>
  413c40:	40000a26 	beq	r8,zero,413c6c <___svfprintf_internal_r+0x340>
  413c44:	00800b44 	movi	r2,45
  413c48:	d8800805 	stb	r2,32(sp)
  413c4c:	88800117 	ldw	r2,4(r17)
  413c50:	a009883a 	mov	r4,r20
  413c54:	880b883a 	mov	r5,r17
  413c58:	d9800804 	addi	r6,sp,32
  413c5c:	01c00044 	movi	r7,1
  413c60:	103ee83a 	callr	r2
  413c64:	10004d1e 	bne	r2,zero,413d9c <___svfprintf_internal_r+0x470>
  413c68:	84000044 	addi	r16,r16,1
  413c6c:	0580070e 	bge	zero,r22,413c8c <___svfprintf_internal_r+0x360>
  413c70:	a009883a 	mov	r4,r20
  413c74:	880b883a 	mov	r5,r17
  413c78:	01800c04 	movi	r6,48
  413c7c:	b00f883a 	mov	r7,r22
  413c80:	04138c00 	call	4138c0 <print_repeat>
  413c84:	1000451e 	bne	r2,zero,413d9c <___svfprintf_internal_r+0x470>
  413c88:	85a1883a 	add	r16,r16,r22
  413c8c:	d9000a17 	ldw	r4,40(sp)
  413c90:	e007883a 	mov	r3,fp
  413c94:	272dc83a 	sub	r22,r4,fp
  413c98:	00002206 	br	413d24 <___svfprintf_internal_r+0x3f8>
  413c9c:	0580090e 	bge	zero,r22,413cc4 <___svfprintf_internal_r+0x398>
  413ca0:	a009883a 	mov	r4,r20
  413ca4:	880b883a 	mov	r5,r17
  413ca8:	01800804 	movi	r6,32
  413cac:	b00f883a 	mov	r7,r22
  413cb0:	da001215 	stw	r8,72(sp)
  413cb4:	04138c00 	call	4138c0 <print_repeat>
  413cb8:	da001217 	ldw	r8,72(sp)
  413cbc:	1000371e 	bne	r2,zero,413d9c <___svfprintf_internal_r+0x470>
  413cc0:	85a1883a 	add	r16,r16,r22
  413cc4:	403ff126 	beq	r8,zero,413c8c <_gp+0xffff3fbc>
  413cc8:	00800b44 	movi	r2,45
  413ccc:	d8800805 	stb	r2,32(sp)
  413cd0:	88800117 	ldw	r2,4(r17)
  413cd4:	a009883a 	mov	r4,r20
  413cd8:	880b883a 	mov	r5,r17
  413cdc:	d9800804 	addi	r6,sp,32
  413ce0:	01c00044 	movi	r7,1
  413ce4:	103ee83a 	callr	r2
  413ce8:	10002c1e 	bne	r2,zero,413d9c <___svfprintf_internal_r+0x470>
  413cec:	84000044 	addi	r16,r16,1
  413cf0:	003fe606 	br	413c8c <_gp+0xffff3fbc>
  413cf4:	18ffffc4 	addi	r3,r3,-1
  413cf8:	18800003 	ldbu	r2,0(r3)
  413cfc:	a009883a 	mov	r4,r20
  413d00:	d8c01115 	stw	r3,68(sp)
  413d04:	d8800805 	stb	r2,32(sp)
  413d08:	88800117 	ldw	r2,4(r17)
  413d0c:	880b883a 	mov	r5,r17
  413d10:	d9800804 	addi	r6,sp,32
  413d14:	01c00044 	movi	r7,1
  413d18:	103ee83a 	callr	r2
  413d1c:	d8c01117 	ldw	r3,68(sp)
  413d20:	10001e1e 	bne	r2,zero,413d9c <___svfprintf_internal_r+0x470>
  413d24:	80c5c83a 	sub	r2,r16,r3
  413d28:	1d89883a 	add	r4,r3,r22
  413d2c:	e085883a 	add	r2,fp,r2
  413d30:	013ff016 	blt	zero,r4,413cf4 <_gp+0xffff4024>
  413d34:	1021883a 	mov	r16,r2
  413d38:	df000d17 	ldw	fp,52(sp)
  413d3c:	00004406 	br	413e50 <___svfprintf_internal_r+0x524>
  413d40:	01000044 	movi	r4,1
  413d44:	2480080e 	bge	r4,r18,413d68 <___svfprintf_internal_r+0x43c>
  413d48:	95bfffc4 	addi	r22,r18,-1
  413d4c:	a009883a 	mov	r4,r20
  413d50:	880b883a 	mov	r5,r17
  413d54:	01800804 	movi	r6,32
  413d58:	b00f883a 	mov	r7,r22
  413d5c:	04138c00 	call	4138c0 <print_repeat>
  413d60:	10000e1e 	bne	r2,zero,413d9c <___svfprintf_internal_r+0x470>
  413d64:	85a1883a 	add	r16,r16,r22
  413d68:	e0800017 	ldw	r2,0(fp)
  413d6c:	a009883a 	mov	r4,r20
  413d70:	880b883a 	mov	r5,r17
  413d74:	d8800005 	stb	r2,0(sp)
  413d78:	88800117 	ldw	r2,4(r17)
  413d7c:	d80d883a 	mov	r6,sp
  413d80:	01c00044 	movi	r7,1
  413d84:	e5800104 	addi	r22,fp,4
  413d88:	103ee83a 	callr	r2
  413d8c:	1000031e 	bne	r2,zero,413d9c <___svfprintf_internal_r+0x470>
  413d90:	84000044 	addi	r16,r16,1
  413d94:	b039883a 	mov	fp,r22
  413d98:	00002d06 	br	413e50 <___svfprintf_internal_r+0x524>
  413d9c:	00bfffc4 	movi	r2,-1
  413da0:	00003106 	br	413e68 <___svfprintf_internal_r+0x53c>
  413da4:	e5800017 	ldw	r22,0(fp)
  413da8:	e0c00104 	addi	r3,fp,4
  413dac:	d8c00a15 	stw	r3,40(sp)
  413db0:	b009883a 	mov	r4,r22
  413db4:	04130800 	call	413080 <strlen>
  413db8:	9091c83a 	sub	r8,r18,r2
  413dbc:	1039883a 	mov	fp,r2
  413dc0:	0200090e 	bge	zero,r8,413de8 <___svfprintf_internal_r+0x4bc>
  413dc4:	400f883a 	mov	r7,r8
  413dc8:	a009883a 	mov	r4,r20
  413dcc:	880b883a 	mov	r5,r17
  413dd0:	01800804 	movi	r6,32
  413dd4:	da001215 	stw	r8,72(sp)
  413dd8:	04138c00 	call	4138c0 <print_repeat>
  413ddc:	da001217 	ldw	r8,72(sp)
  413de0:	103fee1e 	bne	r2,zero,413d9c <_gp+0xffff40cc>
  413de4:	8221883a 	add	r16,r16,r8
  413de8:	88800117 	ldw	r2,4(r17)
  413dec:	a009883a 	mov	r4,r20
  413df0:	880b883a 	mov	r5,r17
  413df4:	b00d883a 	mov	r6,r22
  413df8:	e00f883a 	mov	r7,fp
  413dfc:	103ee83a 	callr	r2
  413e00:	103fe61e 	bne	r2,zero,413d9c <_gp+0xffff40cc>
  413e04:	8721883a 	add	r16,r16,fp
  413e08:	df000a17 	ldw	fp,40(sp)
  413e0c:	00001006 	br	413e50 <___svfprintf_internal_r+0x524>
  413e10:	05c00044 	movi	r23,1
  413e14:	04ffffc4 	movi	r19,-1
  413e18:	d8000e15 	stw	zero,56(sp)
  413e1c:	05400284 	movi	r21,10
  413e20:	9825883a 	mov	r18,r19
  413e24:	d8000c15 	stw	zero,48(sp)
  413e28:	d8000b15 	stw	zero,44(sp)
  413e2c:	b82d883a 	mov	r22,r23
  413e30:	00000806 	br	413e54 <___svfprintf_internal_r+0x528>
  413e34:	dd800b15 	stw	r22,44(sp)
  413e38:	05800084 	movi	r22,2
  413e3c:	00000506 	br	413e54 <___svfprintf_internal_r+0x528>
  413e40:	00c00044 	movi	r3,1
  413e44:	d8c00c15 	stw	r3,48(sp)
  413e48:	058000c4 	movi	r22,3
  413e4c:	00000106 	br	413e54 <___svfprintf_internal_r+0x528>
  413e50:	002d883a 	mov	r22,zero
  413e54:	d8c00f17 	ldw	r3,60(sp)
  413e58:	18c00044 	addi	r3,r3,1
  413e5c:	d8c00f15 	stw	r3,60(sp)
  413e60:	003ecc06 	br	413994 <_gp+0xffff3cc4>
  413e64:	8005883a 	mov	r2,r16
  413e68:	dfc01c17 	ldw	ra,112(sp)
  413e6c:	df001b17 	ldw	fp,108(sp)
  413e70:	ddc01a17 	ldw	r23,104(sp)
  413e74:	dd801917 	ldw	r22,100(sp)
  413e78:	dd401817 	ldw	r21,96(sp)
  413e7c:	dd001717 	ldw	r20,92(sp)
  413e80:	dcc01617 	ldw	r19,88(sp)
  413e84:	dc801517 	ldw	r18,84(sp)
  413e88:	dc401417 	ldw	r17,80(sp)
  413e8c:	dc001317 	ldw	r16,76(sp)
  413e90:	dec01d04 	addi	sp,sp,116
  413e94:	f800283a 	ret

00413e98 <__vfprintf_internal_unused>:
  413e98:	2007883a 	mov	r3,r4
  413e9c:	01001074 	movhi	r4,65
  413ea0:	211f3504 	addi	r4,r4,31956
  413ea4:	21000017 	ldw	r4,0(r4)
  413ea8:	2805883a 	mov	r2,r5
  413eac:	300f883a 	mov	r7,r6
  413eb0:	180b883a 	mov	r5,r3
  413eb4:	100d883a 	mov	r6,r2
  413eb8:	041392c1 	jmpi	41392c <___svfprintf_internal_r>

00413ebc <_write_r>:
  413ebc:	defffd04 	addi	sp,sp,-12
  413ec0:	dc000015 	stw	r16,0(sp)
  413ec4:	040010b4 	movhi	r16,66
  413ec8:	dc400115 	stw	r17,4(sp)
  413ecc:	84206804 	addi	r16,r16,-32352
  413ed0:	2023883a 	mov	r17,r4
  413ed4:	2809883a 	mov	r4,r5
  413ed8:	300b883a 	mov	r5,r6
  413edc:	380d883a 	mov	r6,r7
  413ee0:	dfc00215 	stw	ra,8(sp)
  413ee4:	80000015 	stw	zero,0(r16)
  413ee8:	04143900 	call	414390 <write>
  413eec:	00ffffc4 	movi	r3,-1
  413ef0:	10c0031e 	bne	r2,r3,413f00 <_write_r+0x44>
  413ef4:	80c00017 	ldw	r3,0(r16)
  413ef8:	18000126 	beq	r3,zero,413f00 <_write_r+0x44>
  413efc:	88c00015 	stw	r3,0(r17)
  413f00:	dfc00217 	ldw	ra,8(sp)
  413f04:	dc400117 	ldw	r17,4(sp)
  413f08:	dc000017 	ldw	r16,0(sp)
  413f0c:	dec00304 	addi	sp,sp,12
  413f10:	f800283a 	ret

00413f14 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  413f14:	defff904 	addi	sp,sp,-28
  413f18:	dfc00615 	stw	ra,24(sp)
  413f1c:	df000515 	stw	fp,20(sp)
  413f20:	df000504 	addi	fp,sp,20
  413f24:	e13ffc15 	stw	r4,-16(fp)
  413f28:	e17ffd15 	stw	r5,-12(fp)
  413f2c:	e1bffe15 	stw	r6,-8(fp)
  413f30:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  413f34:	e0800217 	ldw	r2,8(fp)
  413f38:	d8800015 	stw	r2,0(sp)
  413f3c:	e13ffc17 	ldw	r4,-16(fp)
  413f40:	e17ffd17 	ldw	r5,-12(fp)
  413f44:	e1bffe17 	ldw	r6,-8(fp)
  413f48:	e1ffff17 	ldw	r7,-4(fp)
  413f4c:	04140f40 	call	4140f4 <alt_iic_isr_register>
}  
  413f50:	e037883a 	mov	sp,fp
  413f54:	dfc00117 	ldw	ra,4(sp)
  413f58:	df000017 	ldw	fp,0(sp)
  413f5c:	dec00204 	addi	sp,sp,8
  413f60:	f800283a 	ret

00413f64 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  413f64:	defff904 	addi	sp,sp,-28
  413f68:	df000615 	stw	fp,24(sp)
  413f6c:	df000604 	addi	fp,sp,24
  413f70:	e13ffe15 	stw	r4,-8(fp)
  413f74:	e17fff15 	stw	r5,-4(fp)
  413f78:	e0bfff17 	ldw	r2,-4(fp)
  413f7c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  413f80:	0005303a 	rdctl	r2,status
  413f84:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  413f88:	e0fffb17 	ldw	r3,-20(fp)
  413f8c:	00bfff84 	movi	r2,-2
  413f90:	1884703a 	and	r2,r3,r2
  413f94:	1001703a 	wrctl	status,r2
  
  return context;
  413f98:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  413f9c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  413fa0:	e0bffa17 	ldw	r2,-24(fp)
  413fa4:	00c00044 	movi	r3,1
  413fa8:	1884983a 	sll	r2,r3,r2
  413fac:	1007883a 	mov	r3,r2
  413fb0:	008010b4 	movhi	r2,66
  413fb4:	10a06904 	addi	r2,r2,-32348
  413fb8:	10800017 	ldw	r2,0(r2)
  413fbc:	1886b03a 	or	r3,r3,r2
  413fc0:	008010b4 	movhi	r2,66
  413fc4:	10a06904 	addi	r2,r2,-32348
  413fc8:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  413fcc:	008010b4 	movhi	r2,66
  413fd0:	10a06904 	addi	r2,r2,-32348
  413fd4:	10800017 	ldw	r2,0(r2)
  413fd8:	100170fa 	wrctl	ienable,r2
  413fdc:	e0bffc17 	ldw	r2,-16(fp)
  413fe0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  413fe4:	e0bffd17 	ldw	r2,-12(fp)
  413fe8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  413fec:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
  413ff0:	0001883a 	nop
}
  413ff4:	e037883a 	mov	sp,fp
  413ff8:	df000017 	ldw	fp,0(sp)
  413ffc:	dec00104 	addi	sp,sp,4
  414000:	f800283a 	ret

00414004 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  414004:	defff904 	addi	sp,sp,-28
  414008:	df000615 	stw	fp,24(sp)
  41400c:	df000604 	addi	fp,sp,24
  414010:	e13ffe15 	stw	r4,-8(fp)
  414014:	e17fff15 	stw	r5,-4(fp)
  414018:	e0bfff17 	ldw	r2,-4(fp)
  41401c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  414020:	0005303a 	rdctl	r2,status
  414024:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  414028:	e0fffb17 	ldw	r3,-20(fp)
  41402c:	00bfff84 	movi	r2,-2
  414030:	1884703a 	and	r2,r3,r2
  414034:	1001703a 	wrctl	status,r2
  
  return context;
  414038:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  41403c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  414040:	e0bffa17 	ldw	r2,-24(fp)
  414044:	00c00044 	movi	r3,1
  414048:	1884983a 	sll	r2,r3,r2
  41404c:	0084303a 	nor	r2,zero,r2
  414050:	1007883a 	mov	r3,r2
  414054:	008010b4 	movhi	r2,66
  414058:	10a06904 	addi	r2,r2,-32348
  41405c:	10800017 	ldw	r2,0(r2)
  414060:	1886703a 	and	r3,r3,r2
  414064:	008010b4 	movhi	r2,66
  414068:	10a06904 	addi	r2,r2,-32348
  41406c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  414070:	008010b4 	movhi	r2,66
  414074:	10a06904 	addi	r2,r2,-32348
  414078:	10800017 	ldw	r2,0(r2)
  41407c:	100170fa 	wrctl	ienable,r2
  414080:	e0bffc17 	ldw	r2,-16(fp)
  414084:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  414088:	e0bffd17 	ldw	r2,-12(fp)
  41408c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  414090:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
  414094:	0001883a 	nop
}
  414098:	e037883a 	mov	sp,fp
  41409c:	df000017 	ldw	fp,0(sp)
  4140a0:	dec00104 	addi	sp,sp,4
  4140a4:	f800283a 	ret

004140a8 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  4140a8:	defffc04 	addi	sp,sp,-16
  4140ac:	df000315 	stw	fp,12(sp)
  4140b0:	df000304 	addi	fp,sp,12
  4140b4:	e13ffe15 	stw	r4,-8(fp)
  4140b8:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  4140bc:	000530fa 	rdctl	r2,ienable
  4140c0:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  4140c4:	e0bfff17 	ldw	r2,-4(fp)
  4140c8:	00c00044 	movi	r3,1
  4140cc:	1884983a 	sll	r2,r3,r2
  4140d0:	1007883a 	mov	r3,r2
  4140d4:	e0bffd17 	ldw	r2,-12(fp)
  4140d8:	1884703a 	and	r2,r3,r2
  4140dc:	1004c03a 	cmpne	r2,r2,zero
  4140e0:	10803fcc 	andi	r2,r2,255
}
  4140e4:	e037883a 	mov	sp,fp
  4140e8:	df000017 	ldw	fp,0(sp)
  4140ec:	dec00104 	addi	sp,sp,4
  4140f0:	f800283a 	ret

004140f4 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  4140f4:	defff504 	addi	sp,sp,-44
  4140f8:	dfc00a15 	stw	ra,40(sp)
  4140fc:	df000915 	stw	fp,36(sp)
  414100:	df000904 	addi	fp,sp,36
  414104:	e13ffc15 	stw	r4,-16(fp)
  414108:	e17ffd15 	stw	r5,-12(fp)
  41410c:	e1bffe15 	stw	r6,-8(fp)
  414110:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  414114:	00bffa84 	movi	r2,-22
  414118:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  41411c:	e0bffd17 	ldw	r2,-12(fp)
  414120:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  414124:	e0bff817 	ldw	r2,-32(fp)
  414128:	10800808 	cmpgei	r2,r2,32
  41412c:	1000271e 	bne	r2,zero,4141cc <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  414130:	0005303a 	rdctl	r2,status
  414134:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  414138:	e0fffa17 	ldw	r3,-24(fp)
  41413c:	00bfff84 	movi	r2,-2
  414140:	1884703a 	and	r2,r3,r2
  414144:	1001703a 	wrctl	status,r2
  
  return context;
  414148:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  41414c:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  414150:	008010b4 	movhi	r2,66
  414154:	10a11904 	addi	r2,r2,-31644
  414158:	e0fff817 	ldw	r3,-32(fp)
  41415c:	180690fa 	slli	r3,r3,3
  414160:	10c5883a 	add	r2,r2,r3
  414164:	e0fffe17 	ldw	r3,-8(fp)
  414168:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  41416c:	008010b4 	movhi	r2,66
  414170:	10a11904 	addi	r2,r2,-31644
  414174:	e0fff817 	ldw	r3,-32(fp)
  414178:	180690fa 	slli	r3,r3,3
  41417c:	18c00104 	addi	r3,r3,4
  414180:	10c5883a 	add	r2,r2,r3
  414184:	e0ffff17 	ldw	r3,-4(fp)
  414188:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  41418c:	e0bffe17 	ldw	r2,-8(fp)
  414190:	10000526 	beq	r2,zero,4141a8 <alt_iic_isr_register+0xb4>
  414194:	e0bff817 	ldw	r2,-32(fp)
  414198:	e13ffc17 	ldw	r4,-16(fp)
  41419c:	100b883a 	mov	r5,r2
  4141a0:	0413f640 	call	413f64 <alt_ic_irq_enable>
  4141a4:	00000406 	br	4141b8 <alt_iic_isr_register+0xc4>
  4141a8:	e0bff817 	ldw	r2,-32(fp)
  4141ac:	e13ffc17 	ldw	r4,-16(fp)
  4141b0:	100b883a 	mov	r5,r2
  4141b4:	04140040 	call	414004 <alt_ic_irq_disable>
  4141b8:	e0bff715 	stw	r2,-36(fp)
  4141bc:	e0bff917 	ldw	r2,-28(fp)
  4141c0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  4141c4:	e0bffb17 	ldw	r2,-20(fp)
  4141c8:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  4141cc:	e0bff717 	ldw	r2,-36(fp)
}
  4141d0:	e037883a 	mov	sp,fp
  4141d4:	dfc00117 	ldw	ra,4(sp)
  4141d8:	df000017 	ldw	fp,0(sp)
  4141dc:	dec00204 	addi	sp,sp,8
  4141e0:	f800283a 	ret

004141e4 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  4141e4:	defffc04 	addi	sp,sp,-16
  4141e8:	df000315 	stw	fp,12(sp)
  4141ec:	df000304 	addi	fp,sp,12
  4141f0:	e13ffd15 	stw	r4,-12(fp)
  4141f4:	e17ffe15 	stw	r5,-8(fp)
  4141f8:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  4141fc:	e0fffe17 	ldw	r3,-8(fp)
  414200:	e0bffd17 	ldw	r2,-12(fp)
  414204:	18800c26 	beq	r3,r2,414238 <alt_load_section+0x54>
  {
    while( to != end )
  414208:	00000806 	br	41422c <alt_load_section+0x48>
    {
      *to++ = *from++;
  41420c:	e0bffe17 	ldw	r2,-8(fp)
  414210:	10c00104 	addi	r3,r2,4
  414214:	e0fffe15 	stw	r3,-8(fp)
  414218:	e0fffd17 	ldw	r3,-12(fp)
  41421c:	19000104 	addi	r4,r3,4
  414220:	e13ffd15 	stw	r4,-12(fp)
  414224:	18c00017 	ldw	r3,0(r3)
  414228:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  41422c:	e0fffe17 	ldw	r3,-8(fp)
  414230:	e0bfff17 	ldw	r2,-4(fp)
  414234:	18bff51e 	bne	r3,r2,41420c <_gp+0xffff453c>
    {
      *to++ = *from++;
    }
  }
}
  414238:	e037883a 	mov	sp,fp
  41423c:	df000017 	ldw	fp,0(sp)
  414240:	dec00104 	addi	sp,sp,4
  414244:	f800283a 	ret

00414248 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  414248:	defffe04 	addi	sp,sp,-8
  41424c:	dfc00115 	stw	ra,4(sp)
  414250:	df000015 	stw	fp,0(sp)
  414254:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  414258:	01001074 	movhi	r4,65
  41425c:	211f4104 	addi	r4,r4,32004
  414260:	01401074 	movhi	r5,65
  414264:	295e2304 	addi	r5,r5,30860
  414268:	01801074 	movhi	r6,65
  41426c:	319f4104 	addi	r6,r6,32004
  414270:	04141e40 	call	4141e4 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  414274:	01001074 	movhi	r4,65
  414278:	21000804 	addi	r4,r4,32
  41427c:	01401074 	movhi	r5,65
  414280:	29400804 	addi	r5,r5,32
  414284:	01801074 	movhi	r6,65
  414288:	31808b04 	addi	r6,r6,556
  41428c:	04141e40 	call	4141e4 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  414290:	01001074 	movhi	r4,65
  414294:	211db904 	addi	r4,r4,30436
  414298:	01401074 	movhi	r5,65
  41429c:	295db904 	addi	r5,r5,30436
  4142a0:	01801074 	movhi	r6,65
  4142a4:	319e2304 	addi	r6,r6,30860
  4142a8:	04141e40 	call	4141e4 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  4142ac:	04165480 	call	416548 <alt_dcache_flush_all>
  alt_icache_flush_all();
  4142b0:	04167f40 	call	4167f4 <alt_icache_flush_all>
}
  4142b4:	e037883a 	mov	sp,fp
  4142b8:	dfc00117 	ldw	ra,4(sp)
  4142bc:	df000017 	ldw	fp,0(sp)
  4142c0:	dec00204 	addi	sp,sp,8
  4142c4:	f800283a 	ret

004142c8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  4142c8:	defffd04 	addi	sp,sp,-12
  4142cc:	dfc00215 	stw	ra,8(sp)
  4142d0:	df000115 	stw	fp,4(sp)
  4142d4:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  4142d8:	0009883a 	mov	r4,zero
  4142dc:	04144c80 	call	4144c8 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  4142e0:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  4142e4:	04144fc0 	call	4144fc <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  4142e8:	01001074 	movhi	r4,65
  4142ec:	211e0b04 	addi	r4,r4,30764
  4142f0:	01401074 	movhi	r5,65
  4142f4:	295e0b04 	addi	r5,r5,30764
  4142f8:	01801074 	movhi	r6,65
  4142fc:	319e0b04 	addi	r6,r6,30764
  414300:	041698c0 	call	41698c <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  414304:	04166840 	call	416684 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  414308:	01001074 	movhi	r4,65
  41430c:	2119b804 	addi	r4,r4,26336
  414310:	04173600 	call	417360 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  414314:	d1213617 	ldw	r4,-31528(gp)
  414318:	d0e13717 	ldw	r3,-31524(gp)
  41431c:	d0a13817 	ldw	r2,-31520(gp)
  414320:	180b883a 	mov	r5,r3
  414324:	100d883a 	mov	r6,r2
  414328:	0411ae80 	call	411ae8 <main>
  41432c:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  414330:	01000044 	movi	r4,1
  414334:	04164700 	call	416470 <close>
  exit (result);
  414338:	e13fff17 	ldw	r4,-4(fp)
  41433c:	04173740 	call	417374 <exit>

00414340 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  414340:	defffe04 	addi	sp,sp,-8
  414344:	dfc00115 	stw	ra,4(sp)
  414348:	df000015 	stw	fp,0(sp)
  41434c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  414350:	00801074 	movhi	r2,65
  414354:	109f3c04 	addi	r2,r2,31984
  414358:	10800017 	ldw	r2,0(r2)
  41435c:	10000526 	beq	r2,zero,414374 <alt_get_errno+0x34>
  414360:	00801074 	movhi	r2,65
  414364:	109f3c04 	addi	r2,r2,31984
  414368:	10800017 	ldw	r2,0(r2)
  41436c:	103ee83a 	callr	r2
  414370:	00000206 	br	41437c <alt_get_errno+0x3c>
  414374:	008010b4 	movhi	r2,66
  414378:	10a06804 	addi	r2,r2,-32352
}
  41437c:	e037883a 	mov	sp,fp
  414380:	dfc00117 	ldw	ra,4(sp)
  414384:	df000017 	ldw	fp,0(sp)
  414388:	dec00204 	addi	sp,sp,8
  41438c:	f800283a 	ret

00414390 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  414390:	defff904 	addi	sp,sp,-28
  414394:	dfc00615 	stw	ra,24(sp)
  414398:	df000515 	stw	fp,20(sp)
  41439c:	df000504 	addi	fp,sp,20
  4143a0:	e13ffd15 	stw	r4,-12(fp)
  4143a4:	e17ffe15 	stw	r5,-8(fp)
  4143a8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  4143ac:	e0bffd17 	ldw	r2,-12(fp)
  4143b0:	10000816 	blt	r2,zero,4143d4 <write+0x44>
  4143b4:	e13ffd17 	ldw	r4,-12(fp)
  4143b8:	01400304 	movi	r5,12
  4143bc:	0411f000 	call	411f00 <__mulsi3>
  4143c0:	1007883a 	mov	r3,r2
  4143c4:	00801074 	movhi	r2,65
  4143c8:	109ed404 	addi	r2,r2,31568
  4143cc:	1885883a 	add	r2,r3,r2
  4143d0:	00000106 	br	4143d8 <write+0x48>
  4143d4:	0005883a 	mov	r2,zero
  4143d8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  4143dc:	e0bffb17 	ldw	r2,-20(fp)
  4143e0:	10002126 	beq	r2,zero,414468 <write+0xd8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  4143e4:	e0bffb17 	ldw	r2,-20(fp)
  4143e8:	10800217 	ldw	r2,8(r2)
  4143ec:	108000cc 	andi	r2,r2,3
  4143f0:	10001826 	beq	r2,zero,414454 <write+0xc4>
  4143f4:	e0bffb17 	ldw	r2,-20(fp)
  4143f8:	10800017 	ldw	r2,0(r2)
  4143fc:	10800617 	ldw	r2,24(r2)
  414400:	10001426 	beq	r2,zero,414454 <write+0xc4>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  414404:	e0bffb17 	ldw	r2,-20(fp)
  414408:	10800017 	ldw	r2,0(r2)
  41440c:	10800617 	ldw	r2,24(r2)
  414410:	e0ffff17 	ldw	r3,-4(fp)
  414414:	e13ffb17 	ldw	r4,-20(fp)
  414418:	e17ffe17 	ldw	r5,-8(fp)
  41441c:	180d883a 	mov	r6,r3
  414420:	103ee83a 	callr	r2
  414424:	e0bffc15 	stw	r2,-16(fp)
  414428:	e0bffc17 	ldw	r2,-16(fp)
  41442c:	1000070e 	bge	r2,zero,41444c <write+0xbc>
      {
        ALT_ERRNO = -rval;
  414430:	04143400 	call	414340 <alt_get_errno>
  414434:	1007883a 	mov	r3,r2
  414438:	e0bffc17 	ldw	r2,-16(fp)
  41443c:	0085c83a 	sub	r2,zero,r2
  414440:	18800015 	stw	r2,0(r3)
        return -1;
  414444:	00bfffc4 	movi	r2,-1
  414448:	00000c06 	br	41447c <write+0xec>
      }
      return rval;
  41444c:	e0bffc17 	ldw	r2,-16(fp)
  414450:	00000a06 	br	41447c <write+0xec>
    }
    else
    {
      ALT_ERRNO = EACCES;
  414454:	04143400 	call	414340 <alt_get_errno>
  414458:	1007883a 	mov	r3,r2
  41445c:	00800344 	movi	r2,13
  414460:	18800015 	stw	r2,0(r3)
  414464:	00000406 	br	414478 <write+0xe8>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  414468:	04143400 	call	414340 <alt_get_errno>
  41446c:	1007883a 	mov	r3,r2
  414470:	00801444 	movi	r2,81
  414474:	18800015 	stw	r2,0(r3)
  }
  return -1;
  414478:	00bfffc4 	movi	r2,-1
}
  41447c:	e037883a 	mov	sp,fp
  414480:	dfc00117 	ldw	ra,4(sp)
  414484:	df000017 	ldw	fp,0(sp)
  414488:	dec00204 	addi	sp,sp,8
  41448c:	f800283a 	ret

00414490 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  414490:	defffd04 	addi	sp,sp,-12
  414494:	dfc00215 	stw	ra,8(sp)
  414498:	df000115 	stw	fp,4(sp)
  41449c:	df000104 	addi	fp,sp,4
  4144a0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  4144a4:	e13fff17 	ldw	r4,-4(fp)
  4144a8:	01401074 	movhi	r5,65
  4144ac:	295f3904 	addi	r5,r5,31972
  4144b0:	04165e00 	call	4165e0 <alt_dev_llist_insert>
}
  4144b4:	e037883a 	mov	sp,fp
  4144b8:	dfc00117 	ldw	ra,4(sp)
  4144bc:	df000017 	ldw	fp,0(sp)
  4144c0:	dec00204 	addi	sp,sp,8
  4144c4:	f800283a 	ret

004144c8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  4144c8:	defffd04 	addi	sp,sp,-12
  4144cc:	dfc00215 	stw	ra,8(sp)
  4144d0:	df000115 	stw	fp,4(sp)
  4144d4:	df000104 	addi	fp,sp,4
  4144d8:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
  4144dc:	0416ec40 	call	416ec4 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  4144e0:	00800044 	movi	r2,1
  4144e4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  4144e8:	e037883a 	mov	sp,fp
  4144ec:	dfc00117 	ldw	ra,4(sp)
  4144f0:	df000017 	ldw	fp,0(sp)
  4144f4:	dec00204 	addi	sp,sp,8
  4144f8:	f800283a 	ret

004144fc <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  4144fc:	defffe04 	addi	sp,sp,-8
  414500:	dfc00115 	stw	ra,4(sp)
  414504:	df000015 	stw	fp,0(sp)
  414508:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_MS, timer_ms);
  41450c:	010010b4 	movhi	r4,66
  414510:	21062804 	addi	r4,r4,6304
  414514:	000b883a 	mov	r5,zero
  414518:	018000c4 	movi	r6,3
  41451c:	01c0fa04 	movi	r7,1000
  414520:	041533c0 	call	41533c <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_US, timer_us);
  414524:	008010b4 	movhi	r2,66
  414528:	10a06d04 	addi	r2,r2,-32332
  41452c:	00c010b4 	movhi	r3,66
  414530:	18c63004 	addi	r3,r3,6336
  414534:	10c00015 	stw	r3,0(r2)
  414538:	008010b4 	movhi	r2,66
  41453c:	10a06e04 	addi	r2,r2,-32328
  414540:	00c003f4 	movhi	r3,15
  414544:	18d09004 	addi	r3,r3,16960
  414548:	10c00015 	stw	r3,0(r2)
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS_FLASH_CONTROLLER_0, epcs_flash_controller_0);
  41454c:	01001074 	movhi	r4,65
  414550:	211e5b04 	addi	r4,r4,31084
  414554:	04145d00 	call	4145d0 <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
  414558:	01001074 	movhi	r4,65
  41455c:	211e8e04 	addi	r4,r4,31288
  414560:	04144900 	call	414490 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
  414564:	01001074 	movhi	r4,65
  414568:	211ea304 	addi	r4,r4,31372
  41456c:	000b883a 	mov	r5,zero
  414570:	01800044 	movi	r6,1
  414574:	04156140 	call	415614 <altera_avalon_uart_init>
  414578:	01001074 	movhi	r4,65
  41457c:	211e9904 	addi	r4,r4,31332
  414580:	04144900 	call	414490 <alt_dev_reg>
}
  414584:	e037883a 	mov	sp,fp
  414588:	dfc00117 	ldw	ra,4(sp)
  41458c:	df000017 	ldw	fp,0(sp)
  414590:	dec00204 	addi	sp,sp,8
  414594:	f800283a 	ret

00414598 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
  414598:	defffd04 	addi	sp,sp,-12
  41459c:	dfc00215 	stw	ra,8(sp)
  4145a0:	df000115 	stw	fp,4(sp)
  4145a4:	df000104 	addi	fp,sp,4
  4145a8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
  4145ac:	e13fff17 	ldw	r4,-4(fp)
  4145b0:	01401074 	movhi	r5,65
  4145b4:	295f3d04 	addi	r5,r5,31988
  4145b8:	04165e00 	call	4165e0 <alt_dev_llist_insert>
}
  4145bc:	e037883a 	mov	sp,fp
  4145c0:	dfc00117 	ldw	ra,4(sp)
  4145c4:	df000017 	ldw	fp,0(sp)
  4145c8:	dec00204 	addi	sp,sp,8
  4145cc:	f800283a 	ret

004145d0 <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
  4145d0:	defffc04 	addi	sp,sp,-16
  4145d4:	dfc00315 	stw	ra,12(sp)
  4145d8:	df000215 	stw	fp,8(sp)
  4145dc:	df000204 	addi	fp,sp,8
  4145e0:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
  4145e4:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
  4145e8:	e13fff17 	ldw	r4,-4(fp)
  4145ec:	04146240 	call	414624 <alt_epcs_flash_query>
  4145f0:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
  4145f4:	e0bffe17 	ldw	r2,-8(fp)
  4145f8:	1000041e 	bne	r2,zero,41460c <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
  4145fc:	e0bfff17 	ldw	r2,-4(fp)
  414600:	1009883a 	mov	r4,r2
  414604:	04145980 	call	414598 <alt_flash_device_register>
  414608:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
  41460c:	e0bffe17 	ldw	r2,-8(fp)
}
  414610:	e037883a 	mov	sp,fp
  414614:	dfc00117 	ldw	ra,4(sp)
  414618:	df000017 	ldw	fp,0(sp)
  41461c:	dec00204 	addi	sp,sp,8
  414620:	f800283a 	ret

00414624 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
  414624:	defffc04 	addi	sp,sp,-16
  414628:	dfc00315 	stw	ra,12(sp)
  41462c:	df000215 	stw	fp,8(sp)
  414630:	df000204 	addi	fp,sp,8
  414634:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
  414638:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  41463c:	e0bfff17 	ldw	r2,-4(fp)
  414640:	10003215 	stw	zero,200(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
    epcs_read_electronic_signature(flash->register_base);
  414644:	e0bfff17 	ldw	r2,-4(fp)
  414648:	10802e17 	ldw	r2,184(r2)
  41464c:	1009883a 	mov	r4,r2
  414650:	04162800 	call	416280 <epcs_read_electronic_signature>
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  
  /* Send the RES command sequence */
  flash->silicon_id =
  414654:	10c03fcc 	andi	r3,r2,255
  414658:	e0bfff17 	ldw	r2,-4(fp)
  41465c:	10c03015 	stw	r3,192(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
  414660:	e0bfff17 	ldw	r2,-4(fp)
  414664:	10803017 	ldw	r2,192(r2)
  414668:	10800598 	cmpnei	r2,r2,22
  41466c:	10000a1e 	bne	r2,zero,414698 <alt_epcs_flash_query+0x74>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
  414670:	e0bfff17 	ldw	r2,-4(fp)
  414674:	00c02034 	movhi	r3,128
  414678:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 128;
  41467c:	e0bfff17 	ldw	r2,-4(fp)
  414680:	00c02004 	movi	r3,128
  414684:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  414688:	e0bfff17 	ldw	r2,-4(fp)
  41468c:	00c00074 	movhi	r3,1
  414690:	10c01015 	stw	r3,64(r2)
  414694:	0000ce06 	br	4149d0 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
  414698:	e0bfff17 	ldw	r2,-4(fp)
  41469c:	10803017 	ldw	r2,192(r2)
  4146a0:	10800518 	cmpnei	r2,r2,20
  4146a4:	10000a1e 	bne	r2,zero,4146d0 <alt_epcs_flash_query+0xac>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
  4146a8:	e0bfff17 	ldw	r2,-4(fp)
  4146ac:	00c00834 	movhi	r3,32
  4146b0:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 32;
  4146b4:	e0bfff17 	ldw	r2,-4(fp)
  4146b8:	00c00804 	movi	r3,32
  4146bc:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  4146c0:	e0bfff17 	ldw	r2,-4(fp)
  4146c4:	00c00074 	movhi	r3,1
  4146c8:	10c01015 	stw	r3,64(r2)
  4146cc:	0000c006 	br	4149d0 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
  4146d0:	e0bfff17 	ldw	r2,-4(fp)
  4146d4:	10803017 	ldw	r2,192(r2)
  4146d8:	108004d8 	cmpnei	r2,r2,19
  4146dc:	10000a1e 	bne	r2,zero,414708 <alt_epcs_flash_query+0xe4>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
  4146e0:	e0bfff17 	ldw	r2,-4(fp)
  4146e4:	00c00434 	movhi	r3,16
  4146e8:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 16;
  4146ec:	e0bfff17 	ldw	r2,-4(fp)
  4146f0:	00c00404 	movi	r3,16
  4146f4:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  4146f8:	e0bfff17 	ldw	r2,-4(fp)
  4146fc:	00c00074 	movhi	r3,1
  414700:	10c01015 	stw	r3,64(r2)
  414704:	0000b206 	br	4149d0 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
  414708:	e0bfff17 	ldw	r2,-4(fp)
  41470c:	10803017 	ldw	r2,192(r2)
  414710:	10800498 	cmpnei	r2,r2,18
  414714:	10000a1e 	bne	r2,zero,414740 <alt_epcs_flash_query+0x11c>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
  414718:	e0bfff17 	ldw	r2,-4(fp)
  41471c:	00c00234 	movhi	r3,8
  414720:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 8;
  414724:	e0bfff17 	ldw	r2,-4(fp)
  414728:	00c00204 	movi	r3,8
  41472c:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  414730:	e0bfff17 	ldw	r2,-4(fp)
  414734:	00c00074 	movhi	r3,1
  414738:	10c01015 	stw	r3,64(r2)
  41473c:	0000a406 	br	4149d0 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
  414740:	e0bfff17 	ldw	r2,-4(fp)
  414744:	10803017 	ldw	r2,192(r2)
  414748:	10800418 	cmpnei	r2,r2,16
  41474c:	10000a1e 	bne	r2,zero,414778 <alt_epcs_flash_query+0x154>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
  414750:	e0bfff17 	ldw	r2,-4(fp)
  414754:	00c000b4 	movhi	r3,2
  414758:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 4;
  41475c:	e0bfff17 	ldw	r2,-4(fp)
  414760:	00c00104 	movi	r3,4
  414764:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 32768;
  414768:	e0bfff17 	ldw	r2,-4(fp)
  41476c:	00e00014 	movui	r3,32768
  414770:	10c01015 	stw	r3,64(r2)
  414774:	00009606 	br	4149d0 <alt_epcs_flash_query+0x3ac>
  {
    /* 
     * Read electronic signature doesn't work for newer devices; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
  414778:	e0bfff17 	ldw	r2,-4(fp)
  41477c:	10802e17 	ldw	r2,184(r2)
  414780:	1009883a 	mov	r4,r2
  414784:	04162e80 	call	4162e8 <epcs_read_device_id>
  414788:	1007883a 	mov	r3,r2
  41478c:	e0bfff17 	ldw	r2,-4(fp)
  414790:	10c03015 	stw	r3,192(r2)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA15) /* EPCQ16 */
  414794:	e0bfff17 	ldw	r2,-4(fp)
  414798:	10c03017 	ldw	r3,192(r2)
  41479c:	00804034 	movhi	r2,256
  4147a0:	10bfffc4 	addi	r2,r2,-1
  4147a4:	1886703a 	and	r3,r3,r2
  4147a8:	00800874 	movhi	r2,33
  4147ac:	10ae8544 	addi	r2,r2,-17899
  4147b0:	18800a1e 	bne	r3,r2,4147dc <alt_epcs_flash_query+0x1b8>
    {
      flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
  4147b4:	e0bfff17 	ldw	r2,-4(fp)
  4147b8:	00c00834 	movhi	r3,32
  4147bc:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 32; /* number of sectors */
  4147c0:	e0bfff17 	ldw	r2,-4(fp)
  4147c4:	00c00804 	movi	r3,32
  4147c8:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  4147cc:	e0bfff17 	ldw	r2,-4(fp)
  4147d0:	00c00074 	movhi	r3,1
  4147d4:	10c01015 	stw	r3,64(r2)
  4147d8:	00007d06 	br	4149d0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA16) /* EPCQ32 */
  4147dc:	e0bfff17 	ldw	r2,-4(fp)
  4147e0:	10c03017 	ldw	r3,192(r2)
  4147e4:	00804034 	movhi	r2,256
  4147e8:	10bfffc4 	addi	r2,r2,-1
  4147ec:	1886703a 	and	r3,r3,r2
  4147f0:	00800874 	movhi	r2,33
  4147f4:	10ae8584 	addi	r2,r2,-17898
  4147f8:	18800a1e 	bne	r3,r2,414824 <alt_epcs_flash_query+0x200>
    {
      flash->dev.region_info[0].region_size = 32 * 1024 * 1024 / 8;
  4147fc:	e0bfff17 	ldw	r2,-4(fp)
  414800:	00c01034 	movhi	r3,64
  414804:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64; /* number of sectors */
  414808:	e0bfff17 	ldw	r2,-4(fp)
  41480c:	00c01004 	movi	r3,64
  414810:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  414814:	e0bfff17 	ldw	r2,-4(fp)
  414818:	00c00074 	movhi	r3,1
  41481c:	10c01015 	stw	r3,64(r2)
  414820:	00006b06 	br	4149d0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA17) /* EPCQ64 */
  414824:	e0bfff17 	ldw	r2,-4(fp)
  414828:	10c03017 	ldw	r3,192(r2)
  41482c:	00804034 	movhi	r2,256
  414830:	10bfffc4 	addi	r2,r2,-1
  414834:	1886703a 	and	r3,r3,r2
  414838:	00800874 	movhi	r2,33
  41483c:	10ae85c4 	addi	r2,r2,-17897
  414840:	18800a1e 	bne	r3,r2,41486c <alt_epcs_flash_query+0x248>
    {
      flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
  414844:	e0bfff17 	ldw	r2,-4(fp)
  414848:	00c02034 	movhi	r3,128
  41484c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 128; /* number of sectors */
  414850:	e0bfff17 	ldw	r2,-4(fp)
  414854:	00c02004 	movi	r3,128
  414858:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  41485c:	e0bfff17 	ldw	r2,-4(fp)
  414860:	00c00074 	movhi	r3,1
  414864:	10c01015 	stw	r3,64(r2)
  414868:	00005906 	br	4149d0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
  41486c:	e0bfff17 	ldw	r2,-4(fp)
  414870:	10c03017 	ldw	r3,192(r2)
  414874:	00804034 	movhi	r2,256
  414878:	10bfffc4 	addi	r2,r2,-1
  41487c:	1886703a 	and	r3,r3,r2
  414880:	00800874 	movhi	r2,33
  414884:	10ae8604 	addi	r2,r2,-17896
  414888:	18800a1e 	bne	r3,r2,4148b4 <alt_epcs_flash_query+0x290>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
  41488c:	e0bfff17 	ldw	r2,-4(fp)
  414890:	00c04034 	movhi	r3,256
  414894:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
  414898:	e0bfff17 	ldw	r2,-4(fp)
  41489c:	00c04004 	movi	r3,256
  4148a0:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  4148a4:	e0bfff17 	ldw	r2,-4(fp)
  4148a8:	00c00074 	movhi	r3,1
  4148ac:	10c01015 	stw	r3,64(r2)
  4148b0:	00004706 	br	4149d0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
  4148b4:	e0bfff17 	ldw	r2,-4(fp)
  4148b8:	10803017 	ldw	r2,192(r2)
  4148bc:	10803fcc 	andi	r2,r2,255
  4148c0:	10800618 	cmpnei	r2,r2,24
  4148c4:	10000a1e 	bne	r2,zero,4148f0 <alt_epcs_flash_query+0x2cc>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
  4148c8:	e0bfff17 	ldw	r2,-4(fp)
  4148cc:	00c04034 	movhi	r3,256
  4148d0:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64;
  4148d4:	e0bfff17 	ldw	r2,-4(fp)
  4148d8:	00c01004 	movi	r3,64
  4148dc:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 262144;
  4148e0:	e0bfff17 	ldw	r2,-4(fp)
  4148e4:	00c00134 	movhi	r3,4
  4148e8:	10c01015 	stw	r3,64(r2)
  4148ec:	00003806 	br	4149d0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
  4148f0:	e0bfff17 	ldw	r2,-4(fp)
  4148f4:	10803017 	ldw	r2,192(r2)
  4148f8:	10803fcc 	andi	r2,r2,255
  4148fc:	10800658 	cmpnei	r2,r2,25
  414900:	10000d1e 	bne	r2,zero,414938 <alt_epcs_flash_query+0x314>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
  414904:	e0bfff17 	ldw	r2,-4(fp)
  414908:	00c08034 	movhi	r3,512
  41490c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
  414910:	e0bfff17 	ldw	r2,-4(fp)
  414914:	00c08004 	movi	r3,512
  414918:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  41491c:	e0bfff17 	ldw	r2,-4(fp)
  414920:	00c00074 	movhi	r3,1
  414924:	10c01015 	stw	r3,64(r2)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
  414928:	e0bfff17 	ldw	r2,-4(fp)
  41492c:	00c00044 	movi	r3,1
  414930:	10c03215 	stw	r3,200(r2)
  414934:	00002606 	br	4149d0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x20) /* EPCQ512 */
  414938:	e0bfff17 	ldw	r2,-4(fp)
  41493c:	10803017 	ldw	r2,192(r2)
  414940:	10803fcc 	andi	r2,r2,255
  414944:	10800818 	cmpnei	r2,r2,32
  414948:	10000d1e 	bne	r2,zero,414980 <alt_epcs_flash_query+0x35c>
    {
      flash->dev.region_info[0].region_size = 512 * 1024 * 1024 / 8;
  41494c:	e0bfff17 	ldw	r2,-4(fp)
  414950:	00c10034 	movhi	r3,1024
  414954:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 1024; /* number of sectors */
  414958:	e0bfff17 	ldw	r2,-4(fp)
  41495c:	00c10004 	movi	r3,1024
  414960:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  414964:	e0bfff17 	ldw	r2,-4(fp)
  414968:	00c00074 	movhi	r3,1
  41496c:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
  414970:	e0bfff17 	ldw	r2,-4(fp)
  414974:	00c00044 	movi	r3,1
  414978:	10c03215 	stw	r3,200(r2)
  41497c:	00001406 	br	4149d0 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x21) /* EPCQ1024 */
  414980:	e0bfff17 	ldw	r2,-4(fp)
  414984:	10803017 	ldw	r2,192(r2)
  414988:	10803fcc 	andi	r2,r2,255
  41498c:	10800858 	cmpnei	r2,r2,33
  414990:	10000d1e 	bne	r2,zero,4149c8 <alt_epcs_flash_query+0x3a4>
    {
      flash->dev.region_info[0].region_size = 1024 * 1024 * 1024 / 8;
  414994:	e0bfff17 	ldw	r2,-4(fp)
  414998:	00c20034 	movhi	r3,2048
  41499c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 2048; /* number of sectors */
  4149a0:	e0bfff17 	ldw	r2,-4(fp)
  4149a4:	00c20004 	movi	r3,2048
  4149a8:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  4149ac:	e0bfff17 	ldw	r2,-4(fp)
  4149b0:	00c00074 	movhi	r3,1
  4149b4:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
  4149b8:	e0bfff17 	ldw	r2,-4(fp)
  4149bc:	00c00044 	movi	r3,1
  4149c0:	10c03215 	stw	r3,200(r2)
  4149c4:	00000206 	br	4149d0 <alt_epcs_flash_query+0x3ac>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
  4149c8:	00bffb44 	movi	r2,-19
  4149cc:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
  4149d0:	e0bfff17 	ldw	r2,-4(fp)
  4149d4:	10800e17 	ldw	r2,56(r2)
  4149d8:	1007883a 	mov	r3,r2
  4149dc:	e0bfff17 	ldw	r2,-4(fp)
  4149e0:	10c02f15 	stw	r3,188(r2)
  flash->dev.number_of_regions = 1;
  4149e4:	e0bfff17 	ldw	r2,-4(fp)
  4149e8:	00c00044 	movi	r3,1
  4149ec:	10c00c15 	stw	r3,48(r2)
  flash->dev.region_info[0].offset = 0;
  4149f0:	e0bfff17 	ldw	r2,-4(fp)
  4149f4:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
  4149f8:	e0bfff17 	ldw	r2,-4(fp)
  4149fc:	00c04004 	movi	r3,256
  414a00:	10c03115 	stw	r3,196(r2)

  /* Consider clearing all BP bits here. */
  return ret_code;
  414a04:	e0bffe17 	ldw	r2,-8(fp)
}
  414a08:	e037883a 	mov	sp,fp
  414a0c:	dfc00117 	ldw	ra,4(sp)
  414a10:	df000017 	ldw	fp,0(sp)
  414a14:	dec00204 	addi	sp,sp,8
  414a18:	f800283a 	ret

00414a1c <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
  414a1c:	deffee04 	addi	sp,sp,-72
  414a20:	dfc01115 	stw	ra,68(sp)
  414a24:	df001015 	stw	fp,64(sp)
  414a28:	df001004 	addi	fp,sp,64
  414a2c:	e13ffc15 	stw	r4,-16(fp)
  414a30:	e17ffd15 	stw	r5,-12(fp)
  414a34:	e1bffe15 	stw	r6,-8(fp)
  414a38:	e1ffff15 	stw	r7,-4(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  414a3c:	00800804 	movi	r2,32
  414a40:	e0bff115 	stw	r2,-60(fp)
  int current_offset = 0;
  414a44:	e03ff015 	stw	zero,-64(fp)

  while (n > 0)
  414a48:	00002606 	br	414ae4 <alt_epcs_flash_memcmp+0xc8>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
  414a4c:	e0bff117 	ldw	r2,-60(fp)
  414a50:	e0ffff17 	ldw	r3,-4(fp)
  414a54:	1880012e 	bgeu	r3,r2,414a5c <alt_epcs_flash_memcmp+0x40>
  414a58:	1805883a 	mov	r2,r3
  414a5c:	e0bff215 	stw	r2,-56(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
  414a60:	e0fffe17 	ldw	r3,-8(fp)
  414a64:	e0bff017 	ldw	r2,-64(fp)
  414a68:	1887883a 	add	r3,r3,r2
  414a6c:	e0bff404 	addi	r2,fp,-48
  414a70:	e13ffc17 	ldw	r4,-16(fp)
  414a74:	180b883a 	mov	r5,r3
  414a78:	100d883a 	mov	r6,r2
  414a7c:	e1fff217 	ldw	r7,-56(fp)
  414a80:	0414ff80 	call	414ff8 <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
  414a84:	1000020e 	bge	r2,zero,414a90 <alt_epcs_flash_memcmp+0x74>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
  414a88:	00bfffc4 	movi	r2,-1
  414a8c:	00001806 	br	414af0 <alt_epcs_flash_memcmp+0xd4>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
  414a90:	e0bff017 	ldw	r2,-64(fp)
  414a94:	e0fffd17 	ldw	r3,-12(fp)
  414a98:	1889883a 	add	r4,r3,r2
  414a9c:	e0bff217 	ldw	r2,-56(fp)
  414aa0:	e0fff404 	addi	r3,fp,-48
  414aa4:	180b883a 	mov	r5,r3
  414aa8:	100d883a 	mov	r6,r2
  414aac:	04173940 	call	417394 <memcmp>
  414ab0:	e0bff315 	stw	r2,-52(fp)
    if (this_chunk_cmp)
  414ab4:	e0bff317 	ldw	r2,-52(fp)
  414ab8:	10000226 	beq	r2,zero,414ac4 <alt_epcs_flash_memcmp+0xa8>
    {
      return this_chunk_cmp;
  414abc:	e0bff317 	ldw	r2,-52(fp)
  414ac0:	00000b06 	br	414af0 <alt_epcs_flash_memcmp+0xd4>
    }

    n -= this_chunk_size;
  414ac4:	e0bff217 	ldw	r2,-56(fp)
  414ac8:	e0ffff17 	ldw	r3,-4(fp)
  414acc:	1885c83a 	sub	r2,r3,r2
  414ad0:	e0bfff15 	stw	r2,-4(fp)
    current_offset += this_chunk_size;
  414ad4:	e0fff017 	ldw	r3,-64(fp)
  414ad8:	e0bff217 	ldw	r2,-56(fp)
  414adc:	1885883a 	add	r2,r3,r2
  414ae0:	e0bff015 	stw	r2,-64(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
  414ae4:	e0bfff17 	ldw	r2,-4(fp)
  414ae8:	103fd81e 	bne	r2,zero,414a4c <_gp+0xffff4d7c>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
  414aec:	0005883a 	mov	r2,zero
}
  414af0:	e037883a 	mov	sp,fp
  414af4:	dfc00117 	ldw	ra,4(sp)
  414af8:	df000017 	ldw	fp,0(sp)
  414afc:	dec00204 	addi	sp,sp,8
  414b00:	f800283a 	ret

00414b04 <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
  414b04:	defff404 	addi	sp,sp,-48
  414b08:	dfc00b15 	stw	ra,44(sp)
  414b0c:	df000a15 	stw	fp,40(sp)
  414b10:	df000a04 	addi	fp,sp,40
  414b14:	e13ffc15 	stw	r4,-16(fp)
  414b18:	e17ffd15 	stw	r5,-12(fp)
  414b1c:	e1bffe15 	stw	r6,-8(fp)
  414b20:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
  414b24:	e03ff715 	stw	zero,-36(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  414b28:	e03ff815 	stw	zero,-32(fp)
  414b2c:	00008306 	br	414d3c <alt_epcs_flash_write+0x238>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
  414b30:	e0fffc17 	ldw	r3,-16(fp)
  414b34:	e0bff817 	ldw	r2,-32(fp)
  414b38:	1004913a 	slli	r2,r2,4
  414b3c:	10800d04 	addi	r2,r2,52
  414b40:	1885883a 	add	r2,r3,r2
  414b44:	10800017 	ldw	r2,0(r2)
  414b48:	e0fffd17 	ldw	r3,-12(fp)
  414b4c:	18807816 	blt	r3,r2,414d30 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
  414b50:	e0fffc17 	ldw	r3,-16(fp)
  414b54:	e0bff817 	ldw	r2,-32(fp)
  414b58:	1004913a 	slli	r2,r2,4
  414b5c:	10800d04 	addi	r2,r2,52
  414b60:	1885883a 	add	r2,r3,r2
  414b64:	10c00017 	ldw	r3,0(r2)
      flash_info->region_info[i].region_size)))
  414b68:	e13ffc17 	ldw	r4,-16(fp)
  414b6c:	e0bff817 	ldw	r2,-32(fp)
  414b70:	1004913a 	slli	r2,r2,4
  414b74:	10800e04 	addi	r2,r2,56
  414b78:	2085883a 	add	r2,r4,r2
  414b7c:	10800017 	ldw	r2,0(r2)
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
      (offset < (flash_info->region_info[i].offset +
  414b80:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
  414b84:	e0fffd17 	ldw	r3,-12(fp)
  414b88:	1880690e 	bge	r3,r2,414d30 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
  414b8c:	e0fffc17 	ldw	r3,-16(fp)
  414b90:	e0bff817 	ldw	r2,-32(fp)
  414b94:	1004913a 	slli	r2,r2,4
  414b98:	10800d04 	addi	r2,r2,52
  414b9c:	1885883a 	add	r2,r3,r2
  414ba0:	10800017 	ldw	r2,0(r2)
  414ba4:	e0bffa15 	stw	r2,-24(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
  414ba8:	e03ff915 	stw	zero,-28(fp)
  414bac:	00005806 	br	414d10 <alt_epcs_flash_write+0x20c>
      {
        if ((offset >= current_offset ) &&
  414bb0:	e0fffd17 	ldw	r3,-12(fp)
  414bb4:	e0bffa17 	ldw	r2,-24(fp)
  414bb8:	18804916 	blt	r3,r2,414ce0 <alt_epcs_flash_write+0x1dc>
            (offset < (current_offset +
            flash_info->region_info[i].block_size)))
  414bbc:	e0fffc17 	ldw	r3,-16(fp)
  414bc0:	e0bff817 	ldw	r2,-32(fp)
  414bc4:	10800104 	addi	r2,r2,4
  414bc8:	1004913a 	slli	r2,r2,4
  414bcc:	1885883a 	add	r2,r3,r2
  414bd0:	10c00017 	ldw	r3,0(r2)
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
            (offset < (current_offset +
  414bd4:	e0bffa17 	ldw	r2,-24(fp)
  414bd8:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
  414bdc:	e0fffd17 	ldw	r3,-12(fp)
  414be0:	18803f0e 	bge	r3,r2,414ce0 <alt_epcs_flash_write+0x1dc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
  414be4:	e0fffc17 	ldw	r3,-16(fp)
  414be8:	e0bff817 	ldw	r2,-32(fp)
  414bec:	10800104 	addi	r2,r2,4
  414bf0:	1004913a 	slli	r2,r2,4
  414bf4:	1885883a 	add	r2,r3,r2
  414bf8:	10c00017 	ldw	r3,0(r2)
  414bfc:	e0bffa17 	ldw	r2,-24(fp)
  414c00:	1887883a 	add	r3,r3,r2
  414c04:	e0bffd17 	ldw	r2,-12(fp)
  414c08:	1885c83a 	sub	r2,r3,r2
  414c0c:	e0bffb15 	stw	r2,-20(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
  414c10:	e0fffb17 	ldw	r3,-20(fp)
  414c14:	e0bfff17 	ldw	r2,-4(fp)
  414c18:	1880010e 	bge	r3,r2,414c20 <alt_epcs_flash_write+0x11c>
  414c1c:	1805883a 	mov	r2,r3
  414c20:	e0bffb15 	stw	r2,-20(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
  414c24:	e0bffb17 	ldw	r2,-20(fp)
  414c28:	e13ffc17 	ldw	r4,-16(fp)
  414c2c:	e17ffe17 	ldw	r5,-8(fp)
  414c30:	e1bffd17 	ldw	r6,-12(fp)
  414c34:	100f883a 	mov	r7,r2
  414c38:	0414a1c0 	call	414a1c <alt_epcs_flash_memcmp>
  414c3c:	10001226 	beq	r2,zero,414c88 <alt_epcs_flash_write+0x184>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
  414c40:	e0bffc17 	ldw	r2,-16(fp)
  414c44:	10800817 	ldw	r2,32(r2)
  414c48:	e13ffc17 	ldw	r4,-16(fp)
  414c4c:	e17ffa17 	ldw	r5,-24(fp)
  414c50:	103ee83a 	callr	r2
  414c54:	e0bff715 	stw	r2,-36(fp)

            if (!ret_code)
  414c58:	e0bff717 	ldw	r2,-36(fp)
  414c5c:	10000a1e 	bne	r2,zero,414c88 <alt_epcs_flash_write+0x184>
            {
              ret_code = (*flash_info->write_block)(
  414c60:	e0bffc17 	ldw	r2,-16(fp)
  414c64:	10800917 	ldw	r2,36(r2)
  414c68:	e0fffb17 	ldw	r3,-20(fp)
  414c6c:	d8c00015 	stw	r3,0(sp)
  414c70:	e13ffc17 	ldw	r4,-16(fp)
  414c74:	e17ffa17 	ldw	r5,-24(fp)
  414c78:	e1bffd17 	ldw	r6,-12(fp)
  414c7c:	e1fffe17 	ldw	r7,-8(fp)
  414c80:	103ee83a 	callr	r2
  414c84:	e0bff715 	stw	r2,-36(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
  414c88:	e0ffff17 	ldw	r3,-4(fp)
  414c8c:	e0bffb17 	ldw	r2,-20(fp)
  414c90:	18802e26 	beq	r3,r2,414d4c <alt_epcs_flash_write+0x248>
  414c94:	e0bff717 	ldw	r2,-36(fp)
  414c98:	10002c1e 	bne	r2,zero,414d4c <alt_epcs_flash_write+0x248>
          {
            goto finished;
          }

          length -= data_to_write;
  414c9c:	e0ffff17 	ldw	r3,-4(fp)
  414ca0:	e0bffb17 	ldw	r2,-20(fp)
  414ca4:	1885c83a 	sub	r2,r3,r2
  414ca8:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
  414cac:	e0fffc17 	ldw	r3,-16(fp)
  414cb0:	e0bff817 	ldw	r2,-32(fp)
  414cb4:	10800104 	addi	r2,r2,4
  414cb8:	1004913a 	slli	r2,r2,4
  414cbc:	1885883a 	add	r2,r3,r2
  414cc0:	10c00017 	ldw	r3,0(r2)
  414cc4:	e0bffa17 	ldw	r2,-24(fp)
  414cc8:	1885883a 	add	r2,r3,r2
  414ccc:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
  414cd0:	e0bffb17 	ldw	r2,-20(fp)
  414cd4:	e0fffe17 	ldw	r3,-8(fp)
  414cd8:	1885883a 	add	r2,r3,r2
  414cdc:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
  414ce0:	e0fffc17 	ldw	r3,-16(fp)
  414ce4:	e0bff817 	ldw	r2,-32(fp)
  414ce8:	10800104 	addi	r2,r2,4
  414cec:	1004913a 	slli	r2,r2,4
  414cf0:	1885883a 	add	r2,r3,r2
  414cf4:	10800017 	ldw	r2,0(r2)
  414cf8:	e0fffa17 	ldw	r3,-24(fp)
  414cfc:	1885883a 	add	r2,r3,r2
  414d00:	e0bffa15 	stw	r2,-24(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
  414d04:	e0bff917 	ldw	r2,-28(fp)
  414d08:	10800044 	addi	r2,r2,1
  414d0c:	e0bff915 	stw	r2,-28(fp)
  414d10:	e0fffc17 	ldw	r3,-16(fp)
  414d14:	e0bff817 	ldw	r2,-32(fp)
  414d18:	1004913a 	slli	r2,r2,4
  414d1c:	10800f04 	addi	r2,r2,60
  414d20:	1885883a 	add	r2,r3,r2
  414d24:	10800017 	ldw	r2,0(r2)
  414d28:	e0fff917 	ldw	r3,-28(fp)
  414d2c:	18bfa016 	blt	r3,r2,414bb0 <_gp+0xffff4ee0>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  414d30:	e0bff817 	ldw	r2,-32(fp)
  414d34:	10800044 	addi	r2,r2,1
  414d38:	e0bff815 	stw	r2,-32(fp)
  414d3c:	e0bffc17 	ldw	r2,-16(fp)
  414d40:	10800c17 	ldw	r2,48(r2)
  414d44:	e0fff817 	ldw	r3,-32(fp)
  414d48:	18bf7916 	blt	r3,r2,414b30 <_gp+0xffff4e60>
      }
    }
  }

finished:
  return ret_code;
  414d4c:	e0bff717 	ldw	r2,-36(fp)
}
  414d50:	e037883a 	mov	sp,fp
  414d54:	dfc00117 	ldw	ra,4(sp)
  414d58:	df000017 	ldw	fp,0(sp)
  414d5c:	dec00204 	addi	sp,sp,8
  414d60:	f800283a 	ret

00414d64 <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
  414d64:	defffa04 	addi	sp,sp,-24
  414d68:	df000515 	stw	fp,20(sp)
  414d6c:	df000504 	addi	fp,sp,20
  414d70:	e13ffd15 	stw	r4,-12(fp)
  414d74:	e17ffe15 	stw	r5,-8(fp)
  414d78:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
  414d7c:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
  414d80:	e0bffd17 	ldw	r2,-12(fp)
  414d84:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
  414d88:	e0bffc17 	ldw	r2,-16(fp)
  414d8c:	10c00c17 	ldw	r3,48(r2)
  414d90:	e0bfff17 	ldw	r2,-4(fp)
  414d94:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
  414d98:	e0bffc17 	ldw	r2,-16(fp)
  414d9c:	10800c17 	ldw	r2,48(r2)
  414da0:	1000031e 	bne	r2,zero,414db0 <alt_epcs_flash_get_info+0x4c>
  {
    ret_code = -EIO;
  414da4:	00bffec4 	movi	r2,-5
  414da8:	e0bffb15 	stw	r2,-20(fp)
  414dac:	00000b06 	br	414ddc <alt_epcs_flash_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
  414db0:	e0bffc17 	ldw	r2,-16(fp)
  414db4:	10800c17 	ldw	r2,48(r2)
  414db8:	10800250 	cmplti	r2,r2,9
  414dbc:	1000031e 	bne	r2,zero,414dcc <alt_epcs_flash_get_info+0x68>
  {
    ret_code = -ENOMEM;
  414dc0:	00bffd04 	movi	r2,-12
  414dc4:	e0bffb15 	stw	r2,-20(fp)
  414dc8:	00000406 	br	414ddc <alt_epcs_flash_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
  414dcc:	e0bffc17 	ldw	r2,-16(fp)
  414dd0:	10c00d04 	addi	r3,r2,52
  414dd4:	e0bffe17 	ldw	r2,-8(fp)
  414dd8:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
  414ddc:	e0bffb17 	ldw	r2,-20(fp)
}
  414de0:	e037883a 	mov	sp,fp
  414de4:	df000017 	ldw	fp,0(sp)
  414de8:	dec00104 	addi	sp,sp,4
  414dec:	f800283a 	ret

00414df0 <alt_epcs_test_address>:


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
  414df0:	defff904 	addi	sp,sp,-28
  414df4:	df000615 	stw	fp,24(sp)
  414df8:	df000604 	addi	fp,sp,24
  414dfc:	e13ffe15 	stw	r4,-8(fp)
  414e00:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
  414e04:	e03ffa15 	stw	zero,-24(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  414e08:	e0bffe17 	ldw	r2,-8(fp)
  414e0c:	e0bffb15 	stw	r2,-20(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  414e10:	e0bffb17 	ldw	r2,-20(fp)
  414e14:	10800c17 	ldw	r2,48(r2)
  414e18:	10bfffc4 	addi	r2,r2,-1
  414e1c:	e0bffc15 	stw	r2,-16(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
  414e20:	e0fffb17 	ldw	r3,-20(fp)
  414e24:	e0bffc17 	ldw	r2,-16(fp)
  414e28:	1004913a 	slli	r2,r2,4
  414e2c:	10800d04 	addi	r2,r2,52
  414e30:	1885883a 	add	r2,r3,r2
  414e34:	10800017 	ldw	r2,0(r2)
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
  414e38:	10ffffc4 	addi	r3,r2,-1
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
  414e3c:	e13ffb17 	ldw	r4,-20(fp)
  414e40:	e0bffc17 	ldw	r2,-16(fp)
  414e44:	1004913a 	slli	r2,r2,4
  414e48:	10800e04 	addi	r2,r2,56
  414e4c:	2085883a 	add	r2,r4,r2
  414e50:	10800017 	ldw	r2,0(r2)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
  414e54:	1885883a 	add	r2,r3,r2
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
  414e58:	e0bffd15 	stw	r2,-12(fp)
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
  414e5c:	e0bfff17 	ldw	r2,-4(fp)
  414e60:	e0fffd17 	ldw	r3,-12(fp)
  414e64:	1880022e 	bgeu	r3,r2,414e70 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
  414e68:	00bffec4 	movi	r2,-5
  414e6c:	e0bffa15 	stw	r2,-24(fp)
  }
  return ret_code;
  414e70:	e0bffa17 	ldw	r2,-24(fp)
}
  414e74:	e037883a 	mov	sp,fp
  414e78:	df000017 	ldw	fp,0(sp)
  414e7c:	dec00104 	addi	sp,sp,4
  414e80:	f800283a 	ret

00414e84 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
  414e84:	defffa04 	addi	sp,sp,-24
  414e88:	dfc00515 	stw	ra,20(sp)
  414e8c:	df000415 	stw	fp,16(sp)
  414e90:	df000404 	addi	fp,sp,16
  414e94:	e13ffe15 	stw	r4,-8(fp)
  414e98:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
  414e9c:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  414ea0:	e0bffe17 	ldw	r2,-8(fp)
  414ea4:	e0bffd15 	stw	r2,-12(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
  414ea8:	e13ffe17 	ldw	r4,-8(fp)
  414eac:	e17fff17 	ldw	r5,-4(fp)
  414eb0:	0414df00 	call	414df0 <alt_epcs_test_address>
  414eb4:	e0bffc15 	stw	r2,-16(fp)

  if (ret_code >= 0)
  414eb8:	e0bffc17 	ldw	r2,-16(fp)
  414ebc:	10000816 	blt	r2,zero,414ee0 <alt_epcs_flash_erase_block+0x5c>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
  414ec0:	e0bffd17 	ldw	r2,-12(fp)
  414ec4:	11002e17 	ldw	r4,184(r2)
  414ec8:	e0ffff17 	ldw	r3,-4(fp)
  414ecc:	e0bffd17 	ldw	r2,-12(fp)
  414ed0:	10803217 	ldw	r2,200(r2)
  414ed4:	180b883a 	mov	r5,r3
  414ed8:	100d883a 	mov	r6,r2
  414edc:	0415ec00 	call	415ec0 <epcs_sector_erase>
  }
  return ret_code;
  414ee0:	e0bffc17 	ldw	r2,-16(fp)
}
  414ee4:	e037883a 	mov	sp,fp
  414ee8:	dfc00117 	ldw	ra,4(sp)
  414eec:	df000017 	ldw	fp,0(sp)
  414ef0:	dec00204 	addi	sp,sp,8
  414ef4:	f800283a 	ret

00414ef8 <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
  414ef8:	defff404 	addi	sp,sp,-48
  414efc:	dfc00b15 	stw	ra,44(sp)
  414f00:	df000a15 	stw	fp,40(sp)
  414f04:	df000a04 	addi	fp,sp,40
  414f08:	e13ffc15 	stw	r4,-16(fp)
  414f0c:	e17ffd15 	stw	r5,-12(fp)
  414f10:	e1bffe15 	stw	r6,-8(fp)
  414f14:	e1ffff15 	stw	r7,-4(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  414f18:	e0bffc17 	ldw	r2,-16(fp)
  414f1c:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
  414f20:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
  414f24:	e13ffc17 	ldw	r4,-16(fp)
  414f28:	e17ffe17 	ldw	r5,-8(fp)
  414f2c:	0414df00 	call	414df0 <alt_epcs_test_address>
  414f30:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
  414f34:	e0bff917 	ldw	r2,-28(fp)
  414f38:	10002916 	blt	r2,zero,414fe0 <alt_epcs_flash_write_block+0xe8>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
  414f3c:	00002606 	br	414fd8 <alt_epcs_flash_write_block+0xe0>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
  414f40:	e0bff817 	ldw	r2,-32(fp)
  414f44:	10c03117 	ldw	r3,196(r2)
  414f48:	e0bffe17 	ldw	r2,-8(fp)
  414f4c:	1887883a 	add	r3,r3,r2
  414f50:	e0bff817 	ldw	r2,-32(fp)
  414f54:	10803117 	ldw	r2,196(r2)
  414f58:	0085c83a 	sub	r2,zero,r2
  414f5c:	1884703a 	and	r2,r3,r2
  414f60:	e0bffa15 	stw	r2,-24(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
  414f64:	e0fffa17 	ldw	r3,-24(fp)
  414f68:	e0bffe17 	ldw	r2,-8(fp)
  414f6c:	1885c83a 	sub	r2,r3,r2
  414f70:	e0c00217 	ldw	r3,8(fp)
  414f74:	1880010e 	bge	r3,r2,414f7c <alt_epcs_flash_write_block+0x84>
  414f78:	1805883a 	mov	r2,r3
  414f7c:	e0bffb15 	stw	r2,-20(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
  414f80:	e0bff817 	ldw	r2,-32(fp)
  414f84:	11002e17 	ldw	r4,184(r2)
  414f88:	e0bff717 	ldw	r2,-36(fp)
  414f8c:	e0ffff17 	ldw	r3,-4(fp)
  414f90:	1887883a 	add	r3,r3,r2
  414f94:	e0bff817 	ldw	r2,-32(fp)
  414f98:	10803217 	ldw	r2,200(r2)
  414f9c:	d8800015 	stw	r2,0(sp)
  414fa0:	e17ffe17 	ldw	r5,-8(fp)
  414fa4:	180d883a 	mov	r6,r3
  414fa8:	e1fffb17 	ldw	r7,-20(fp)
  414fac:	04161640 	call	416164 <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
  414fb0:	e0c00217 	ldw	r3,8(fp)
  414fb4:	e0bffb17 	ldw	r2,-20(fp)
  414fb8:	1885c83a 	sub	r2,r3,r2
  414fbc:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
  414fc0:	e0fff717 	ldw	r3,-36(fp)
  414fc4:	e0bffb17 	ldw	r2,-20(fp)
  414fc8:	1885883a 	add	r2,r3,r2
  414fcc:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
  414fd0:	e0bffa17 	ldw	r2,-24(fp)
  414fd4:	e0bffe15 	stw	r2,-8(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
  414fd8:	e0800217 	ldw	r2,8(fp)
  414fdc:	103fd81e 	bne	r2,zero,414f40 <_gp+0xffff5270>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
  414fe0:	e0bff917 	ldw	r2,-28(fp)
}
  414fe4:	e037883a 	mov	sp,fp
  414fe8:	dfc00117 	ldw	ra,4(sp)
  414fec:	df000017 	ldw	fp,0(sp)
  414ff0:	dec00204 	addi	sp,sp,8
  414ff4:	f800283a 	ret

00414ff8 <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
  414ff8:	defff704 	addi	sp,sp,-36
  414ffc:	dfc00815 	stw	ra,32(sp)
  415000:	df000715 	stw	fp,28(sp)
  415004:	df000704 	addi	fp,sp,28
  415008:	e13ffc15 	stw	r4,-16(fp)
  41500c:	e17ffd15 	stw	r5,-12(fp)
  415010:	e1bffe15 	stw	r6,-8(fp)
  415014:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
  415018:	e03ffa15 	stw	zero,-24(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  41501c:	e0bffc17 	ldw	r2,-16(fp)
  415020:	e0bffb15 	stw	r2,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
  415024:	e13ffc17 	ldw	r4,-16(fp)
  415028:	e17ffd17 	ldw	r5,-12(fp)
  41502c:	0414df00 	call	414df0 <alt_epcs_test_address>
  415030:	e0bffa15 	stw	r2,-24(fp)

  if (ret_code >= 0)
  415034:	e0bffa17 	ldw	r2,-24(fp)
  415038:	10000f16 	blt	r2,zero,415078 <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
  41503c:	e0bffb17 	ldw	r2,-20(fp)
  415040:	10c02e17 	ldw	r3,184(r2)
  415044:	e0bffb17 	ldw	r2,-20(fp)
  415048:	10803217 	ldw	r2,200(r2)
  41504c:	d8800015 	stw	r2,0(sp)
  415050:	1809883a 	mov	r4,r3
  415054:	e17ffd17 	ldw	r5,-12(fp)
  415058:	e1bffe17 	ldw	r6,-8(fp)
  41505c:	e1ffff17 	ldw	r7,-4(fp)
  415060:	0415fb80 	call	415fb8 <epcs_read_buffer>
  415064:	e0bffa15 	stw	r2,-24(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
  415068:	e0fffa17 	ldw	r3,-24(fp)
  41506c:	e0bfff17 	ldw	r2,-4(fp)
  415070:	1880011e 	bne	r3,r2,415078 <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
  415074:	e03ffa15 	stw	zero,-24(fp)
    }
  }
  return ret_code;
  415078:	e0bffa17 	ldw	r2,-24(fp)
}
  41507c:	e037883a 	mov	sp,fp
  415080:	dfc00117 	ldw	ra,4(sp)
  415084:	df000017 	ldw	fp,0(sp)
  415088:	dec00204 	addi	sp,sp,8
  41508c:	f800283a 	ret

00415090 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  415090:	defffa04 	addi	sp,sp,-24
  415094:	dfc00515 	stw	ra,20(sp)
  415098:	df000415 	stw	fp,16(sp)
  41509c:	df000404 	addi	fp,sp,16
  4150a0:	e13ffd15 	stw	r4,-12(fp)
  4150a4:	e17ffe15 	stw	r5,-8(fp)
  4150a8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  4150ac:	e0bffd17 	ldw	r2,-12(fp)
  4150b0:	10800017 	ldw	r2,0(r2)
  4150b4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  4150b8:	e0bffc17 	ldw	r2,-16(fp)
  4150bc:	10c00a04 	addi	r3,r2,40
  4150c0:	e0bffd17 	ldw	r2,-12(fp)
  4150c4:	10800217 	ldw	r2,8(r2)
  4150c8:	1809883a 	mov	r4,r3
  4150cc:	e17ffe17 	ldw	r5,-8(fp)
  4150d0:	e1bfff17 	ldw	r6,-4(fp)
  4150d4:	100f883a 	mov	r7,r2
  4150d8:	04151500 	call	415150 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  4150dc:	e037883a 	mov	sp,fp
  4150e0:	dfc00117 	ldw	ra,4(sp)
  4150e4:	df000017 	ldw	fp,0(sp)
  4150e8:	dec00204 	addi	sp,sp,8
  4150ec:	f800283a 	ret

004150f0 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  4150f0:	defffa04 	addi	sp,sp,-24
  4150f4:	dfc00515 	stw	ra,20(sp)
  4150f8:	df000415 	stw	fp,16(sp)
  4150fc:	df000404 	addi	fp,sp,16
  415100:	e13ffd15 	stw	r4,-12(fp)
  415104:	e17ffe15 	stw	r5,-8(fp)
  415108:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  41510c:	e0bffd17 	ldw	r2,-12(fp)
  415110:	10800017 	ldw	r2,0(r2)
  415114:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  415118:	e0bffc17 	ldw	r2,-16(fp)
  41511c:	10c00a04 	addi	r3,r2,40
  415120:	e0bffd17 	ldw	r2,-12(fp)
  415124:	10800217 	ldw	r2,8(r2)
  415128:	1809883a 	mov	r4,r3
  41512c:	e17ffe17 	ldw	r5,-8(fp)
  415130:	e1bfff17 	ldw	r6,-4(fp)
  415134:	100f883a 	mov	r7,r2
  415138:	04152340 	call	415234 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  41513c:	e037883a 	mov	sp,fp
  415140:	dfc00117 	ldw	ra,4(sp)
  415144:	df000017 	ldw	fp,0(sp)
  415148:	dec00204 	addi	sp,sp,8
  41514c:	f800283a 	ret

00415150 <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
  415150:	defff704 	addi	sp,sp,-36
  415154:	df000815 	stw	fp,32(sp)
  415158:	df000804 	addi	fp,sp,32
  41515c:	e13ffc15 	stw	r4,-16(fp)
  415160:	e17ffd15 	stw	r5,-12(fp)
  415164:	e1bffe15 	stw	r6,-8(fp)
  415168:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
  41516c:	e0bffc17 	ldw	r2,-16(fp)
  415170:	10800017 	ldw	r2,0(r2)
  415174:	e0bff915 	stw	r2,-28(fp)

  char * ptr = buffer;
  415178:	e0bffd17 	ldw	r2,-12(fp)
  41517c:	e0bff815 	stw	r2,-32(fp)
  char * end = buffer + space;
  415180:	e0bffe17 	ldw	r2,-8(fp)
  415184:	e0fffd17 	ldw	r3,-12(fp)
  415188:	1885883a 	add	r2,r3,r2
  41518c:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
  415190:	00001406 	br	4151e4 <altera_avalon_jtag_uart_read+0x94>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  415194:	e0bff917 	ldw	r2,-28(fp)
  415198:	10800037 	ldwio	r2,0(r2)
  41519c:	e0bffb15 	stw	r2,-20(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
  4151a0:	e0bffb17 	ldw	r2,-20(fp)
  4151a4:	10a0000c 	andi	r2,r2,32768
  4151a8:	10000626 	beq	r2,zero,4151c4 <altera_avalon_jtag_uart_read+0x74>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  4151ac:	e0bff817 	ldw	r2,-32(fp)
  4151b0:	10c00044 	addi	r3,r2,1
  4151b4:	e0fff815 	stw	r3,-32(fp)
  4151b8:	e0fffb17 	ldw	r3,-20(fp)
  4151bc:	10c00005 	stb	r3,0(r2)
  4151c0:	00000806 	br	4151e4 <altera_avalon_jtag_uart_read+0x94>
    else if (ptr != buffer)
  4151c4:	e0fff817 	ldw	r3,-32(fp)
  4151c8:	e0bffd17 	ldw	r2,-12(fp)
  4151cc:	18800126 	beq	r3,r2,4151d4 <altera_avalon_jtag_uart_read+0x84>
      break;
  4151d0:	00000706 	br	4151f0 <altera_avalon_jtag_uart_read+0xa0>
    else if(flags & O_NONBLOCK)
  4151d4:	e0bfff17 	ldw	r2,-4(fp)
  4151d8:	1090000c 	andi	r2,r2,16384
  4151dc:	10000126 	beq	r2,zero,4151e4 <altera_avalon_jtag_uart_read+0x94>
      break;   
  4151e0:	00000306 	br	4151f0 <altera_avalon_jtag_uart_read+0xa0>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
  4151e4:	e0fff817 	ldw	r3,-32(fp)
  4151e8:	e0bffa17 	ldw	r2,-24(fp)
  4151ec:	18bfe936 	bltu	r3,r2,415194 <_gp+0xffff54c4>
    else if(flags & O_NONBLOCK)
      break;   
    
  }

  if (ptr != buffer)
  4151f0:	e0fff817 	ldw	r3,-32(fp)
  4151f4:	e0bffd17 	ldw	r2,-12(fp)
  4151f8:	18800426 	beq	r3,r2,41520c <altera_avalon_jtag_uart_read+0xbc>
    return ptr - buffer;
  4151fc:	e0fff817 	ldw	r3,-32(fp)
  415200:	e0bffd17 	ldw	r2,-12(fp)
  415204:	1885c83a 	sub	r2,r3,r2
  415208:	00000606 	br	415224 <altera_avalon_jtag_uart_read+0xd4>
  else if (flags & O_NONBLOCK)
  41520c:	e0bfff17 	ldw	r2,-4(fp)
  415210:	1090000c 	andi	r2,r2,16384
  415214:	10000226 	beq	r2,zero,415220 <altera_avalon_jtag_uart_read+0xd0>
    return -EWOULDBLOCK;
  415218:	00bffd44 	movi	r2,-11
  41521c:	00000106 	br	415224 <altera_avalon_jtag_uart_read+0xd4>
  else
    return -EIO;
  415220:	00bffec4 	movi	r2,-5
}
  415224:	e037883a 	mov	sp,fp
  415228:	df000017 	ldw	fp,0(sp)
  41522c:	dec00104 	addi	sp,sp,4
  415230:	f800283a 	ret

00415234 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  415234:	defff904 	addi	sp,sp,-28
  415238:	df000615 	stw	fp,24(sp)
  41523c:	df000604 	addi	fp,sp,24
  415240:	e13ffc15 	stw	r4,-16(fp)
  415244:	e17ffd15 	stw	r5,-12(fp)
  415248:	e1bffe15 	stw	r6,-8(fp)
  41524c:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
  415250:	e0bffc17 	ldw	r2,-16(fp)
  415254:	10800017 	ldw	r2,0(r2)
  415258:	e0bffa15 	stw	r2,-24(fp)

  const char * end = ptr + count;
  41525c:	e0bffe17 	ldw	r2,-8(fp)
  415260:	e0fffd17 	ldw	r3,-12(fp)
  415264:	1885883a 	add	r2,r3,r2
  415268:	e0bffb15 	stw	r2,-20(fp)

  while (ptr < end)
  41526c:	00000e06 	br	4152a8 <altera_avalon_jtag_uart_write+0x74>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  415270:	e0bffa17 	ldw	r2,-24(fp)
  415274:	10800104 	addi	r2,r2,4
  415278:	10800037 	ldwio	r2,0(r2)
  41527c:	10bfffec 	andhi	r2,r2,65535
  415280:	10000926 	beq	r2,zero,4152a8 <altera_avalon_jtag_uart_write+0x74>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
  415284:	e0fffa17 	ldw	r3,-24(fp)
  415288:	e0bffd17 	ldw	r2,-12(fp)
  41528c:	11000044 	addi	r4,r2,1
  415290:	e13ffd15 	stw	r4,-12(fp)
  415294:	10800003 	ldbu	r2,0(r2)
  415298:	10803fcc 	andi	r2,r2,255
  41529c:	1080201c 	xori	r2,r2,128
  4152a0:	10bfe004 	addi	r2,r2,-128
  4152a4:	18800035 	stwio	r2,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
  4152a8:	e0fffd17 	ldw	r3,-12(fp)
  4152ac:	e0bffb17 	ldw	r2,-20(fp)
  4152b0:	18bfef36 	bltu	r3,r2,415270 <_gp+0xffff55a0>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
  4152b4:	e0bffe17 	ldw	r2,-8(fp)
}
  4152b8:	e037883a 	mov	sp,fp
  4152bc:	df000017 	ldw	fp,0(sp)
  4152c0:	dec00104 	addi	sp,sp,4
  4152c4:	f800283a 	ret

004152c8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  4152c8:	defffa04 	addi	sp,sp,-24
  4152cc:	dfc00515 	stw	ra,20(sp)
  4152d0:	df000415 	stw	fp,16(sp)
  4152d4:	df000404 	addi	fp,sp,16
  4152d8:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  4152dc:	0007883a 	mov	r3,zero
  4152e0:	e0bfff17 	ldw	r2,-4(fp)
  4152e4:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  4152e8:	e0bfff17 	ldw	r2,-4(fp)
  4152ec:	10800104 	addi	r2,r2,4
  4152f0:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4152f4:	0005303a 	rdctl	r2,status
  4152f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4152fc:	e0fffd17 	ldw	r3,-12(fp)
  415300:	00bfff84 	movi	r2,-2
  415304:	1884703a 	and	r2,r3,r2
  415308:	1001703a 	wrctl	status,r2
  
  return context;
  41530c:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  415310:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
  415314:	0416dc00 	call	416dc0 <alt_tick>
  415318:	e0bffc17 	ldw	r2,-16(fp)
  41531c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  415320:	e0bffe17 	ldw	r2,-8(fp)
  415324:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  415328:	e037883a 	mov	sp,fp
  41532c:	dfc00117 	ldw	ra,4(sp)
  415330:	df000017 	ldw	fp,0(sp)
  415334:	dec00204 	addi	sp,sp,8
  415338:	f800283a 	ret

0041533c <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  41533c:	defff804 	addi	sp,sp,-32
  415340:	dfc00715 	stw	ra,28(sp)
  415344:	df000615 	stw	fp,24(sp)
  415348:	df000604 	addi	fp,sp,24
  41534c:	e13ffc15 	stw	r4,-16(fp)
  415350:	e17ffd15 	stw	r5,-12(fp)
  415354:	e1bffe15 	stw	r6,-8(fp)
  415358:	e1ffff15 	stw	r7,-4(fp)
  41535c:	e0bfff17 	ldw	r2,-4(fp)
  415360:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  415364:	008010b4 	movhi	r2,66
  415368:	10a07004 	addi	r2,r2,-32320
  41536c:	10800017 	ldw	r2,0(r2)
  415370:	1000041e 	bne	r2,zero,415384 <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
  415374:	008010b4 	movhi	r2,66
  415378:	10a07004 	addi	r2,r2,-32320
  41537c:	e0fffb17 	ldw	r3,-20(fp)
  415380:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  415384:	e0bffc17 	ldw	r2,-16(fp)
  415388:	10800104 	addi	r2,r2,4
  41538c:	00c001c4 	movi	r3,7
  415390:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  415394:	d8000015 	stw	zero,0(sp)
  415398:	e13ffd17 	ldw	r4,-12(fp)
  41539c:	e17ffe17 	ldw	r5,-8(fp)
  4153a0:	01801074 	movhi	r6,65
  4153a4:	3194b204 	addi	r6,r6,21192
  4153a8:	e1fffc17 	ldw	r7,-16(fp)
  4153ac:	0413f140 	call	413f14 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  4153b0:	e037883a 	mov	sp,fp
  4153b4:	dfc00117 	ldw	ra,4(sp)
  4153b8:	df000017 	ldw	fp,0(sp)
  4153bc:	dec00204 	addi	sp,sp,8
  4153c0:	f800283a 	ret

004153c4 <alt_timestamp_start>:
 * The return value of this function is 0 upon sucess and -1 if in timestamp
 * device has not been registered. 
 */

int alt_timestamp_start(void)
{
  4153c4:	defffe04 	addi	sp,sp,-8
  4153c8:	df000115 	stw	fp,4(sp)
  4153cc:	df000104 	addi	fp,sp,4
  void* base = altera_avalon_timer_ts_base;
  4153d0:	008010b4 	movhi	r2,66
  4153d4:	10a06d04 	addi	r2,r2,-32332
  4153d8:	10800017 	ldw	r2,0(r2)
  4153dc:	e0bfff15 	stw	r2,-4(fp)

  if (!altera_avalon_timer_ts_freq)
  4153e0:	008010b4 	movhi	r2,66
  4153e4:	10a06e04 	addi	r2,r2,-32328
  4153e8:	10800017 	ldw	r2,0(r2)
  4153ec:	1000021e 	bne	r2,zero,4153f8 <alt_timestamp_start+0x34>
  {
    return -1;
  4153f0:	00bfffc4 	movi	r2,-1
  4153f4:	00001106 	br	41543c <alt_timestamp_start+0x78>
        IOWR_ALTERA_AVALON_TIMER_PERIOD_1 (base, 0xFFFF);;
        IOWR_ALTERA_AVALON_TIMER_PERIOD_2 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_PERIOD_3 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK);
    } else {
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base,ALTERA_AVALON_TIMER_CONTROL_STOP_MSK);
  4153f8:	e0bfff17 	ldw	r2,-4(fp)
  4153fc:	10800104 	addi	r2,r2,4
  415400:	00c00204 	movi	r3,8
  415404:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIODL (base, 0xFFFF);
  415408:	e0bfff17 	ldw	r2,-4(fp)
  41540c:	10800204 	addi	r2,r2,8
  415410:	00ffffd4 	movui	r3,65535
  415414:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIODH (base, 0xFFFF);
  415418:	e0bfff17 	ldw	r2,-4(fp)
  41541c:	10800304 	addi	r2,r2,12
  415420:	00ffffd4 	movui	r3,65535
  415424:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK); 
  415428:	e0bfff17 	ldw	r2,-4(fp)
  41542c:	10800104 	addi	r2,r2,4
  415430:	00c00104 	movi	r3,4
  415434:	10c00035 	stwio	r3,0(r2)
    } 
  }
  return 0;
  415438:	0005883a 	mov	r2,zero
}
  41543c:	e037883a 	mov	sp,fp
  415440:	df000017 	ldw	fp,0(sp)
  415444:	dec00104 	addi	sp,sp,4
  415448:	f800283a 	ret

0041544c <alt_timestamp>:
 * The returned timestamp counts up from the last time the period register
 * was reset. 
 */

alt_timestamp_type alt_timestamp(void)
{
  41544c:	defffc04 	addi	sp,sp,-16
  415450:	df000315 	stw	fp,12(sp)
  415454:	df000304 	addi	fp,sp,12

  void* base = altera_avalon_timer_ts_base;
  415458:	008010b4 	movhi	r2,66
  41545c:	10a06d04 	addi	r2,r2,-32332
  415460:	10800017 	ldw	r2,0(r2)
  415464:	e0bffd15 	stw	r2,-12(fp)

  if (!altera_avalon_timer_ts_freq)
  415468:	008010b4 	movhi	r2,66
  41546c:	10a06e04 	addi	r2,r2,-32328
  415470:	10800017 	ldw	r2,0(r2)
  415474:	1000021e 	bne	r2,zero,415480 <alt_timestamp+0x34>
  {
#if (ALT_TIMESTAMP_COUNTER_SIZE == 64)
        return 0xFFFFFFFFFFFFFFFFULL;
#else
        return 0xFFFFFFFF;
  415478:	00bfffc4 	movi	r2,-1
  41547c:	00001306 	br	4154cc <alt_timestamp+0x80>
        alt_timestamp_type snap_2 = IORD_ALTERA_AVALON_TIMER_SNAP_2(base) & ALTERA_AVALON_TIMER_SNAP_2_MSK;
        alt_timestamp_type snap_3 = IORD_ALTERA_AVALON_TIMER_SNAP_3(base) & ALTERA_AVALON_TIMER_SNAP_3_MSK;
        
        return (0xFFFFFFFFFFFFFFFFULL - ( (snap_3 << 48) | (snap_2 << 32) | (snap_1 << 16) | (snap_0) ));
#else
        IOWR_ALTERA_AVALON_TIMER_SNAPL (base, 0);
  415480:	e0bffd17 	ldw	r2,-12(fp)
  415484:	10800404 	addi	r2,r2,16
  415488:	0007883a 	mov	r3,zero
  41548c:	10c00035 	stwio	r3,0(r2)
        alt_timestamp_type lower = IORD_ALTERA_AVALON_TIMER_SNAPL(base) & ALTERA_AVALON_TIMER_SNAPL_MSK;
  415490:	e0bffd17 	ldw	r2,-12(fp)
  415494:	10800404 	addi	r2,r2,16
  415498:	10800037 	ldwio	r2,0(r2)
  41549c:	10bfffcc 	andi	r2,r2,65535
  4154a0:	e0bffe15 	stw	r2,-8(fp)
        alt_timestamp_type upper = IORD_ALTERA_AVALON_TIMER_SNAPH(base) & ALTERA_AVALON_TIMER_SNAPH_MSK;
  4154a4:	e0bffd17 	ldw	r2,-12(fp)
  4154a8:	10800504 	addi	r2,r2,20
  4154ac:	10800037 	ldwio	r2,0(r2)
  4154b0:	10bfffcc 	andi	r2,r2,65535
  4154b4:	e0bfff15 	stw	r2,-4(fp)
        
        return (0xFFFFFFFF - ((upper << 16) | lower)); 
  4154b8:	e0bfff17 	ldw	r2,-4(fp)
  4154bc:	1006943a 	slli	r3,r2,16
  4154c0:	e0bffe17 	ldw	r2,-8(fp)
  4154c4:	1884b03a 	or	r2,r3,r2
  4154c8:	0084303a 	nor	r2,zero,r2
#endif
  }
}
  4154cc:	e037883a 	mov	sp,fp
  4154d0:	df000017 	ldw	fp,0(sp)
  4154d4:	dec00104 	addi	sp,sp,4
  4154d8:	f800283a 	ret

004154dc <alt_timestamp_freq>:
 * Return the number of timestamp ticks per second. This will be 0 if no
 * timestamp device has been registered.
 */

alt_u32 alt_timestamp_freq(void)
{
  4154dc:	deffff04 	addi	sp,sp,-4
  4154e0:	df000015 	stw	fp,0(sp)
  4154e4:	d839883a 	mov	fp,sp
  return altera_avalon_timer_ts_freq;
  4154e8:	008010b4 	movhi	r2,66
  4154ec:	10a06e04 	addi	r2,r2,-32328
  4154f0:	10800017 	ldw	r2,0(r2)
}
  4154f4:	e037883a 	mov	sp,fp
  4154f8:	df000017 	ldw	fp,0(sp)
  4154fc:	dec00104 	addi	sp,sp,4
  415500:	f800283a 	ret

00415504 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  415504:	defffa04 	addi	sp,sp,-24
  415508:	dfc00515 	stw	ra,20(sp)
  41550c:	df000415 	stw	fp,16(sp)
  415510:	df000404 	addi	fp,sp,16
  415514:	e13ffd15 	stw	r4,-12(fp)
  415518:	e17ffe15 	stw	r5,-8(fp)
  41551c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  415520:	e0bffd17 	ldw	r2,-12(fp)
  415524:	10800017 	ldw	r2,0(r2)
  415528:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
  41552c:	e0bffc17 	ldw	r2,-16(fp)
  415530:	10c00a04 	addi	r3,r2,40
  415534:	e0bffd17 	ldw	r2,-12(fp)
  415538:	10800217 	ldw	r2,8(r2)
  41553c:	1809883a 	mov	r4,r3
  415540:	e17ffe17 	ldw	r5,-8(fp)
  415544:	e1bfff17 	ldw	r6,-4(fp)
  415548:	100f883a 	mov	r7,r2
  41554c:	0415a1c0 	call	415a1c <altera_avalon_uart_read>
      fd->fd_flags);
}
  415550:	e037883a 	mov	sp,fp
  415554:	dfc00117 	ldw	ra,4(sp)
  415558:	df000017 	ldw	fp,0(sp)
  41555c:	dec00204 	addi	sp,sp,8
  415560:	f800283a 	ret

00415564 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  415564:	defffa04 	addi	sp,sp,-24
  415568:	dfc00515 	stw	ra,20(sp)
  41556c:	df000415 	stw	fp,16(sp)
  415570:	df000404 	addi	fp,sp,16
  415574:	e13ffd15 	stw	r4,-12(fp)
  415578:	e17ffe15 	stw	r5,-8(fp)
  41557c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  415580:	e0bffd17 	ldw	r2,-12(fp)
  415584:	10800017 	ldw	r2,0(r2)
  415588:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
  41558c:	e0bffc17 	ldw	r2,-16(fp)
  415590:	10c00a04 	addi	r3,r2,40
  415594:	e0bffd17 	ldw	r2,-12(fp)
  415598:	10800217 	ldw	r2,8(r2)
  41559c:	1809883a 	mov	r4,r3
  4155a0:	e17ffe17 	ldw	r5,-8(fp)
  4155a4:	e1bfff17 	ldw	r6,-4(fp)
  4155a8:	100f883a 	mov	r7,r2
  4155ac:	0415c480 	call	415c48 <altera_avalon_uart_write>
      fd->fd_flags);
}
  4155b0:	e037883a 	mov	sp,fp
  4155b4:	dfc00117 	ldw	ra,4(sp)
  4155b8:	df000017 	ldw	fp,0(sp)
  4155bc:	dec00204 	addi	sp,sp,8
  4155c0:	f800283a 	ret

004155c4 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
  4155c4:	defffc04 	addi	sp,sp,-16
  4155c8:	dfc00315 	stw	ra,12(sp)
  4155cc:	df000215 	stw	fp,8(sp)
  4155d0:	df000204 	addi	fp,sp,8
  4155d4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  4155d8:	e0bfff17 	ldw	r2,-4(fp)
  4155dc:	10800017 	ldw	r2,0(r2)
  4155e0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
  4155e4:	e0bffe17 	ldw	r2,-8(fp)
  4155e8:	10c00a04 	addi	r3,r2,40
  4155ec:	e0bfff17 	ldw	r2,-4(fp)
  4155f0:	10800217 	ldw	r2,8(r2)
  4155f4:	1809883a 	mov	r4,r3
  4155f8:	100b883a 	mov	r5,r2
  4155fc:	04159780 	call	415978 <altera_avalon_uart_close>
}
  415600:	e037883a 	mov	sp,fp
  415604:	dfc00117 	ldw	ra,4(sp)
  415608:	df000017 	ldw	fp,0(sp)
  41560c:	dec00204 	addi	sp,sp,8
  415610:	f800283a 	ret

00415614 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
  415614:	defff804 	addi	sp,sp,-32
  415618:	dfc00715 	stw	ra,28(sp)
  41561c:	df000615 	stw	fp,24(sp)
  415620:	df000604 	addi	fp,sp,24
  415624:	e13ffd15 	stw	r4,-12(fp)
  415628:	e17ffe15 	stw	r5,-8(fp)
  41562c:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
  415630:	e0bffd17 	ldw	r2,-12(fp)
  415634:	10800017 	ldw	r2,0(r2)
  415638:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
  41563c:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  415640:	1000041e 	bne	r2,zero,415654 <altera_avalon_uart_init+0x40>
  415644:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  415648:	1000021e 	bne	r2,zero,415654 <altera_avalon_uart_init+0x40>
  41564c:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  415650:	10000226 	beq	r2,zero,41565c <altera_avalon_uart_init+0x48>
  415654:	00800044 	movi	r2,1
  415658:	00000106 	br	415660 <altera_avalon_uart_init+0x4c>
  41565c:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  415660:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
  415664:	e0bffc17 	ldw	r2,-16(fp)
  415668:	10000f1e 	bne	r2,zero,4156a8 <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
  41566c:	e0bffd17 	ldw	r2,-12(fp)
  415670:	00c32004 	movi	r3,3200
  415674:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
  415678:	e0bffb17 	ldw	r2,-20(fp)
  41567c:	10800304 	addi	r2,r2,12
  415680:	e0fffd17 	ldw	r3,-12(fp)
  415684:	18c00117 	ldw	r3,4(r3)
  415688:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
  41568c:	d8000015 	stw	zero,0(sp)
  415690:	e13ffe17 	ldw	r4,-8(fp)
  415694:	e17fff17 	ldw	r5,-4(fp)
  415698:	01801074 	movhi	r6,65
  41569c:	3195af04 	addi	r6,r6,22204
  4156a0:	e1fffd17 	ldw	r7,-12(fp)
  4156a4:	0413f140 	call	413f14 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
  4156a8:	e037883a 	mov	sp,fp
  4156ac:	dfc00117 	ldw	ra,4(sp)
  4156b0:	df000017 	ldw	fp,0(sp)
  4156b4:	dec00204 	addi	sp,sp,8
  4156b8:	f800283a 	ret

004156bc <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
  4156bc:	defffa04 	addi	sp,sp,-24
  4156c0:	dfc00515 	stw	ra,20(sp)
  4156c4:	df000415 	stw	fp,16(sp)
  4156c8:	df000404 	addi	fp,sp,16
  4156cc:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
  4156d0:	e0bfff17 	ldw	r2,-4(fp)
  4156d4:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
  4156d8:	e0bffc17 	ldw	r2,-16(fp)
  4156dc:	10800017 	ldw	r2,0(r2)
  4156e0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
  4156e4:	e0bffd17 	ldw	r2,-12(fp)
  4156e8:	10800204 	addi	r2,r2,8
  4156ec:	10800037 	ldwio	r2,0(r2)
  4156f0:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
  4156f4:	e0bffd17 	ldw	r2,-12(fp)
  4156f8:	10800204 	addi	r2,r2,8
  4156fc:	0007883a 	mov	r3,zero
  415700:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
  415704:	e0bffd17 	ldw	r2,-12(fp)
  415708:	10800204 	addi	r2,r2,8
  41570c:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  415710:	e0bffe17 	ldw	r2,-8(fp)
  415714:	1080200c 	andi	r2,r2,128
  415718:	10000326 	beq	r2,zero,415728 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
  41571c:	e13ffc17 	ldw	r4,-16(fp)
  415720:	e17ffe17 	ldw	r5,-8(fp)
  415724:	04157540 	call	415754 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
  415728:	e0bffe17 	ldw	r2,-8(fp)
  41572c:	1081100c 	andi	r2,r2,1088
  415730:	10000326 	beq	r2,zero,415740 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
  415734:	e13ffc17 	ldw	r4,-16(fp)
  415738:	e17ffe17 	ldw	r5,-8(fp)
  41573c:	04158340 	call	415834 <altera_avalon_uart_txirq>
  }
  

}
  415740:	e037883a 	mov	sp,fp
  415744:	dfc00117 	ldw	ra,4(sp)
  415748:	df000017 	ldw	fp,0(sp)
  41574c:	dec00204 	addi	sp,sp,8
  415750:	f800283a 	ret

00415754 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  415754:	defffc04 	addi	sp,sp,-16
  415758:	df000315 	stw	fp,12(sp)
  41575c:	df000304 	addi	fp,sp,12
  415760:	e13ffe15 	stw	r4,-8(fp)
  415764:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
  415768:	e0bfff17 	ldw	r2,-4(fp)
  41576c:	108000cc 	andi	r2,r2,3
  415770:	10000126 	beq	r2,zero,415778 <altera_avalon_uart_rxirq+0x24>
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
  415774:	00002b06 	br	415824 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
  415778:	e0bffe17 	ldw	r2,-8(fp)
  41577c:	10800317 	ldw	r2,12(r2)
  415780:	e0bffe17 	ldw	r2,-8(fp)
  415784:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  415788:	e0bffe17 	ldw	r2,-8(fp)
  41578c:	10800317 	ldw	r2,12(r2)
  415790:	10800044 	addi	r2,r2,1
  415794:	10800fcc 	andi	r2,r2,63
  415798:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
  41579c:	e0bffe17 	ldw	r2,-8(fp)
  4157a0:	10800317 	ldw	r2,12(r2)
  4157a4:	e0fffe17 	ldw	r3,-8(fp)
  4157a8:	18c00017 	ldw	r3,0(r3)
  4157ac:	18c00037 	ldwio	r3,0(r3)
  4157b0:	1809883a 	mov	r4,r3
  4157b4:	e0fffe17 	ldw	r3,-8(fp)
  4157b8:	1885883a 	add	r2,r3,r2
  4157bc:	10800704 	addi	r2,r2,28
  4157c0:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
  4157c4:	e0bffe17 	ldw	r2,-8(fp)
  4157c8:	e0fffd17 	ldw	r3,-12(fp)
  4157cc:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  4157d0:	e0bffe17 	ldw	r2,-8(fp)
  4157d4:	10800317 	ldw	r2,12(r2)
  4157d8:	10800044 	addi	r2,r2,1
  4157dc:	10800fcc 	andi	r2,r2,63
  4157e0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
  4157e4:	e0bffe17 	ldw	r2,-8(fp)
  4157e8:	10c00217 	ldw	r3,8(r2)
  4157ec:	e0bffd17 	ldw	r2,-12(fp)
  4157f0:	18800c1e 	bne	r3,r2,415824 <altera_avalon_uart_rxirq+0xd0>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  4157f4:	e0bffe17 	ldw	r2,-8(fp)
  4157f8:	10c00117 	ldw	r3,4(r2)
  4157fc:	00bfdfc4 	movi	r2,-129
  415800:	1886703a 	and	r3,r3,r2
  415804:	e0bffe17 	ldw	r2,-8(fp)
  415808:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  41580c:	e0bffe17 	ldw	r2,-8(fp)
  415810:	10800017 	ldw	r2,0(r2)
  415814:	10800304 	addi	r2,r2,12
  415818:	e0fffe17 	ldw	r3,-8(fp)
  41581c:	18c00117 	ldw	r3,4(r3)
  415820:	10c00035 	stwio	r3,0(r2)
  }   
}
  415824:	e037883a 	mov	sp,fp
  415828:	df000017 	ldw	fp,0(sp)
  41582c:	dec00104 	addi	sp,sp,4
  415830:	f800283a 	ret

00415834 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  415834:	defffb04 	addi	sp,sp,-20
  415838:	df000415 	stw	fp,16(sp)
  41583c:	df000404 	addi	fp,sp,16
  415840:	e13ffc15 	stw	r4,-16(fp)
  415844:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
  415848:	e0bffc17 	ldw	r2,-16(fp)
  41584c:	10c00417 	ldw	r3,16(r2)
  415850:	e0bffc17 	ldw	r2,-16(fp)
  415854:	10800517 	ldw	r2,20(r2)
  415858:	18803226 	beq	r3,r2,415924 <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  41585c:	e0bffc17 	ldw	r2,-16(fp)
  415860:	10800617 	ldw	r2,24(r2)
  415864:	1080008c 	andi	r2,r2,2
  415868:	10000326 	beq	r2,zero,415878 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  41586c:	e0bffd17 	ldw	r2,-12(fp)
  415870:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  415874:	10001d26 	beq	r2,zero,4158ec <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
  415878:	e0bffc17 	ldw	r2,-16(fp)
  41587c:	10800417 	ldw	r2,16(r2)
  415880:	e0bffc17 	ldw	r2,-16(fp)
  415884:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
  415888:	e0bffc17 	ldw	r2,-16(fp)
  41588c:	10800017 	ldw	r2,0(r2)
  415890:	10800104 	addi	r2,r2,4
  415894:	e0fffc17 	ldw	r3,-16(fp)
  415898:	18c00417 	ldw	r3,16(r3)
  41589c:	e13ffc17 	ldw	r4,-16(fp)
  4158a0:	20c7883a 	add	r3,r4,r3
  4158a4:	18c01704 	addi	r3,r3,92
  4158a8:	18c00003 	ldbu	r3,0(r3)
  4158ac:	18c03fcc 	andi	r3,r3,255
  4158b0:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
  4158b4:	e0bffc17 	ldw	r2,-16(fp)
  4158b8:	10800417 	ldw	r2,16(r2)
  4158bc:	10800044 	addi	r2,r2,1
  4158c0:	e0fffc17 	ldw	r3,-16(fp)
  4158c4:	18800415 	stw	r2,16(r3)
  4158c8:	10c00fcc 	andi	r3,r2,63
  4158cc:	e0bffc17 	ldw	r2,-16(fp)
  4158d0:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  4158d4:	e0bffc17 	ldw	r2,-16(fp)
  4158d8:	10800117 	ldw	r2,4(r2)
  4158dc:	10c01014 	ori	r3,r2,64
  4158e0:	e0bffc17 	ldw	r2,-16(fp)
  4158e4:	10c00115 	stw	r3,4(r2)
  4158e8:	00000e06 	br	415924 <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
  4158ec:	e0bffc17 	ldw	r2,-16(fp)
  4158f0:	10800017 	ldw	r2,0(r2)
  4158f4:	10800204 	addi	r2,r2,8
  4158f8:	10800037 	ldwio	r2,0(r2)
  4158fc:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  415900:	e0bffd17 	ldw	r2,-12(fp)
  415904:	1082000c 	andi	r2,r2,2048
  415908:	1000061e 	bne	r2,zero,415924 <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  41590c:	e0bffc17 	ldw	r2,-16(fp)
  415910:	10c00117 	ldw	r3,4(r2)
  415914:	00bfefc4 	movi	r2,-65
  415918:	1886703a 	and	r3,r3,r2
  41591c:	e0bffc17 	ldw	r2,-16(fp)
  415920:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
  415924:	e0bffc17 	ldw	r2,-16(fp)
  415928:	10c00417 	ldw	r3,16(r2)
  41592c:	e0bffc17 	ldw	r2,-16(fp)
  415930:	10800517 	ldw	r2,20(r2)
  415934:	1880061e 	bne	r3,r2,415950 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  415938:	e0bffc17 	ldw	r2,-16(fp)
  41593c:	10c00117 	ldw	r3,4(r2)
  415940:	00beefc4 	movi	r2,-1089
  415944:	1886703a 	and	r3,r3,r2
  415948:	e0bffc17 	ldw	r2,-16(fp)
  41594c:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  415950:	e0bffc17 	ldw	r2,-16(fp)
  415954:	10800017 	ldw	r2,0(r2)
  415958:	10800304 	addi	r2,r2,12
  41595c:	e0fffc17 	ldw	r3,-16(fp)
  415960:	18c00117 	ldw	r3,4(r3)
  415964:	10c00035 	stwio	r3,0(r2)
}
  415968:	e037883a 	mov	sp,fp
  41596c:	df000017 	ldw	fp,0(sp)
  415970:	dec00104 	addi	sp,sp,4
  415974:	f800283a 	ret

00415978 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  415978:	defffd04 	addi	sp,sp,-12
  41597c:	df000215 	stw	fp,8(sp)
  415980:	df000204 	addi	fp,sp,8
  415984:	e13ffe15 	stw	r4,-8(fp)
  415988:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  41598c:	00000506 	br	4159a4 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  415990:	e0bfff17 	ldw	r2,-4(fp)
  415994:	1090000c 	andi	r2,r2,16384
  415998:	10000226 	beq	r2,zero,4159a4 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
  41599c:	00bffd44 	movi	r2,-11
  4159a0:	00000606 	br	4159bc <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  4159a4:	e0bffe17 	ldw	r2,-8(fp)
  4159a8:	10c00417 	ldw	r3,16(r2)
  4159ac:	e0bffe17 	ldw	r2,-8(fp)
  4159b0:	10800517 	ldw	r2,20(r2)
  4159b4:	18bff61e 	bne	r3,r2,415990 <_gp+0xffff5cc0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  4159b8:	0005883a 	mov	r2,zero
}
  4159bc:	e037883a 	mov	sp,fp
  4159c0:	df000017 	ldw	fp,0(sp)
  4159c4:	dec00104 	addi	sp,sp,4
  4159c8:	f800283a 	ret

004159cc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  4159cc:	defffe04 	addi	sp,sp,-8
  4159d0:	dfc00115 	stw	ra,4(sp)
  4159d4:	df000015 	stw	fp,0(sp)
  4159d8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  4159dc:	00801074 	movhi	r2,65
  4159e0:	109f3c04 	addi	r2,r2,31984
  4159e4:	10800017 	ldw	r2,0(r2)
  4159e8:	10000526 	beq	r2,zero,415a00 <alt_get_errno+0x34>
  4159ec:	00801074 	movhi	r2,65
  4159f0:	109f3c04 	addi	r2,r2,31984
  4159f4:	10800017 	ldw	r2,0(r2)
  4159f8:	103ee83a 	callr	r2
  4159fc:	00000206 	br	415a08 <alt_get_errno+0x3c>
  415a00:	008010b4 	movhi	r2,66
  415a04:	10a06804 	addi	r2,r2,-32352
}
  415a08:	e037883a 	mov	sp,fp
  415a0c:	dfc00117 	ldw	ra,4(sp)
  415a10:	df000017 	ldw	fp,0(sp)
  415a14:	dec00204 	addi	sp,sp,8
  415a18:	f800283a 	ret

00415a1c <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
  415a1c:	defff204 	addi	sp,sp,-56
  415a20:	dfc00d15 	stw	ra,52(sp)
  415a24:	df000c15 	stw	fp,48(sp)
  415a28:	df000c04 	addi	fp,sp,48
  415a2c:	e13ffc15 	stw	r4,-16(fp)
  415a30:	e17ffd15 	stw	r5,-12(fp)
  415a34:	e1bffe15 	stw	r6,-8(fp)
  415a38:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
  415a3c:	e03ff405 	stb	zero,-48(fp)
  int             count = 0;
  415a40:	e03ff515 	stw	zero,-44(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
  415a44:	e0bfff17 	ldw	r2,-4(fp)
  415a48:	1090000c 	andi	r2,r2,16384
  415a4c:	1005003a 	cmpeq	r2,r2,zero
  415a50:	10803fcc 	andi	r2,r2,255
  415a54:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  415a58:	00001306 	br	415aa8 <altera_avalon_uart_read+0x8c>
    {
      count++;
  415a5c:	e0bff517 	ldw	r2,-44(fp)
  415a60:	10800044 	addi	r2,r2,1
  415a64:	e0bff515 	stw	r2,-44(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
  415a68:	e0bffd17 	ldw	r2,-12(fp)
  415a6c:	10c00044 	addi	r3,r2,1
  415a70:	e0fffd15 	stw	r3,-12(fp)
  415a74:	e0fffc17 	ldw	r3,-16(fp)
  415a78:	18c00217 	ldw	r3,8(r3)
  415a7c:	e13ffc17 	ldw	r4,-16(fp)
  415a80:	20c7883a 	add	r3,r4,r3
  415a84:	18c00704 	addi	r3,r3,28
  415a88:	18c00003 	ldbu	r3,0(r3)
  415a8c:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
  415a90:	e0bffc17 	ldw	r2,-16(fp)
  415a94:	10800217 	ldw	r2,8(r2)
  415a98:	10800044 	addi	r2,r2,1
  415a9c:	10c00fcc 	andi	r3,r2,63
  415aa0:	e0bffc17 	ldw	r2,-16(fp)
  415aa4:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  415aa8:	e0fff517 	ldw	r3,-44(fp)
  415aac:	e0bffe17 	ldw	r2,-8(fp)
  415ab0:	1880050e 	bge	r3,r2,415ac8 <altera_avalon_uart_read+0xac>
  415ab4:	e0bffc17 	ldw	r2,-16(fp)
  415ab8:	10c00217 	ldw	r3,8(r2)
  415abc:	e0bffc17 	ldw	r2,-16(fp)
  415ac0:	10800317 	ldw	r2,12(r2)
  415ac4:	18bfe51e 	bne	r3,r2,415a5c <_gp+0xffff5d8c>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
  415ac8:	e0bff517 	ldw	r2,-44(fp)
  415acc:	1000251e 	bne	r2,zero,415b64 <altera_avalon_uart_read+0x148>
  415ad0:	e0bffc17 	ldw	r2,-16(fp)
  415ad4:	10c00217 	ldw	r3,8(r2)
  415ad8:	e0bffc17 	ldw	r2,-16(fp)
  415adc:	10800317 	ldw	r2,12(r2)
  415ae0:	1880201e 	bne	r3,r2,415b64 <altera_avalon_uart_read+0x148>
    {
      if (!block)
  415ae4:	e0bff617 	ldw	r2,-40(fp)
  415ae8:	1000071e 	bne	r2,zero,415b08 <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
  415aec:	04159cc0 	call	4159cc <alt_get_errno>
  415af0:	1007883a 	mov	r3,r2
  415af4:	008002c4 	movi	r2,11
  415af8:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
  415afc:	00800044 	movi	r2,1
  415b00:	e0bff405 	stb	r2,-48(fp)
        break;
  415b04:	00001b06 	br	415b74 <altera_avalon_uart_read+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  415b08:	0005303a 	rdctl	r2,status
  415b0c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  415b10:	e0fff817 	ldw	r3,-32(fp)
  415b14:	00bfff84 	movi	r2,-2
  415b18:	1884703a 	and	r2,r3,r2
  415b1c:	1001703a 	wrctl	status,r2
  
  return context;
  415b20:	e0bff817 	ldw	r2,-32(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
  415b24:	e0bff715 	stw	r2,-36(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  415b28:	e0bffc17 	ldw	r2,-16(fp)
  415b2c:	10800117 	ldw	r2,4(r2)
  415b30:	10c02014 	ori	r3,r2,128
  415b34:	e0bffc17 	ldw	r2,-16(fp)
  415b38:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  415b3c:	e0bffc17 	ldw	r2,-16(fp)
  415b40:	10800017 	ldw	r2,0(r2)
  415b44:	10800304 	addi	r2,r2,12
  415b48:	e0fffc17 	ldw	r3,-16(fp)
  415b4c:	18c00117 	ldw	r3,4(r3)
  415b50:	10c00035 	stwio	r3,0(r2)
  415b54:	e0bff717 	ldw	r2,-36(fp)
  415b58:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  415b5c:	e0bff917 	ldw	r2,-28(fp)
  415b60:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
  415b64:	e0bff517 	ldw	r2,-44(fp)
  415b68:	1000021e 	bne	r2,zero,415b74 <altera_avalon_uart_read+0x158>
  415b6c:	e0bffe17 	ldw	r2,-8(fp)
  415b70:	103fb91e 	bne	r2,zero,415a58 <_gp+0xffff5d88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  415b74:	0005303a 	rdctl	r2,status
  415b78:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  415b7c:	e0fffa17 	ldw	r3,-24(fp)
  415b80:	00bfff84 	movi	r2,-2
  415b84:	1884703a 	and	r2,r3,r2
  415b88:	1001703a 	wrctl	status,r2
  
  return context;
  415b8c:	e0bffa17 	ldw	r2,-24(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
  415b90:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  415b94:	e0bffc17 	ldw	r2,-16(fp)
  415b98:	10800117 	ldw	r2,4(r2)
  415b9c:	10c02014 	ori	r3,r2,128
  415ba0:	e0bffc17 	ldw	r2,-16(fp)
  415ba4:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  415ba8:	e0bffc17 	ldw	r2,-16(fp)
  415bac:	10800017 	ldw	r2,0(r2)
  415bb0:	10800304 	addi	r2,r2,12
  415bb4:	e0fffc17 	ldw	r3,-16(fp)
  415bb8:	18c00117 	ldw	r3,4(r3)
  415bbc:	10c00035 	stwio	r3,0(r2)
  415bc0:	e0bff717 	ldw	r2,-36(fp)
  415bc4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  415bc8:	e0bffb17 	ldw	r2,-20(fp)
  415bcc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
  415bd0:	e0bff403 	ldbu	r2,-48(fp)
  415bd4:	10000226 	beq	r2,zero,415be0 <altera_avalon_uart_read+0x1c4>
    return -EWOULDBLOCK;
  415bd8:	00bffd44 	movi	r2,-11
  415bdc:	00000106 	br	415be4 <altera_avalon_uart_read+0x1c8>
  }
  else {
    return count;
  415be0:	e0bff517 	ldw	r2,-44(fp)
  }
}
  415be4:	e037883a 	mov	sp,fp
  415be8:	dfc00117 	ldw	ra,4(sp)
  415bec:	df000017 	ldw	fp,0(sp)
  415bf0:	dec00204 	addi	sp,sp,8
  415bf4:	f800283a 	ret

00415bf8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  415bf8:	defffe04 	addi	sp,sp,-8
  415bfc:	dfc00115 	stw	ra,4(sp)
  415c00:	df000015 	stw	fp,0(sp)
  415c04:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  415c08:	00801074 	movhi	r2,65
  415c0c:	109f3c04 	addi	r2,r2,31984
  415c10:	10800017 	ldw	r2,0(r2)
  415c14:	10000526 	beq	r2,zero,415c2c <alt_get_errno+0x34>
  415c18:	00801074 	movhi	r2,65
  415c1c:	109f3c04 	addi	r2,r2,31984
  415c20:	10800017 	ldw	r2,0(r2)
  415c24:	103ee83a 	callr	r2
  415c28:	00000206 	br	415c34 <alt_get_errno+0x3c>
  415c2c:	008010b4 	movhi	r2,66
  415c30:	10a06804 	addi	r2,r2,-32352
}
  415c34:	e037883a 	mov	sp,fp
  415c38:	dfc00117 	ldw	ra,4(sp)
  415c3c:	df000017 	ldw	fp,0(sp)
  415c40:	dec00204 	addi	sp,sp,8
  415c44:	f800283a 	ret

00415c48 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
  415c48:	defff204 	addi	sp,sp,-56
  415c4c:	dfc00d15 	stw	ra,52(sp)
  415c50:	df000c15 	stw	fp,48(sp)
  415c54:	df000c04 	addi	fp,sp,48
  415c58:	e13ffc15 	stw	r4,-16(fp)
  415c5c:	e17ffd15 	stw	r5,-12(fp)
  415c60:	e1bffe15 	stw	r6,-8(fp)
  415c64:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
  415c68:	e0bffe17 	ldw	r2,-8(fp)
  415c6c:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
  415c70:	e0bfff17 	ldw	r2,-4(fp)
  415c74:	1090000c 	andi	r2,r2,16384
  415c78:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  415c7c:	00003c06 	br	415d70 <altera_avalon_uart_write+0x128>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  415c80:	e0bffc17 	ldw	r2,-16(fp)
  415c84:	10800517 	ldw	r2,20(r2)
  415c88:	10800044 	addi	r2,r2,1
  415c8c:	10800fcc 	andi	r2,r2,63
  415c90:	e0bff615 	stw	r2,-40(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
  415c94:	e0bffc17 	ldw	r2,-16(fp)
  415c98:	10c00417 	ldw	r3,16(r2)
  415c9c:	e0bff617 	ldw	r2,-40(fp)
  415ca0:	1880221e 	bne	r3,r2,415d2c <altera_avalon_uart_write+0xe4>
    {
      if (no_block)
  415ca4:	e0bff517 	ldw	r2,-44(fp)
  415ca8:	10000526 	beq	r2,zero,415cc0 <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
  415cac:	0415bf80 	call	415bf8 <alt_get_errno>
  415cb0:	1007883a 	mov	r3,r2
  415cb4:	008002c4 	movi	r2,11
  415cb8:	18800015 	stw	r2,0(r3)
        break;
  415cbc:	00002e06 	br	415d78 <altera_avalon_uart_write+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  415cc0:	0005303a 	rdctl	r2,status
  415cc4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  415cc8:	e0fff817 	ldw	r3,-32(fp)
  415ccc:	00bfff84 	movi	r2,-2
  415cd0:	1884703a 	and	r2,r3,r2
  415cd4:	1001703a 	wrctl	status,r2
  
  return context;
  415cd8:	e0bff817 	ldw	r2,-32(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
  415cdc:	e0bff715 	stw	r2,-36(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  415ce0:	e0bffc17 	ldw	r2,-16(fp)
  415ce4:	10800117 	ldw	r2,4(r2)
  415ce8:	10c11014 	ori	r3,r2,1088
  415cec:	e0bffc17 	ldw	r2,-16(fp)
  415cf0:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  415cf4:	e0bffc17 	ldw	r2,-16(fp)
  415cf8:	10800017 	ldw	r2,0(r2)
  415cfc:	10800304 	addi	r2,r2,12
  415d00:	e0fffc17 	ldw	r3,-16(fp)
  415d04:	18c00117 	ldw	r3,4(r3)
  415d08:	10c00035 	stwio	r3,0(r2)
  415d0c:	e0bff717 	ldw	r2,-36(fp)
  415d10:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  415d14:	e0bff917 	ldw	r2,-28(fp)
  415d18:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
  415d1c:	e0bffc17 	ldw	r2,-16(fp)
  415d20:	10c00417 	ldw	r3,16(r2)
  415d24:	e0bff617 	ldw	r2,-40(fp)
  415d28:	18bffc26 	beq	r3,r2,415d1c <_gp+0xffff604c>
      }
    }

    count--;
  415d2c:	e0bff417 	ldw	r2,-48(fp)
  415d30:	10bfffc4 	addi	r2,r2,-1
  415d34:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
  415d38:	e0bffc17 	ldw	r2,-16(fp)
  415d3c:	10c00517 	ldw	r3,20(r2)
  415d40:	e0bffd17 	ldw	r2,-12(fp)
  415d44:	11000044 	addi	r4,r2,1
  415d48:	e13ffd15 	stw	r4,-12(fp)
  415d4c:	10800003 	ldbu	r2,0(r2)
  415d50:	1009883a 	mov	r4,r2
  415d54:	e0bffc17 	ldw	r2,-16(fp)
  415d58:	10c5883a 	add	r2,r2,r3
  415d5c:	10801704 	addi	r2,r2,92
  415d60:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
  415d64:	e0bffc17 	ldw	r2,-16(fp)
  415d68:	e0fff617 	ldw	r3,-40(fp)
  415d6c:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  415d70:	e0bff417 	ldw	r2,-48(fp)
  415d74:	103fc21e 	bne	r2,zero,415c80 <_gp+0xffff5fb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  415d78:	0005303a 	rdctl	r2,status
  415d7c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  415d80:	e0fffa17 	ldw	r3,-24(fp)
  415d84:	00bfff84 	movi	r2,-2
  415d88:	1884703a 	and	r2,r3,r2
  415d8c:	1001703a 	wrctl	status,r2
  
  return context;
  415d90:	e0bffa17 	ldw	r2,-24(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
  415d94:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  415d98:	e0bffc17 	ldw	r2,-16(fp)
  415d9c:	10800117 	ldw	r2,4(r2)
  415da0:	10c11014 	ori	r3,r2,1088
  415da4:	e0bffc17 	ldw	r2,-16(fp)
  415da8:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  415dac:	e0bffc17 	ldw	r2,-16(fp)
  415db0:	10800017 	ldw	r2,0(r2)
  415db4:	10800304 	addi	r2,r2,12
  415db8:	e0fffc17 	ldw	r3,-16(fp)
  415dbc:	18c00117 	ldw	r3,4(r3)
  415dc0:	10c00035 	stwio	r3,0(r2)
  415dc4:	e0bff717 	ldw	r2,-36(fp)
  415dc8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  415dcc:	e0bffb17 	ldw	r2,-20(fp)
  415dd0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
  415dd4:	e0fffe17 	ldw	r3,-8(fp)
  415dd8:	e0bff417 	ldw	r2,-48(fp)
  415ddc:	1885c83a 	sub	r2,r3,r2
}
  415de0:	e037883a 	mov	sp,fp
  415de4:	dfc00117 	ldw	ra,4(sp)
  415de8:	df000017 	ldw	fp,0(sp)
  415dec:	dec00204 	addi	sp,sp,8
  415df0:	f800283a 	ret

00415df4 <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
  415df4:	defff904 	addi	sp,sp,-28
  415df8:	dfc00615 	stw	ra,24(sp)
  415dfc:	df000515 	stw	fp,20(sp)
  415e00:	df000504 	addi	fp,sp,20
  415e04:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
  415e08:	00800144 	movi	r2,5
  415e0c:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
  415e10:	00800044 	movi	r2,1
  415e14:	d8800015 	stw	r2,0(sp)
  415e18:	e0bffe44 	addi	r2,fp,-7
  415e1c:	d8800115 	stw	r2,4(sp)
  415e20:	d8000215 	stw	zero,8(sp)
  415e24:	e13fff17 	ldw	r4,-4(fp)
  415e28:	000b883a 	mov	r5,zero
  415e2c:	01800044 	movi	r6,1
  415e30:	e1fffe04 	addi	r7,fp,-8
  415e34:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
  415e38:	e0bffe43 	ldbu	r2,-7(fp)
}
  415e3c:	e037883a 	mov	sp,fp
  415e40:	dfc00117 	ldw	ra,4(sp)
  415e44:	df000017 	ldw	fp,0(sp)
  415e48:	dec00204 	addi	sp,sp,8
  415e4c:	f800283a 	ret

00415e50 <epcs_test_wip>:

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
  415e50:	defffd04 	addi	sp,sp,-12
  415e54:	dfc00215 	stw	ra,8(sp)
  415e58:	df000115 	stw	fp,4(sp)
  415e5c:	df000104 	addi	fp,sp,4
  415e60:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
  415e64:	e13fff17 	ldw	r4,-4(fp)
  415e68:	0415df40 	call	415df4 <epcs_read_status_register>
  415e6c:	10803fcc 	andi	r2,r2,255
  415e70:	1080004c 	andi	r2,r2,1
}
  415e74:	e037883a 	mov	sp,fp
  415e78:	dfc00117 	ldw	ra,4(sp)
  415e7c:	df000017 	ldw	fp,0(sp)
  415e80:	dec00204 	addi	sp,sp,8
  415e84:	f800283a 	ret

00415e88 <epcs_await_wip_released>:

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
  415e88:	defffd04 	addi	sp,sp,-12
  415e8c:	dfc00215 	stw	ra,8(sp)
  415e90:	df000115 	stw	fp,4(sp)
  415e94:	df000104 	addi	fp,sp,4
  415e98:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
  415e9c:	0001883a 	nop
  415ea0:	e13fff17 	ldw	r4,-4(fp)
  415ea4:	0415e500 	call	415e50 <epcs_test_wip>
  415ea8:	103ffd1e 	bne	r2,zero,415ea0 <_gp+0xffff61d0>
  {
  }
}
  415eac:	e037883a 	mov	sp,fp
  415eb0:	dfc00117 	ldw	ra,4(sp)
  415eb4:	df000017 	ldw	fp,0(sp)
  415eb8:	dec00204 	addi	sp,sp,8
  415ebc:	f800283a 	ret

00415ec0 <epcs_sector_erase>:

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
  415ec0:	defff604 	addi	sp,sp,-40
  415ec4:	dfc00915 	stw	ra,36(sp)
  415ec8:	df000815 	stw	fp,32(sp)
  415ecc:	df000804 	addi	fp,sp,32
  415ed0:	e13ffd15 	stw	r4,-12(fp)
  415ed4:	e17ffe15 	stw	r5,-8(fp)
  415ed8:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
  415edc:	e0bfff17 	ldw	r2,-4(fp)
  415ee0:	10001226 	beq	r2,zero,415f2c <epcs_sector_erase+0x6c>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
  415ee4:	00bff604 	movi	r2,-40
  415ee8:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
  415eec:	e0bffe17 	ldw	r2,-8(fp)
  415ef0:	1004d63a 	srli	r2,r2,24
  415ef4:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
  415ef8:	e0bffe17 	ldw	r2,-8(fp)
  415efc:	1004d43a 	srli	r2,r2,16
  415f00:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
  415f04:	e0bffe17 	ldw	r2,-8(fp)
  415f08:	1004d23a 	srli	r2,r2,8
  415f0c:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
  415f10:	e0bffe17 	ldw	r2,-8(fp)
  415f14:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
  415f18:	00800144 	movi	r2,5
  415f1c:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
  415f20:	e13ffd17 	ldw	r4,-12(fp)
  415f24:	04163680 	call	416368 <epcs_enter_4_bytes_mode>
  415f28:	00000c06 	br	415f5c <epcs_sector_erase+0x9c>
  }
  else
  {
      se[0] = epcs_se;
  415f2c:	00bff604 	movi	r2,-40
  415f30:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
  415f34:	e0bffe17 	ldw	r2,-8(fp)
  415f38:	1004d43a 	srli	r2,r2,16
  415f3c:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
  415f40:	e0bffe17 	ldw	r2,-8(fp)
  415f44:	1004d23a 	srli	r2,r2,8
  415f48:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
  415f4c:	e0bffe17 	ldw	r2,-8(fp)
  415f50:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
  415f54:	00800104 	movi	r2,4
  415f58:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
  415f5c:	e13ffd17 	ldw	r4,-12(fp)
  415f60:	04160ac0 	call	4160ac <epcs_write_enable>

  alt_avalon_spi_command(
  415f64:	e0fffb03 	ldbu	r3,-20(fp)
  415f68:	e0bffb44 	addi	r2,fp,-19
  415f6c:	d8000015 	stw	zero,0(sp)
  415f70:	d8000115 	stw	zero,4(sp)
  415f74:	d8000215 	stw	zero,8(sp)
  415f78:	e13ffd17 	ldw	r4,-12(fp)
  415f7c:	000b883a 	mov	r5,zero
  415f80:	180d883a 	mov	r6,r3
  415f84:	100f883a 	mov	r7,r2
  415f88:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
  415f8c:	e13ffd17 	ldw	r4,-12(fp)
  415f90:	0415e880 	call	415e88 <epcs_await_wip_released>

  if(four_bytes_mode)
  415f94:	e0bfff17 	ldw	r2,-4(fp)
  415f98:	10000226 	beq	r2,zero,415fa4 <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
  415f9c:	e13ffd17 	ldw	r4,-12(fp)
  415fa0:	04163c40 	call	4163c4 <epcs_exit_4_bytes_mode>
  }
}
  415fa4:	e037883a 	mov	sp,fp
  415fa8:	dfc00117 	ldw	ra,4(sp)
  415fac:	df000017 	ldw	fp,0(sp)
  415fb0:	dec00204 	addi	sp,sp,8
  415fb4:	f800283a 	ret

00415fb8 <epcs_read_buffer>:

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
  415fb8:	defff404 	addi	sp,sp,-48
  415fbc:	dfc00b15 	stw	ra,44(sp)
  415fc0:	df000a15 	stw	fp,40(sp)
  415fc4:	df000a04 	addi	fp,sp,40
  415fc8:	e13ffc15 	stw	r4,-16(fp)
  415fcc:	e17ffd15 	stw	r5,-12(fp)
  415fd0:	e1bffe15 	stw	r6,-8(fp)
  415fd4:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
  415fd8:	008000c4 	movi	r2,3
  415fdc:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
  415fe0:	e0800217 	ldw	r2,8(fp)
  415fe4:	10001026 	beq	r2,zero,416028 <epcs_read_buffer+0x70>
  {
        read_command[1] = (offset >> 24) & 0xFF;
  415fe8:	e0bffd17 	ldw	r2,-12(fp)
  415fec:	1004d63a 	srli	r2,r2,24
  415ff0:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
  415ff4:	e0bffd17 	ldw	r2,-12(fp)
  415ff8:	1005d43a 	srai	r2,r2,16
  415ffc:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
  416000:	e0bffd17 	ldw	r2,-12(fp)
  416004:	1005d23a 	srai	r2,r2,8
  416008:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
  41600c:	e0bffd17 	ldw	r2,-12(fp)
  416010:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
  416014:	00800144 	movi	r2,5
  416018:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
  41601c:	e13ffc17 	ldw	r4,-16(fp)
  416020:	04163680 	call	416368 <epcs_enter_4_bytes_mode>
  416024:	00000a06 	br	416050 <epcs_read_buffer+0x98>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
  416028:	e0bffd17 	ldw	r2,-12(fp)
  41602c:	1005d43a 	srai	r2,r2,16
  416030:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
  416034:	e0bffd17 	ldw	r2,-12(fp)
  416038:	1005d23a 	srai	r2,r2,8
  41603c:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
  416040:	e0bffd17 	ldw	r2,-12(fp)
  416044:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
  416048:	00800104 	movi	r2,4
  41604c:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
  416050:	e13ffc17 	ldw	r4,-16(fp)
  416054:	0415e880 	call	415e88 <epcs_await_wip_released>

  alt_avalon_spi_command(
  416058:	e0bfff17 	ldw	r2,-4(fp)
  41605c:	e0fffa04 	addi	r3,fp,-24
  416060:	d8800015 	stw	r2,0(sp)
  416064:	e0bffe17 	ldw	r2,-8(fp)
  416068:	d8800115 	stw	r2,4(sp)
  41606c:	d8000215 	stw	zero,8(sp)
  416070:	e13ffc17 	ldw	r4,-16(fp)
  416074:	000b883a 	mov	r5,zero
  416078:	e1bff917 	ldw	r6,-28(fp)
  41607c:	180f883a 	mov	r7,r3
  416080:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
  416084:	e0800217 	ldw	r2,8(fp)
  416088:	10000226 	beq	r2,zero,416094 <epcs_read_buffer+0xdc>
  {
    epcs_exit_4_bytes_mode(base);
  41608c:	e13ffc17 	ldw	r4,-16(fp)
  416090:	04163c40 	call	4163c4 <epcs_exit_4_bytes_mode>
  }

  return length;
  416094:	e0bfff17 	ldw	r2,-4(fp)
}
  416098:	e037883a 	mov	sp,fp
  41609c:	dfc00117 	ldw	ra,4(sp)
  4160a0:	df000017 	ldw	fp,0(sp)
  4160a4:	dec00204 	addi	sp,sp,8
  4160a8:	f800283a 	ret

004160ac <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
  4160ac:	defff904 	addi	sp,sp,-28
  4160b0:	dfc00615 	stw	ra,24(sp)
  4160b4:	df000515 	stw	fp,20(sp)
  4160b8:	df000504 	addi	fp,sp,20
  4160bc:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
  4160c0:	00800184 	movi	r2,6
  4160c4:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
  4160c8:	d8000015 	stw	zero,0(sp)
  4160cc:	d8000115 	stw	zero,4(sp)
  4160d0:	d8000215 	stw	zero,8(sp)
  4160d4:	e13fff17 	ldw	r4,-4(fp)
  4160d8:	000b883a 	mov	r5,zero
  4160dc:	01800044 	movi	r6,1
  4160e0:	e1fffe04 	addi	r7,fp,-8
  4160e4:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
  4160e8:	e037883a 	mov	sp,fp
  4160ec:	dfc00117 	ldw	ra,4(sp)
  4160f0:	df000017 	ldw	fp,0(sp)
  4160f4:	dec00204 	addi	sp,sp,8
  4160f8:	f800283a 	ret

004160fc <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
  4160fc:	defff804 	addi	sp,sp,-32
  416100:	dfc00715 	stw	ra,28(sp)
  416104:	df000615 	stw	fp,24(sp)
  416108:	df000604 	addi	fp,sp,24
  41610c:	e13ffe15 	stw	r4,-8(fp)
  416110:	2805883a 	mov	r2,r5
  416114:	e0bfff05 	stb	r2,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
  416118:	00800044 	movi	r2,1
  41611c:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
  416120:	e0bfff03 	ldbu	r2,-4(fp)
  416124:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
  416128:	d8000015 	stw	zero,0(sp)
  41612c:	d8000115 	stw	zero,4(sp)
  416130:	d8000215 	stw	zero,8(sp)
  416134:	e13ffe17 	ldw	r4,-8(fp)
  416138:	000b883a 	mov	r5,zero
  41613c:	01800084 	movi	r6,2
  416140:	e1fffd04 	addi	r7,fp,-12
  416144:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
  416148:	e13ffe17 	ldw	r4,-8(fp)
  41614c:	0415e880 	call	415e88 <epcs_await_wip_released>
}
  416150:	e037883a 	mov	sp,fp
  416154:	dfc00117 	ldw	ra,4(sp)
  416158:	df000017 	ldw	fp,0(sp)
  41615c:	dec00204 	addi	sp,sp,8
  416160:	f800283a 	ret

00416164 <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
  416164:	defff404 	addi	sp,sp,-48
  416168:	dfc00b15 	stw	ra,44(sp)
  41616c:	df000a15 	stw	fp,40(sp)
  416170:	df000a04 	addi	fp,sp,40
  416174:	e13ffc15 	stw	r4,-16(fp)
  416178:	e17ffd15 	stw	r5,-12(fp)
  41617c:	e1bffe15 	stw	r6,-8(fp)
  416180:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
  416184:	00800084 	movi	r2,2
  416188:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
  41618c:	e0800217 	ldw	r2,8(fp)
  416190:	10001026 	beq	r2,zero,4161d4 <epcs_write_buffer+0x70>
  {
      pp[1] = (offset >> 24) & 0xFF;
  416194:	e0bffd17 	ldw	r2,-12(fp)
  416198:	1004d63a 	srli	r2,r2,24
  41619c:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
  4161a0:	e0bffd17 	ldw	r2,-12(fp)
  4161a4:	1005d43a 	srai	r2,r2,16
  4161a8:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
  4161ac:	e0bffd17 	ldw	r2,-12(fp)
  4161b0:	1005d23a 	srai	r2,r2,8
  4161b4:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
  4161b8:	e0bffd17 	ldw	r2,-12(fp)
  4161bc:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
  4161c0:	00800144 	movi	r2,5
  4161c4:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
  4161c8:	e13ffc17 	ldw	r4,-16(fp)
  4161cc:	04163680 	call	416368 <epcs_enter_4_bytes_mode>
  4161d0:	00000a06 	br	4161fc <epcs_write_buffer+0x98>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
  4161d4:	e0bffd17 	ldw	r2,-12(fp)
  4161d8:	1005d43a 	srai	r2,r2,16
  4161dc:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
  4161e0:	e0bffd17 	ldw	r2,-12(fp)
  4161e4:	1005d23a 	srai	r2,r2,8
  4161e8:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
  4161ec:	e0bffd17 	ldw	r2,-12(fp)
  4161f0:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
  4161f4:	00800104 	movi	r2,4
  4161f8:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
  4161fc:	e13ffc17 	ldw	r4,-16(fp)
  416200:	04160ac0 	call	4160ac <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
  416204:	e0fffa04 	addi	r3,fp,-24
  416208:	d8000015 	stw	zero,0(sp)
  41620c:	d8000115 	stw	zero,4(sp)
  416210:	00800044 	movi	r2,1
  416214:	d8800215 	stw	r2,8(sp)
  416218:	e13ffc17 	ldw	r4,-16(fp)
  41621c:	000b883a 	mov	r5,zero
  416220:	e1bff917 	ldw	r6,-28(fp)
  416224:	180f883a 	mov	r7,r3
  416228:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
  41622c:	e0bfff17 	ldw	r2,-4(fp)
  416230:	d8000015 	stw	zero,0(sp)
  416234:	d8000115 	stw	zero,4(sp)
  416238:	d8000215 	stw	zero,8(sp)
  41623c:	e13ffc17 	ldw	r4,-16(fp)
  416240:	000b883a 	mov	r5,zero
  416244:	100d883a 	mov	r6,r2
  416248:	e1fffe17 	ldw	r7,-8(fp)
  41624c:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
  416250:	e13ffc17 	ldw	r4,-16(fp)
  416254:	0415e880 	call	415e88 <epcs_await_wip_released>

  if(four_bytes_mode)
  416258:	e0800217 	ldw	r2,8(fp)
  41625c:	10000226 	beq	r2,zero,416268 <epcs_write_buffer+0x104>
  {
    epcs_exit_4_bytes_mode(base);
  416260:	e13ffc17 	ldw	r4,-16(fp)
  416264:	04163c40 	call	4163c4 <epcs_exit_4_bytes_mode>
  }

  return length;
  416268:	e0bfff17 	ldw	r2,-4(fp)
}
  41626c:	e037883a 	mov	sp,fp
  416270:	dfc00117 	ldw	ra,4(sp)
  416274:	df000017 	ldw	fp,0(sp)
  416278:	dec00204 	addi	sp,sp,8
  41627c:	f800283a 	ret

00416280 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
  416280:	defff804 	addi	sp,sp,-32
  416284:	dfc00715 	stw	ra,28(sp)
  416288:	df000615 	stw	fp,24(sp)
  41628c:	df000604 	addi	fp,sp,24
  416290:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
  416294:	00bfeac4 	movi	r2,-85
  416298:	e0bffd05 	stb	r2,-12(fp)
  41629c:	e03ffd45 	stb	zero,-11(fp)
  4162a0:	e03ffd85 	stb	zero,-10(fp)
  4162a4:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
  4162a8:	00800044 	movi	r2,1
  4162ac:	d8800015 	stw	r2,0(sp)
  4162b0:	e0bffe04 	addi	r2,fp,-8
  4162b4:	d8800115 	stw	r2,4(sp)
  4162b8:	d8000215 	stw	zero,8(sp)
  4162bc:	e13fff17 	ldw	r4,-4(fp)
  4162c0:	000b883a 	mov	r5,zero
  4162c4:	01800104 	movi	r6,4
  4162c8:	e1fffd04 	addi	r7,fp,-12
  4162cc:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
  4162d0:	e0bffe03 	ldbu	r2,-8(fp)
}
  4162d4:	e037883a 	mov	sp,fp
  4162d8:	dfc00117 	ldw	ra,4(sp)
  4162dc:	df000017 	ldw	fp,0(sp)
  4162e0:	dec00204 	addi	sp,sp,8
  4162e4:	f800283a 	ret

004162e8 <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
  4162e8:	defff904 	addi	sp,sp,-28
  4162ec:	dfc00615 	stw	ra,24(sp)
  4162f0:	df000515 	stw	fp,20(sp)
  4162f4:	df000504 	addi	fp,sp,20
  4162f8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
  4162fc:	00bfe7c4 	movi	r2,-97
  416300:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
  416304:	008000c4 	movi	r2,3
  416308:	d8800015 	stw	r2,0(sp)
  41630c:	e0bffe44 	addi	r2,fp,-7
  416310:	d8800115 	stw	r2,4(sp)
  416314:	d8000215 	stw	zero,8(sp)
  416318:	e13fff17 	ldw	r4,-4(fp)
  41631c:	000b883a 	mov	r5,zero
  416320:	01800044 	movi	r6,1
  416324:	e1fffe04 	addi	r7,fp,-8
  416328:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
  41632c:	e0bffe43 	ldbu	r2,-7(fp)
  416330:	10803fcc 	andi	r2,r2,255
  416334:	1006943a 	slli	r3,r2,16
  416338:	e0bffe83 	ldbu	r2,-6(fp)
  41633c:	10803fcc 	andi	r2,r2,255
  416340:	1004923a 	slli	r2,r2,8
  416344:	1886b03a 	or	r3,r3,r2
  416348:	e0bffec3 	ldbu	r2,-5(fp)
  41634c:	10803fcc 	andi	r2,r2,255
  416350:	1884b03a 	or	r2,r3,r2
}
  416354:	e037883a 	mov	sp,fp
  416358:	dfc00117 	ldw	ra,4(sp)
  41635c:	df000017 	ldw	fp,0(sp)
  416360:	dec00204 	addi	sp,sp,8
  416364:	f800283a 	ret

00416368 <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
  416368:	defff904 	addi	sp,sp,-28
  41636c:	dfc00615 	stw	ra,24(sp)
  416370:	df000515 	stw	fp,20(sp)
  416374:	df000504 	addi	fp,sp,20
  416378:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
  41637c:	00bfedc4 	movi	r2,-73
  416380:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
  416384:	e13fff17 	ldw	r4,-4(fp)
  416388:	04160ac0 	call	4160ac <epcs_write_enable>

  alt_avalon_spi_command(
  41638c:	d8000015 	stw	zero,0(sp)
  416390:	d8000115 	stw	zero,4(sp)
  416394:	d8000215 	stw	zero,8(sp)
  416398:	e13fff17 	ldw	r4,-4(fp)
  41639c:	000b883a 	mov	r5,zero
  4163a0:	01800044 	movi	r6,1
  4163a4:	e1fffe04 	addi	r7,fp,-8
  4163a8:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
  4163ac:	0001883a 	nop
}
  4163b0:	e037883a 	mov	sp,fp
  4163b4:	dfc00117 	ldw	ra,4(sp)
  4163b8:	df000017 	ldw	fp,0(sp)
  4163bc:	dec00204 	addi	sp,sp,8
  4163c0:	f800283a 	ret

004163c4 <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
  4163c4:	defff904 	addi	sp,sp,-28
  4163c8:	dfc00615 	stw	ra,24(sp)
  4163cc:	df000515 	stw	fp,20(sp)
  4163d0:	df000504 	addi	fp,sp,20
  4163d4:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
  4163d8:	00bffa44 	movi	r2,-23
  4163dc:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
  4163e0:	e13fff17 	ldw	r4,-4(fp)
  4163e4:	04160ac0 	call	4160ac <epcs_write_enable>

  alt_avalon_spi_command(
  4163e8:	d8000015 	stw	zero,0(sp)
  4163ec:	d8000115 	stw	zero,4(sp)
  4163f0:	d8000215 	stw	zero,8(sp)
  4163f4:	e13fff17 	ldw	r4,-4(fp)
  4163f8:	000b883a 	mov	r5,zero
  4163fc:	01800044 	movi	r6,1
  416400:	e1fffe04 	addi	r7,fp,-8
  416404:	0416ee40 	call	416ee4 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
  416408:	0001883a 	nop
}
  41640c:	e037883a 	mov	sp,fp
  416410:	dfc00117 	ldw	ra,4(sp)
  416414:	df000017 	ldw	fp,0(sp)
  416418:	dec00204 	addi	sp,sp,8
  41641c:	f800283a 	ret

00416420 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  416420:	defffe04 	addi	sp,sp,-8
  416424:	dfc00115 	stw	ra,4(sp)
  416428:	df000015 	stw	fp,0(sp)
  41642c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  416430:	00801074 	movhi	r2,65
  416434:	109f3c04 	addi	r2,r2,31984
  416438:	10800017 	ldw	r2,0(r2)
  41643c:	10000526 	beq	r2,zero,416454 <alt_get_errno+0x34>
  416440:	00801074 	movhi	r2,65
  416444:	109f3c04 	addi	r2,r2,31984
  416448:	10800017 	ldw	r2,0(r2)
  41644c:	103ee83a 	callr	r2
  416450:	00000206 	br	41645c <alt_get_errno+0x3c>
  416454:	008010b4 	movhi	r2,66
  416458:	10a06804 	addi	r2,r2,-32352
}
  41645c:	e037883a 	mov	sp,fp
  416460:	dfc00117 	ldw	ra,4(sp)
  416464:	df000017 	ldw	fp,0(sp)
  416468:	dec00204 	addi	sp,sp,8
  41646c:	f800283a 	ret

00416470 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  416470:	defffb04 	addi	sp,sp,-20
  416474:	dfc00415 	stw	ra,16(sp)
  416478:	df000315 	stw	fp,12(sp)
  41647c:	df000304 	addi	fp,sp,12
  416480:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  416484:	e0bfff17 	ldw	r2,-4(fp)
  416488:	10000816 	blt	r2,zero,4164ac <close+0x3c>
  41648c:	e13fff17 	ldw	r4,-4(fp)
  416490:	01400304 	movi	r5,12
  416494:	0411f000 	call	411f00 <__mulsi3>
  416498:	1007883a 	mov	r3,r2
  41649c:	00801074 	movhi	r2,65
  4164a0:	109ed404 	addi	r2,r2,31568
  4164a4:	1885883a 	add	r2,r3,r2
  4164a8:	00000106 	br	4164b0 <close+0x40>
  4164ac:	0005883a 	mov	r2,zero
  4164b0:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  4164b4:	e0bffd17 	ldw	r2,-12(fp)
  4164b8:	10001926 	beq	r2,zero,416520 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  4164bc:	e0bffd17 	ldw	r2,-12(fp)
  4164c0:	10800017 	ldw	r2,0(r2)
  4164c4:	10800417 	ldw	r2,16(r2)
  4164c8:	10000626 	beq	r2,zero,4164e4 <close+0x74>
  4164cc:	e0bffd17 	ldw	r2,-12(fp)
  4164d0:	10800017 	ldw	r2,0(r2)
  4164d4:	10800417 	ldw	r2,16(r2)
  4164d8:	e13ffd17 	ldw	r4,-12(fp)
  4164dc:	103ee83a 	callr	r2
  4164e0:	00000106 	br	4164e8 <close+0x78>
  4164e4:	0005883a 	mov	r2,zero
  4164e8:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  4164ec:	e13fff17 	ldw	r4,-4(fp)
  4164f0:	0416ca80 	call	416ca8 <alt_release_fd>
    if (rval < 0)
  4164f4:	e0bffe17 	ldw	r2,-8(fp)
  4164f8:	1000070e 	bge	r2,zero,416518 <close+0xa8>
    {
      ALT_ERRNO = -rval;
  4164fc:	04164200 	call	416420 <alt_get_errno>
  416500:	1007883a 	mov	r3,r2
  416504:	e0bffe17 	ldw	r2,-8(fp)
  416508:	0085c83a 	sub	r2,zero,r2
  41650c:	18800015 	stw	r2,0(r3)
      return -1;
  416510:	00bfffc4 	movi	r2,-1
  416514:	00000706 	br	416534 <close+0xc4>
    }
    return 0;
  416518:	0005883a 	mov	r2,zero
  41651c:	00000506 	br	416534 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  416520:	04164200 	call	416420 <alt_get_errno>
  416524:	1007883a 	mov	r3,r2
  416528:	00801444 	movi	r2,81
  41652c:	18800015 	stw	r2,0(r3)
    return -1;
  416530:	00bfffc4 	movi	r2,-1
  }
}
  416534:	e037883a 	mov	sp,fp
  416538:	dfc00117 	ldw	ra,4(sp)
  41653c:	df000017 	ldw	fp,0(sp)
  416540:	dec00204 	addi	sp,sp,8
  416544:	f800283a 	ret

00416548 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  416548:	deffff04 	addi	sp,sp,-4
  41654c:	df000015 	stw	fp,0(sp)
  416550:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  416554:	e037883a 	mov	sp,fp
  416558:	df000017 	ldw	fp,0(sp)
  41655c:	dec00104 	addi	sp,sp,4
  416560:	f800283a 	ret

00416564 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  416564:	defffc04 	addi	sp,sp,-16
  416568:	df000315 	stw	fp,12(sp)
  41656c:	df000304 	addi	fp,sp,12
  416570:	e13ffd15 	stw	r4,-12(fp)
  416574:	e17ffe15 	stw	r5,-8(fp)
  416578:	e1bfff15 	stw	r6,-4(fp)
  return len;
  41657c:	e0bfff17 	ldw	r2,-4(fp)
}
  416580:	e037883a 	mov	sp,fp
  416584:	df000017 	ldw	fp,0(sp)
  416588:	dec00104 	addi	sp,sp,4
  41658c:	f800283a 	ret

00416590 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  416590:	defffe04 	addi	sp,sp,-8
  416594:	dfc00115 	stw	ra,4(sp)
  416598:	df000015 	stw	fp,0(sp)
  41659c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  4165a0:	00801074 	movhi	r2,65
  4165a4:	109f3c04 	addi	r2,r2,31984
  4165a8:	10800017 	ldw	r2,0(r2)
  4165ac:	10000526 	beq	r2,zero,4165c4 <alt_get_errno+0x34>
  4165b0:	00801074 	movhi	r2,65
  4165b4:	109f3c04 	addi	r2,r2,31984
  4165b8:	10800017 	ldw	r2,0(r2)
  4165bc:	103ee83a 	callr	r2
  4165c0:	00000206 	br	4165cc <alt_get_errno+0x3c>
  4165c4:	008010b4 	movhi	r2,66
  4165c8:	10a06804 	addi	r2,r2,-32352
}
  4165cc:	e037883a 	mov	sp,fp
  4165d0:	dfc00117 	ldw	ra,4(sp)
  4165d4:	df000017 	ldw	fp,0(sp)
  4165d8:	dec00204 	addi	sp,sp,8
  4165dc:	f800283a 	ret

004165e0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  4165e0:	defffa04 	addi	sp,sp,-24
  4165e4:	dfc00515 	stw	ra,20(sp)
  4165e8:	df000415 	stw	fp,16(sp)
  4165ec:	df000404 	addi	fp,sp,16
  4165f0:	e13ffe15 	stw	r4,-8(fp)
  4165f4:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  4165f8:	e0bffe17 	ldw	r2,-8(fp)
  4165fc:	10000326 	beq	r2,zero,41660c <alt_dev_llist_insert+0x2c>
  416600:	e0bffe17 	ldw	r2,-8(fp)
  416604:	10800217 	ldw	r2,8(r2)
  416608:	1000061e 	bne	r2,zero,416624 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
  41660c:	04165900 	call	416590 <alt_get_errno>
  416610:	1007883a 	mov	r3,r2
  416614:	00800584 	movi	r2,22
  416618:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  41661c:	00bffa84 	movi	r2,-22
  416620:	00001306 	br	416670 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  416624:	e0bffe17 	ldw	r2,-8(fp)
  416628:	e0ffff17 	ldw	r3,-4(fp)
  41662c:	e0fffc15 	stw	r3,-16(fp)
  416630:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  416634:	e0bffd17 	ldw	r2,-12(fp)
  416638:	e0fffc17 	ldw	r3,-16(fp)
  41663c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  416640:	e0bffc17 	ldw	r2,-16(fp)
  416644:	10c00017 	ldw	r3,0(r2)
  416648:	e0bffd17 	ldw	r2,-12(fp)
  41664c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  416650:	e0bffc17 	ldw	r2,-16(fp)
  416654:	10800017 	ldw	r2,0(r2)
  416658:	e0fffd17 	ldw	r3,-12(fp)
  41665c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  416660:	e0bffc17 	ldw	r2,-16(fp)
  416664:	e0fffd17 	ldw	r3,-12(fp)
  416668:	10c00015 	stw	r3,0(r2)

  return 0;  
  41666c:	0005883a 	mov	r2,zero
}
  416670:	e037883a 	mov	sp,fp
  416674:	dfc00117 	ldw	ra,4(sp)
  416678:	df000017 	ldw	fp,0(sp)
  41667c:	dec00204 	addi	sp,sp,8
  416680:	f800283a 	ret

00416684 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  416684:	defffd04 	addi	sp,sp,-12
  416688:	dfc00215 	stw	ra,8(sp)
  41668c:	df000115 	stw	fp,4(sp)
  416690:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  416694:	00801074 	movhi	r2,65
  416698:	109db804 	addi	r2,r2,30432
  41669c:	e0bfff15 	stw	r2,-4(fp)
  4166a0:	00000606 	br	4166bc <_do_ctors+0x38>
        (*ctor) (); 
  4166a4:	e0bfff17 	ldw	r2,-4(fp)
  4166a8:	10800017 	ldw	r2,0(r2)
  4166ac:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  4166b0:	e0bfff17 	ldw	r2,-4(fp)
  4166b4:	10bfff04 	addi	r2,r2,-4
  4166b8:	e0bfff15 	stw	r2,-4(fp)
  4166bc:	e0ffff17 	ldw	r3,-4(fp)
  4166c0:	00801074 	movhi	r2,65
  4166c4:	109db904 	addi	r2,r2,30436
  4166c8:	18bff62e 	bgeu	r3,r2,4166a4 <_gp+0xffff69d4>
        (*ctor) (); 
}
  4166cc:	e037883a 	mov	sp,fp
  4166d0:	dfc00117 	ldw	ra,4(sp)
  4166d4:	df000017 	ldw	fp,0(sp)
  4166d8:	dec00204 	addi	sp,sp,8
  4166dc:	f800283a 	ret

004166e0 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  4166e0:	defffd04 	addi	sp,sp,-12
  4166e4:	dfc00215 	stw	ra,8(sp)
  4166e8:	df000115 	stw	fp,4(sp)
  4166ec:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  4166f0:	00801074 	movhi	r2,65
  4166f4:	109db804 	addi	r2,r2,30432
  4166f8:	e0bfff15 	stw	r2,-4(fp)
  4166fc:	00000606 	br	416718 <_do_dtors+0x38>
        (*dtor) (); 
  416700:	e0bfff17 	ldw	r2,-4(fp)
  416704:	10800017 	ldw	r2,0(r2)
  416708:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  41670c:	e0bfff17 	ldw	r2,-4(fp)
  416710:	10bfff04 	addi	r2,r2,-4
  416714:	e0bfff15 	stw	r2,-4(fp)
  416718:	e0ffff17 	ldw	r3,-4(fp)
  41671c:	00801074 	movhi	r2,65
  416720:	109db904 	addi	r2,r2,30436
  416724:	18bff62e 	bgeu	r3,r2,416700 <_gp+0xffff6a30>
        (*dtor) (); 
}
  416728:	e037883a 	mov	sp,fp
  41672c:	dfc00117 	ldw	ra,4(sp)
  416730:	df000017 	ldw	fp,0(sp)
  416734:	dec00204 	addi	sp,sp,8
  416738:	f800283a 	ret

0041673c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
  41673c:	defffc04 	addi	sp,sp,-16
  416740:	dfc00315 	stw	ra,12(sp)
  416744:	df000215 	stw	fp,8(sp)
  416748:	df000204 	addi	fp,sp,8
  41674c:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
  416750:	e13fff17 	ldw	r4,-4(fp)
  416754:	d1600904 	addi	r5,gp,-32732
  416758:	04170e80 	call	4170e8 <alt_find_dev>
  41675c:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
  416760:	e0bffe17 	ldw	r2,-8(fp)
  416764:	10000926 	beq	r2,zero,41678c <alt_flash_open_dev+0x50>
  416768:	e0bffe17 	ldw	r2,-8(fp)
  41676c:	10800317 	ldw	r2,12(r2)
  416770:	10000626 	beq	r2,zero,41678c <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
  416774:	e0bffe17 	ldw	r2,-8(fp)
  416778:	10800317 	ldw	r2,12(r2)
  41677c:	e13ffe17 	ldw	r4,-8(fp)
  416780:	e17fff17 	ldw	r5,-4(fp)
  416784:	103ee83a 	callr	r2
  416788:	00000106 	br	416790 <alt_flash_open_dev+0x54>
  }

  return dev;
  41678c:	e0bffe17 	ldw	r2,-8(fp)
}
  416790:	e037883a 	mov	sp,fp
  416794:	dfc00117 	ldw	ra,4(sp)
  416798:	df000017 	ldw	fp,0(sp)
  41679c:	dec00204 	addi	sp,sp,8
  4167a0:	f800283a 	ret

004167a4 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
  4167a4:	defffd04 	addi	sp,sp,-12
  4167a8:	dfc00215 	stw	ra,8(sp)
  4167ac:	df000115 	stw	fp,4(sp)
  4167b0:	df000104 	addi	fp,sp,4
  4167b4:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
  4167b8:	e0bfff17 	ldw	r2,-4(fp)
  4167bc:	10000726 	beq	r2,zero,4167dc <alt_flash_close_dev+0x38>
  4167c0:	e0bfff17 	ldw	r2,-4(fp)
  4167c4:	10800417 	ldw	r2,16(r2)
  4167c8:	10000426 	beq	r2,zero,4167dc <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
  4167cc:	e0bfff17 	ldw	r2,-4(fp)
  4167d0:	10800417 	ldw	r2,16(r2)
  4167d4:	e13fff17 	ldw	r4,-4(fp)
  4167d8:	103ee83a 	callr	r2
  }
  return;
  4167dc:	0001883a 	nop
}
  4167e0:	e037883a 	mov	sp,fp
  4167e4:	dfc00117 	ldw	ra,4(sp)
  4167e8:	df000017 	ldw	fp,0(sp)
  4167ec:	dec00204 	addi	sp,sp,8
  4167f0:	f800283a 	ret

004167f4 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  4167f4:	deffff04 	addi	sp,sp,-4
  4167f8:	df000015 	stw	fp,0(sp)
  4167fc:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
  416800:	e037883a 	mov	sp,fp
  416804:	df000017 	ldw	fp,0(sp)
  416808:	dec00104 	addi	sp,sp,4
  41680c:	f800283a 	ret

00416810 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  416810:	defffe04 	addi	sp,sp,-8
  416814:	df000115 	stw	fp,4(sp)
  416818:	df000104 	addi	fp,sp,4
  41681c:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
  416820:	e0bfff17 	ldw	r2,-4(fp)
  416824:	10bffe84 	addi	r2,r2,-6
  416828:	10c00428 	cmpgeui	r3,r2,16
  41682c:	18001a1e 	bne	r3,zero,416898 <alt_exception_cause_generated_bad_addr+0x88>
  416830:	100690ba 	slli	r3,r2,2
  416834:	00801074 	movhi	r2,65
  416838:	109a1204 	addi	r2,r2,26696
  41683c:	1885883a 	add	r2,r3,r2
  416840:	10800017 	ldw	r2,0(r2)
  416844:	1000683a 	jmp	r2
  416848:	00416888 	cmpgei	at,zero,1442
  41684c:	00416888 	cmpgei	at,zero,1442
  416850:	00416898 	cmpnei	at,zero,1442
  416854:	00416898 	cmpnei	at,zero,1442
  416858:	00416898 	cmpnei	at,zero,1442
  41685c:	00416888 	cmpgei	at,zero,1442
  416860:	00416890 	cmplti	at,zero,1442
  416864:	00416898 	cmpnei	at,zero,1442
  416868:	00416888 	cmpgei	at,zero,1442
  41686c:	00416888 	cmpgei	at,zero,1442
  416870:	00416898 	cmpnei	at,zero,1442
  416874:	00416888 	cmpgei	at,zero,1442
  416878:	00416890 	cmplti	at,zero,1442
  41687c:	00416898 	cmpnei	at,zero,1442
  416880:	00416898 	cmpnei	at,zero,1442
  416884:	00416888 	cmpgei	at,zero,1442
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
  416888:	00800044 	movi	r2,1
  41688c:	00000306 	br	41689c <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
  416890:	0005883a 	mov	r2,zero
  416894:	00000106 	br	41689c <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
  416898:	0005883a 	mov	r2,zero
  }
}
  41689c:	e037883a 	mov	sp,fp
  4168a0:	df000017 	ldw	fp,0(sp)
  4168a4:	dec00104 	addi	sp,sp,4
  4168a8:	f800283a 	ret

004168ac <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  4168ac:	defff804 	addi	sp,sp,-32
  4168b0:	dfc00715 	stw	ra,28(sp)
  4168b4:	df000615 	stw	fp,24(sp)
  4168b8:	dc000515 	stw	r16,20(sp)
  4168bc:	df000604 	addi	fp,sp,24
  4168c0:	e13ffb15 	stw	r4,-20(fp)
  4168c4:	e17ffc15 	stw	r5,-16(fp)
  4168c8:	e1bffd15 	stw	r6,-12(fp)
  4168cc:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
  4168d0:	e13ffc17 	ldw	r4,-16(fp)
  4168d4:	e17ffd17 	ldw	r5,-12(fp)
  4168d8:	e1bffe17 	ldw	r6,-8(fp)
  4168dc:	0416b480 	call	416b48 <open>
  4168e0:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
  4168e4:	e0bffa17 	ldw	r2,-24(fp)
  4168e8:	10002216 	blt	r2,zero,416974 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
  4168ec:	04001074 	movhi	r16,65
  4168f0:	841ed404 	addi	r16,r16,31568
  4168f4:	e0bffa17 	ldw	r2,-24(fp)
  4168f8:	1009883a 	mov	r4,r2
  4168fc:	01400304 	movi	r5,12
  416900:	0411f000 	call	411f00 <__mulsi3>
  416904:	8085883a 	add	r2,r16,r2
  416908:	10c00017 	ldw	r3,0(r2)
  41690c:	e0bffb17 	ldw	r2,-20(fp)
  416910:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  416914:	04001074 	movhi	r16,65
  416918:	841ed404 	addi	r16,r16,31568
  41691c:	e0bffa17 	ldw	r2,-24(fp)
  416920:	1009883a 	mov	r4,r2
  416924:	01400304 	movi	r5,12
  416928:	0411f000 	call	411f00 <__mulsi3>
  41692c:	10800104 	addi	r2,r2,4
  416930:	8085883a 	add	r2,r16,r2
  416934:	10c00017 	ldw	r3,0(r2)
  416938:	e0bffb17 	ldw	r2,-20(fp)
  41693c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  416940:	04001074 	movhi	r16,65
  416944:	841ed404 	addi	r16,r16,31568
  416948:	e0bffa17 	ldw	r2,-24(fp)
  41694c:	1009883a 	mov	r4,r2
  416950:	01400304 	movi	r5,12
  416954:	0411f000 	call	411f00 <__mulsi3>
  416958:	10800204 	addi	r2,r2,8
  41695c:	8085883a 	add	r2,r16,r2
  416960:	10c00017 	ldw	r3,0(r2)
  416964:	e0bffb17 	ldw	r2,-20(fp)
  416968:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  41696c:	e13ffa17 	ldw	r4,-24(fp)
  416970:	0416ca80 	call	416ca8 <alt_release_fd>
  }
} 
  416974:	e6ffff04 	addi	sp,fp,-4
  416978:	dfc00217 	ldw	ra,8(sp)
  41697c:	df000117 	ldw	fp,4(sp)
  416980:	dc000017 	ldw	r16,0(sp)
  416984:	dec00304 	addi	sp,sp,12
  416988:	f800283a 	ret

0041698c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  41698c:	defffb04 	addi	sp,sp,-20
  416990:	dfc00415 	stw	ra,16(sp)
  416994:	df000315 	stw	fp,12(sp)
  416998:	df000304 	addi	fp,sp,12
  41699c:	e13ffd15 	stw	r4,-12(fp)
  4169a0:	e17ffe15 	stw	r5,-8(fp)
  4169a4:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  4169a8:	01001074 	movhi	r4,65
  4169ac:	211ed704 	addi	r4,r4,31580
  4169b0:	e17ffd17 	ldw	r5,-12(fp)
  4169b4:	01800044 	movi	r6,1
  4169b8:	01c07fc4 	movi	r7,511
  4169bc:	04168ac0 	call	4168ac <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  4169c0:	01001074 	movhi	r4,65
  4169c4:	211ed404 	addi	r4,r4,31568
  4169c8:	e17ffe17 	ldw	r5,-8(fp)
  4169cc:	000d883a 	mov	r6,zero
  4169d0:	01c07fc4 	movi	r7,511
  4169d4:	04168ac0 	call	4168ac <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  4169d8:	01001074 	movhi	r4,65
  4169dc:	211eda04 	addi	r4,r4,31592
  4169e0:	e17fff17 	ldw	r5,-4(fp)
  4169e4:	01800044 	movi	r6,1
  4169e8:	01c07fc4 	movi	r7,511
  4169ec:	04168ac0 	call	4168ac <alt_open_fd>
}  
  4169f0:	e037883a 	mov	sp,fp
  4169f4:	dfc00117 	ldw	ra,4(sp)
  4169f8:	df000017 	ldw	fp,0(sp)
  4169fc:	dec00204 	addi	sp,sp,8
  416a00:	f800283a 	ret

00416a04 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  416a04:	defffe04 	addi	sp,sp,-8
  416a08:	dfc00115 	stw	ra,4(sp)
  416a0c:	df000015 	stw	fp,0(sp)
  416a10:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  416a14:	00801074 	movhi	r2,65
  416a18:	109f3c04 	addi	r2,r2,31984
  416a1c:	10800017 	ldw	r2,0(r2)
  416a20:	10000526 	beq	r2,zero,416a38 <alt_get_errno+0x34>
  416a24:	00801074 	movhi	r2,65
  416a28:	109f3c04 	addi	r2,r2,31984
  416a2c:	10800017 	ldw	r2,0(r2)
  416a30:	103ee83a 	callr	r2
  416a34:	00000206 	br	416a40 <alt_get_errno+0x3c>
  416a38:	008010b4 	movhi	r2,66
  416a3c:	10a06804 	addi	r2,r2,-32352
}
  416a40:	e037883a 	mov	sp,fp
  416a44:	dfc00117 	ldw	ra,4(sp)
  416a48:	df000017 	ldw	fp,0(sp)
  416a4c:	dec00204 	addi	sp,sp,8
  416a50:	f800283a 	ret

00416a54 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  416a54:	defffb04 	addi	sp,sp,-20
  416a58:	dfc00415 	stw	ra,16(sp)
  416a5c:	df000315 	stw	fp,12(sp)
  416a60:	dc000215 	stw	r16,8(sp)
  416a64:	df000304 	addi	fp,sp,12
  416a68:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  416a6c:	e0bffe17 	ldw	r2,-8(fp)
  416a70:	10800217 	ldw	r2,8(r2)
  416a74:	10d00034 	orhi	r3,r2,16384
  416a78:	e0bffe17 	ldw	r2,-8(fp)
  416a7c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  416a80:	e03ffd15 	stw	zero,-12(fp)
  416a84:	00002306 	br	416b14 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  416a88:	04001074 	movhi	r16,65
  416a8c:	841ed404 	addi	r16,r16,31568
  416a90:	e0bffd17 	ldw	r2,-12(fp)
  416a94:	1009883a 	mov	r4,r2
  416a98:	01400304 	movi	r5,12
  416a9c:	0411f000 	call	411f00 <__mulsi3>
  416aa0:	8085883a 	add	r2,r16,r2
  416aa4:	10c00017 	ldw	r3,0(r2)
  416aa8:	e0bffe17 	ldw	r2,-8(fp)
  416aac:	10800017 	ldw	r2,0(r2)
  416ab0:	1880151e 	bne	r3,r2,416b08 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  416ab4:	04001074 	movhi	r16,65
  416ab8:	841ed404 	addi	r16,r16,31568
  416abc:	e0bffd17 	ldw	r2,-12(fp)
  416ac0:	1009883a 	mov	r4,r2
  416ac4:	01400304 	movi	r5,12
  416ac8:	0411f000 	call	411f00 <__mulsi3>
  416acc:	10800204 	addi	r2,r2,8
  416ad0:	8085883a 	add	r2,r16,r2
  416ad4:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  416ad8:	10000b0e 	bge	r2,zero,416b08 <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  416adc:	e13ffd17 	ldw	r4,-12(fp)
  416ae0:	01400304 	movi	r5,12
  416ae4:	0411f000 	call	411f00 <__mulsi3>
  416ae8:	1007883a 	mov	r3,r2
  416aec:	00801074 	movhi	r2,65
  416af0:	109ed404 	addi	r2,r2,31568
  416af4:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  416af8:	e0bffe17 	ldw	r2,-8(fp)
  416afc:	18800226 	beq	r3,r2,416b08 <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  416b00:	00bffcc4 	movi	r2,-13
  416b04:	00000a06 	br	416b30 <alt_file_locked+0xdc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  416b08:	e0bffd17 	ldw	r2,-12(fp)
  416b0c:	10800044 	addi	r2,r2,1
  416b10:	e0bffd15 	stw	r2,-12(fp)
  416b14:	00801074 	movhi	r2,65
  416b18:	109f3b04 	addi	r2,r2,31980
  416b1c:	10800017 	ldw	r2,0(r2)
  416b20:	1007883a 	mov	r3,r2
  416b24:	e0bffd17 	ldw	r2,-12(fp)
  416b28:	18bfd72e 	bgeu	r3,r2,416a88 <_gp+0xffff6db8>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  416b2c:	0005883a 	mov	r2,zero
}
  416b30:	e6ffff04 	addi	sp,fp,-4
  416b34:	dfc00217 	ldw	ra,8(sp)
  416b38:	df000117 	ldw	fp,4(sp)
  416b3c:	dc000017 	ldw	r16,0(sp)
  416b40:	dec00304 	addi	sp,sp,12
  416b44:	f800283a 	ret

00416b48 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  416b48:	defff604 	addi	sp,sp,-40
  416b4c:	dfc00915 	stw	ra,36(sp)
  416b50:	df000815 	stw	fp,32(sp)
  416b54:	df000804 	addi	fp,sp,32
  416b58:	e13ffd15 	stw	r4,-12(fp)
  416b5c:	e17ffe15 	stw	r5,-8(fp)
  416b60:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  416b64:	00bfffc4 	movi	r2,-1
  416b68:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  416b6c:	00bffb44 	movi	r2,-19
  416b70:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  416b74:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  416b78:	e13ffd17 	ldw	r4,-12(fp)
  416b7c:	01401074 	movhi	r5,65
  416b80:	295f3904 	addi	r5,r5,31972
  416b84:	04170e80 	call	4170e8 <alt_find_dev>
  416b88:	e0bff815 	stw	r2,-32(fp)
  416b8c:	e0bff817 	ldw	r2,-32(fp)
  416b90:	1000051e 	bne	r2,zero,416ba8 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  416b94:	e13ffd17 	ldw	r4,-12(fp)
  416b98:	04171780 	call	417178 <alt_find_file>
  416b9c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  416ba0:	00800044 	movi	r2,1
  416ba4:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  416ba8:	e0bff817 	ldw	r2,-32(fp)
  416bac:	10002b26 	beq	r2,zero,416c5c <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
  416bb0:	e13ff817 	ldw	r4,-32(fp)
  416bb4:	041728c0 	call	41728c <alt_get_fd>
  416bb8:	e0bff915 	stw	r2,-28(fp)
  416bbc:	e0bff917 	ldw	r2,-28(fp)
  416bc0:	1000030e 	bge	r2,zero,416bd0 <open+0x88>
    {
      status = index;
  416bc4:	e0bff917 	ldw	r2,-28(fp)
  416bc8:	e0bffa15 	stw	r2,-24(fp)
  416bcc:	00002506 	br	416c64 <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
  416bd0:	e13ff917 	ldw	r4,-28(fp)
  416bd4:	01400304 	movi	r5,12
  416bd8:	0411f000 	call	411f00 <__mulsi3>
  416bdc:	1007883a 	mov	r3,r2
  416be0:	00801074 	movhi	r2,65
  416be4:	109ed404 	addi	r2,r2,31568
  416be8:	1885883a 	add	r2,r3,r2
  416bec:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  416bf0:	e0fffe17 	ldw	r3,-8(fp)
  416bf4:	00900034 	movhi	r2,16384
  416bf8:	10bfffc4 	addi	r2,r2,-1
  416bfc:	1886703a 	and	r3,r3,r2
  416c00:	e0bffc17 	ldw	r2,-16(fp)
  416c04:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  416c08:	e0bffb17 	ldw	r2,-20(fp)
  416c0c:	1000051e 	bne	r2,zero,416c24 <open+0xdc>
  416c10:	e13ffc17 	ldw	r4,-16(fp)
  416c14:	0416a540 	call	416a54 <alt_file_locked>
  416c18:	e0bffa15 	stw	r2,-24(fp)
  416c1c:	e0bffa17 	ldw	r2,-24(fp)
  416c20:	10001016 	blt	r2,zero,416c64 <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  416c24:	e0bff817 	ldw	r2,-32(fp)
  416c28:	10800317 	ldw	r2,12(r2)
  416c2c:	10000826 	beq	r2,zero,416c50 <open+0x108>
  416c30:	e0bff817 	ldw	r2,-32(fp)
  416c34:	10800317 	ldw	r2,12(r2)
  416c38:	e13ffc17 	ldw	r4,-16(fp)
  416c3c:	e17ffd17 	ldw	r5,-12(fp)
  416c40:	e1bffe17 	ldw	r6,-8(fp)
  416c44:	e1ffff17 	ldw	r7,-4(fp)
  416c48:	103ee83a 	callr	r2
  416c4c:	00000106 	br	416c54 <open+0x10c>
  416c50:	0005883a 	mov	r2,zero
  416c54:	e0bffa15 	stw	r2,-24(fp)
  416c58:	00000206 	br	416c64 <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
  416c5c:	00bffb44 	movi	r2,-19
  416c60:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  416c64:	e0bffa17 	ldw	r2,-24(fp)
  416c68:	1000090e 	bge	r2,zero,416c90 <open+0x148>
  {
    alt_release_fd (index);  
  416c6c:	e13ff917 	ldw	r4,-28(fp)
  416c70:	0416ca80 	call	416ca8 <alt_release_fd>
    ALT_ERRNO = -status;
  416c74:	0416a040 	call	416a04 <alt_get_errno>
  416c78:	1007883a 	mov	r3,r2
  416c7c:	e0bffa17 	ldw	r2,-24(fp)
  416c80:	0085c83a 	sub	r2,zero,r2
  416c84:	18800015 	stw	r2,0(r3)
    return -1;
  416c88:	00bfffc4 	movi	r2,-1
  416c8c:	00000106 	br	416c94 <open+0x14c>
  }
  
  /* return the reference upon success */

  return index;
  416c90:	e0bff917 	ldw	r2,-28(fp)
}
  416c94:	e037883a 	mov	sp,fp
  416c98:	dfc00117 	ldw	ra,4(sp)
  416c9c:	df000017 	ldw	fp,0(sp)
  416ca0:	dec00204 	addi	sp,sp,8
  416ca4:	f800283a 	ret

00416ca8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  416ca8:	defffc04 	addi	sp,sp,-16
  416cac:	dfc00315 	stw	ra,12(sp)
  416cb0:	df000215 	stw	fp,8(sp)
  416cb4:	dc000115 	stw	r16,4(sp)
  416cb8:	df000204 	addi	fp,sp,8
  416cbc:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
  416cc0:	e0bffe17 	ldw	r2,-8(fp)
  416cc4:	108000d0 	cmplti	r2,r2,3
  416cc8:	1000111e 	bne	r2,zero,416d10 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
  416ccc:	04001074 	movhi	r16,65
  416cd0:	841ed404 	addi	r16,r16,31568
  416cd4:	e0bffe17 	ldw	r2,-8(fp)
  416cd8:	1009883a 	mov	r4,r2
  416cdc:	01400304 	movi	r5,12
  416ce0:	0411f000 	call	411f00 <__mulsi3>
  416ce4:	10800204 	addi	r2,r2,8
  416ce8:	8085883a 	add	r2,r16,r2
  416cec:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  416cf0:	04001074 	movhi	r16,65
  416cf4:	841ed404 	addi	r16,r16,31568
  416cf8:	e0bffe17 	ldw	r2,-8(fp)
  416cfc:	1009883a 	mov	r4,r2
  416d00:	01400304 	movi	r5,12
  416d04:	0411f000 	call	411f00 <__mulsi3>
  416d08:	8085883a 	add	r2,r16,r2
  416d0c:	10000015 	stw	zero,0(r2)
  }
}
  416d10:	e6ffff04 	addi	sp,fp,-4
  416d14:	dfc00217 	ldw	ra,8(sp)
  416d18:	df000117 	ldw	fp,4(sp)
  416d1c:	dc000017 	ldw	r16,0(sp)
  416d20:	dec00304 	addi	sp,sp,12
  416d24:	f800283a 	ret

00416d28 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  416d28:	defffa04 	addi	sp,sp,-24
  416d2c:	df000515 	stw	fp,20(sp)
  416d30:	df000504 	addi	fp,sp,20
  416d34:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  416d38:	0005303a 	rdctl	r2,status
  416d3c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  416d40:	e0fffc17 	ldw	r3,-16(fp)
  416d44:	00bfff84 	movi	r2,-2
  416d48:	1884703a 	and	r2,r3,r2
  416d4c:	1001703a 	wrctl	status,r2
  
  return context;
  416d50:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  416d54:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  416d58:	e0bfff17 	ldw	r2,-4(fp)
  416d5c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  416d60:	e0bffd17 	ldw	r2,-12(fp)
  416d64:	10800017 	ldw	r2,0(r2)
  416d68:	e0fffd17 	ldw	r3,-12(fp)
  416d6c:	18c00117 	ldw	r3,4(r3)
  416d70:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  416d74:	e0bffd17 	ldw	r2,-12(fp)
  416d78:	10800117 	ldw	r2,4(r2)
  416d7c:	e0fffd17 	ldw	r3,-12(fp)
  416d80:	18c00017 	ldw	r3,0(r3)
  416d84:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  416d88:	e0bffd17 	ldw	r2,-12(fp)
  416d8c:	e0fffd17 	ldw	r3,-12(fp)
  416d90:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  416d94:	e0bffd17 	ldw	r2,-12(fp)
  416d98:	e0fffd17 	ldw	r3,-12(fp)
  416d9c:	10c00015 	stw	r3,0(r2)
  416da0:	e0bffb17 	ldw	r2,-20(fp)
  416da4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  416da8:	e0bffe17 	ldw	r2,-8(fp)
  416dac:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  416db0:	e037883a 	mov	sp,fp
  416db4:	df000017 	ldw	fp,0(sp)
  416db8:	dec00104 	addi	sp,sp,4
  416dbc:	f800283a 	ret

00416dc0 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  416dc0:	defffb04 	addi	sp,sp,-20
  416dc4:	dfc00415 	stw	ra,16(sp)
  416dc8:	df000315 	stw	fp,12(sp)
  416dcc:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  416dd0:	d0a00b17 	ldw	r2,-32724(gp)
  416dd4:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  416dd8:	d0a13d17 	ldw	r2,-31500(gp)
  416ddc:	10800044 	addi	r2,r2,1
  416de0:	d0a13d15 	stw	r2,-31500(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  416de4:	00002e06 	br	416ea0 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  416de8:	e0bffd17 	ldw	r2,-12(fp)
  416dec:	10800017 	ldw	r2,0(r2)
  416df0:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  416df4:	e0bffd17 	ldw	r2,-12(fp)
  416df8:	10800403 	ldbu	r2,16(r2)
  416dfc:	10803fcc 	andi	r2,r2,255
  416e00:	10000426 	beq	r2,zero,416e14 <alt_tick+0x54>
  416e04:	d0a13d17 	ldw	r2,-31500(gp)
  416e08:	1000021e 	bne	r2,zero,416e14 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  416e0c:	e0bffd17 	ldw	r2,-12(fp)
  416e10:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  416e14:	e0bffd17 	ldw	r2,-12(fp)
  416e18:	10800217 	ldw	r2,8(r2)
  416e1c:	d0e13d17 	ldw	r3,-31500(gp)
  416e20:	18801d36 	bltu	r3,r2,416e98 <alt_tick+0xd8>
  416e24:	e0bffd17 	ldw	r2,-12(fp)
  416e28:	10800403 	ldbu	r2,16(r2)
  416e2c:	10803fcc 	andi	r2,r2,255
  416e30:	1000191e 	bne	r2,zero,416e98 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  416e34:	e0bffd17 	ldw	r2,-12(fp)
  416e38:	10800317 	ldw	r2,12(r2)
  416e3c:	e0fffd17 	ldw	r3,-12(fp)
  416e40:	18c00517 	ldw	r3,20(r3)
  416e44:	1809883a 	mov	r4,r3
  416e48:	103ee83a 	callr	r2
  416e4c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  416e50:	e0bfff17 	ldw	r2,-4(fp)
  416e54:	1000031e 	bne	r2,zero,416e64 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  416e58:	e13ffd17 	ldw	r4,-12(fp)
  416e5c:	0416d280 	call	416d28 <alt_alarm_stop>
  416e60:	00000d06 	br	416e98 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  416e64:	e0bffd17 	ldw	r2,-12(fp)
  416e68:	10c00217 	ldw	r3,8(r2)
  416e6c:	e0bfff17 	ldw	r2,-4(fp)
  416e70:	1887883a 	add	r3,r3,r2
  416e74:	e0bffd17 	ldw	r2,-12(fp)
  416e78:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  416e7c:	e0bffd17 	ldw	r2,-12(fp)
  416e80:	10c00217 	ldw	r3,8(r2)
  416e84:	d0a13d17 	ldw	r2,-31500(gp)
  416e88:	1880032e 	bgeu	r3,r2,416e98 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  416e8c:	e0bffd17 	ldw	r2,-12(fp)
  416e90:	00c00044 	movi	r3,1
  416e94:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  416e98:	e0bffe17 	ldw	r2,-8(fp)
  416e9c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  416ea0:	e0fffd17 	ldw	r3,-12(fp)
  416ea4:	d0a00b04 	addi	r2,gp,-32724
  416ea8:	18bfcf1e 	bne	r3,r2,416de8 <_gp+0xffff7118>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  416eac:	0001883a 	nop
}
  416eb0:	e037883a 	mov	sp,fp
  416eb4:	dfc00117 	ldw	ra,4(sp)
  416eb8:	df000017 	ldw	fp,0(sp)
  416ebc:	dec00204 	addi	sp,sp,8
  416ec0:	f800283a 	ret

00416ec4 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  416ec4:	deffff04 	addi	sp,sp,-4
  416ec8:	df000015 	stw	fp,0(sp)
  416ecc:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  416ed0:	000170fa 	wrctl	ienable,zero
}
  416ed4:	e037883a 	mov	sp,fp
  416ed8:	df000017 	ldw	fp,0(sp)
  416edc:	dec00104 	addi	sp,sp,4
  416ee0:	f800283a 	ret

00416ee4 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  416ee4:	defff404 	addi	sp,sp,-48
  416ee8:	df000b15 	stw	fp,44(sp)
  416eec:	df000b04 	addi	fp,sp,44
  416ef0:	e13ffc15 	stw	r4,-16(fp)
  416ef4:	e17ffd15 	stw	r5,-12(fp)
  416ef8:	e1bffe15 	stw	r6,-8(fp)
  416efc:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
  416f00:	e0ffff17 	ldw	r3,-4(fp)
  416f04:	e0bffe17 	ldw	r2,-8(fp)
  416f08:	1885883a 	add	r2,r3,r2
  416f0c:	e0bff815 	stw	r2,-32(fp)
  alt_u8 * read_end = read_data + read_length;
  416f10:	e0c00217 	ldw	r3,8(fp)
  416f14:	e0800117 	ldw	r2,4(fp)
  416f18:	1885883a 	add	r2,r3,r2
  416f1c:	e0bff915 	stw	r2,-28(fp)

  alt_u32 write_zeros = read_length;
  416f20:	e0800117 	ldw	r2,4(fp)
  416f24:	e0bff515 	stw	r2,-44(fp)
  alt_u32 read_ignore = write_length;
  416f28:	e0bffe17 	ldw	r2,-8(fp)
  416f2c:	e0bff615 	stw	r2,-40(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
  416f30:	00800044 	movi	r2,1
  416f34:	e0bff715 	stw	r2,-36(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
  416f38:	e0bffc17 	ldw	r2,-16(fp)
  416f3c:	10800504 	addi	r2,r2,20
  416f40:	1009883a 	mov	r4,r2
  416f44:	e0bffd17 	ldw	r2,-12(fp)
  416f48:	00c00044 	movi	r3,1
  416f4c:	1884983a 	sll	r2,r3,r2
  416f50:	20800035 	stwio	r2,0(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
  416f54:	e0800317 	ldw	r2,12(fp)
  416f58:	1080008c 	andi	r2,r2,2
  416f5c:	1000051e 	bne	r2,zero,416f74 <alt_avalon_spi_command+0x90>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
  416f60:	e0bffc17 	ldw	r2,-16(fp)
  416f64:	10800304 	addi	r2,r2,12
  416f68:	1007883a 	mov	r3,r2
  416f6c:	00810004 	movi	r2,1024
  416f70:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
  416f74:	e0bffc17 	ldw	r2,-16(fp)
  416f78:	10800037 	ldwio	r2,0(r2)
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  416f7c:	e0bffc17 	ldw	r2,-16(fp)
  416f80:	10800204 	addi	r2,r2,8
  416f84:	10800037 	ldwio	r2,0(r2)
  416f88:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  416f8c:	e0bffa17 	ldw	r2,-24(fp)
  416f90:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
  416f94:	10000226 	beq	r2,zero,416fa0 <alt_avalon_spi_command+0xbc>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  416f98:	e0bff717 	ldw	r2,-36(fp)
  416f9c:	1000031e 	bne	r2,zero,416fac <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
  416fa0:	e0bffa17 	ldw	r2,-24(fp)
  416fa4:	1080200c 	andi	r2,r2,128
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  416fa8:	103ff426 	beq	r2,zero,416f7c <_gp+0xffff72ac>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
  416fac:	e0bffa17 	ldw	r2,-24(fp)
  416fb0:	1080100c 	andi	r2,r2,64
  416fb4:	10001e26 	beq	r2,zero,417030 <alt_avalon_spi_command+0x14c>
  416fb8:	e0bff717 	ldw	r2,-36(fp)
  416fbc:	00801c0e 	bge	zero,r2,417030 <alt_avalon_spi_command+0x14c>
    {
      credits--;
  416fc0:	e0bff717 	ldw	r2,-36(fp)
  416fc4:	10bfffc4 	addi	r2,r2,-1
  416fc8:	e0bff715 	stw	r2,-36(fp)

      if (write_data < write_end)
  416fcc:	e0ffff17 	ldw	r3,-4(fp)
  416fd0:	e0bff817 	ldw	r2,-32(fp)
  416fd4:	18800a2e 	bgeu	r3,r2,417000 <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
  416fd8:	e0bffc17 	ldw	r2,-16(fp)
  416fdc:	10800104 	addi	r2,r2,4
  416fe0:	1009883a 	mov	r4,r2
  416fe4:	e0bfff17 	ldw	r2,-4(fp)
  416fe8:	10c00044 	addi	r3,r2,1
  416fec:	e0ffff15 	stw	r3,-4(fp)
  416ff0:	10800003 	ldbu	r2,0(r2)
  416ff4:	10803fcc 	andi	r2,r2,255
  416ff8:	20800035 	stwio	r2,0(r4)
  416ffc:	00000c06 	br	417030 <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
  417000:	e0bff517 	ldw	r2,-44(fp)
  417004:	10000826 	beq	r2,zero,417028 <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
  417008:	e0bff517 	ldw	r2,-44(fp)
  41700c:	10bfffc4 	addi	r2,r2,-1
  417010:	e0bff515 	stw	r2,-44(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
  417014:	e0bffc17 	ldw	r2,-16(fp)
  417018:	10800104 	addi	r2,r2,4
  41701c:	0007883a 	mov	r3,zero
  417020:	10c00035 	stwio	r3,0(r2)
  417024:	00000206 	br	417030 <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
  417028:	00bf0004 	movi	r2,-1024
  41702c:	e0bff715 	stw	r2,-36(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
  417030:	e0bffa17 	ldw	r2,-24(fp)
  417034:	1080200c 	andi	r2,r2,128
  417038:	10001726 	beq	r2,zero,417098 <alt_avalon_spi_command+0x1b4>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
  41703c:	e0bffc17 	ldw	r2,-16(fp)
  417040:	10800037 	ldwio	r2,0(r2)
  417044:	e0bffb15 	stw	r2,-20(fp)

      if (read_ignore > 0)
  417048:	e0bff617 	ldw	r2,-40(fp)
  41704c:	10000426 	beq	r2,zero,417060 <alt_avalon_spi_command+0x17c>
        read_ignore--;
  417050:	e0bff617 	ldw	r2,-40(fp)
  417054:	10bfffc4 	addi	r2,r2,-1
  417058:	e0bff615 	stw	r2,-40(fp)
  41705c:	00000506 	br	417074 <alt_avalon_spi_command+0x190>
      else
        *read_data++ = (alt_u8)rxdata;
  417060:	e0800217 	ldw	r2,8(fp)
  417064:	10c00044 	addi	r3,r2,1
  417068:	e0c00215 	stw	r3,8(fp)
  41706c:	e0fffb17 	ldw	r3,-20(fp)
  417070:	10c00005 	stb	r3,0(r2)
      credits++;
  417074:	e0bff717 	ldw	r2,-36(fp)
  417078:	10800044 	addi	r2,r2,1
  41707c:	e0bff715 	stw	r2,-36(fp)

      if (read_ignore == 0 && read_data == read_end)
  417080:	e0bff617 	ldw	r2,-40(fp)
  417084:	1000041e 	bne	r2,zero,417098 <alt_avalon_spi_command+0x1b4>
  417088:	e0c00217 	ldw	r3,8(fp)
  41708c:	e0bff917 	ldw	r2,-28(fp)
  417090:	1880011e 	bne	r3,r2,417098 <alt_avalon_spi_command+0x1b4>
        break;
  417094:	00000106 	br	41709c <alt_avalon_spi_command+0x1b8>
    }
    
  }
  417098:	003fb806 	br	416f7c <_gp+0xffff72ac>

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  41709c:	e0bffc17 	ldw	r2,-16(fp)
  4170a0:	10800204 	addi	r2,r2,8
  4170a4:	10800037 	ldwio	r2,0(r2)
  4170a8:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
  4170ac:	e0bffa17 	ldw	r2,-24(fp)
  4170b0:	1080080c 	andi	r2,r2,32
  4170b4:	103ff926 	beq	r2,zero,41709c <_gp+0xffff73cc>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
  4170b8:	e0800317 	ldw	r2,12(fp)
  4170bc:	1080004c 	andi	r2,r2,1
  4170c0:	1000041e 	bne	r2,zero,4170d4 <alt_avalon_spi_command+0x1f0>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
  4170c4:	e0bffc17 	ldw	r2,-16(fp)
  4170c8:	10800304 	addi	r2,r2,12
  4170cc:	0007883a 	mov	r3,zero
  4170d0:	10c00035 	stwio	r3,0(r2)

  return read_length;
  4170d4:	e0800117 	ldw	r2,4(fp)
}
  4170d8:	e037883a 	mov	sp,fp
  4170dc:	df000017 	ldw	fp,0(sp)
  4170e0:	dec00104 	addi	sp,sp,4
  4170e4:	f800283a 	ret

004170e8 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  4170e8:	defffa04 	addi	sp,sp,-24
  4170ec:	dfc00515 	stw	ra,20(sp)
  4170f0:	df000415 	stw	fp,16(sp)
  4170f4:	df000404 	addi	fp,sp,16
  4170f8:	e13ffe15 	stw	r4,-8(fp)
  4170fc:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  417100:	e0bfff17 	ldw	r2,-4(fp)
  417104:	10800017 	ldw	r2,0(r2)
  417108:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  41710c:	e13ffe17 	ldw	r4,-8(fp)
  417110:	04130800 	call	413080 <strlen>
  417114:	10800044 	addi	r2,r2,1
  417118:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  41711c:	00000d06 	br	417154 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  417120:	e0bffc17 	ldw	r2,-16(fp)
  417124:	10c00217 	ldw	r3,8(r2)
  417128:	e0bffd17 	ldw	r2,-12(fp)
  41712c:	1809883a 	mov	r4,r3
  417130:	e17ffe17 	ldw	r5,-8(fp)
  417134:	100d883a 	mov	r6,r2
  417138:	04173940 	call	417394 <memcmp>
  41713c:	1000021e 	bne	r2,zero,417148 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  417140:	e0bffc17 	ldw	r2,-16(fp)
  417144:	00000706 	br	417164 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  417148:	e0bffc17 	ldw	r2,-16(fp)
  41714c:	10800017 	ldw	r2,0(r2)
  417150:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  417154:	e0fffc17 	ldw	r3,-16(fp)
  417158:	e0bfff17 	ldw	r2,-4(fp)
  41715c:	18bff01e 	bne	r3,r2,417120 <_gp+0xffff7450>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  417160:	0005883a 	mov	r2,zero
}
  417164:	e037883a 	mov	sp,fp
  417168:	dfc00117 	ldw	ra,4(sp)
  41716c:	df000017 	ldw	fp,0(sp)
  417170:	dec00204 	addi	sp,sp,8
  417174:	f800283a 	ret

00417178 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  417178:	defffb04 	addi	sp,sp,-20
  41717c:	dfc00415 	stw	ra,16(sp)
  417180:	df000315 	stw	fp,12(sp)
  417184:	df000304 	addi	fp,sp,12
  417188:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  41718c:	00801074 	movhi	r2,65
  417190:	109f3704 	addi	r2,r2,31964
  417194:	10800017 	ldw	r2,0(r2)
  417198:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  41719c:	00003106 	br	417264 <alt_find_file+0xec>
  {
    len = strlen(next->name);
  4171a0:	e0bffd17 	ldw	r2,-12(fp)
  4171a4:	10800217 	ldw	r2,8(r2)
  4171a8:	1009883a 	mov	r4,r2
  4171ac:	04130800 	call	413080 <strlen>
  4171b0:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  4171b4:	e0bffd17 	ldw	r2,-12(fp)
  4171b8:	10c00217 	ldw	r3,8(r2)
  4171bc:	e0bffe17 	ldw	r2,-8(fp)
  4171c0:	10bfffc4 	addi	r2,r2,-1
  4171c4:	1885883a 	add	r2,r3,r2
  4171c8:	10800003 	ldbu	r2,0(r2)
  4171cc:	10803fcc 	andi	r2,r2,255
  4171d0:	1080201c 	xori	r2,r2,128
  4171d4:	10bfe004 	addi	r2,r2,-128
  4171d8:	10800bd8 	cmpnei	r2,r2,47
  4171dc:	1000031e 	bne	r2,zero,4171ec <alt_find_file+0x74>
    {
      len -= 1;
  4171e0:	e0bffe17 	ldw	r2,-8(fp)
  4171e4:	10bfffc4 	addi	r2,r2,-1
  4171e8:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  4171ec:	e0bffe17 	ldw	r2,-8(fp)
  4171f0:	e0ffff17 	ldw	r3,-4(fp)
  4171f4:	1885883a 	add	r2,r3,r2
  4171f8:	10800003 	ldbu	r2,0(r2)
  4171fc:	10803fcc 	andi	r2,r2,255
  417200:	1080201c 	xori	r2,r2,128
  417204:	10bfe004 	addi	r2,r2,-128
  417208:	10800be0 	cmpeqi	r2,r2,47
  41720c:	1000081e 	bne	r2,zero,417230 <alt_find_file+0xb8>
  417210:	e0bffe17 	ldw	r2,-8(fp)
  417214:	e0ffff17 	ldw	r3,-4(fp)
  417218:	1885883a 	add	r2,r3,r2
  41721c:	10800003 	ldbu	r2,0(r2)
  417220:	10803fcc 	andi	r2,r2,255
  417224:	1080201c 	xori	r2,r2,128
  417228:	10bfe004 	addi	r2,r2,-128
  41722c:	10000a1e 	bne	r2,zero,417258 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  417230:	e0bffd17 	ldw	r2,-12(fp)
  417234:	10c00217 	ldw	r3,8(r2)
  417238:	e0bffe17 	ldw	r2,-8(fp)
  41723c:	1809883a 	mov	r4,r3
  417240:	e17fff17 	ldw	r5,-4(fp)
  417244:	100d883a 	mov	r6,r2
  417248:	04173940 	call	417394 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  41724c:	1000021e 	bne	r2,zero,417258 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  417250:	e0bffd17 	ldw	r2,-12(fp)
  417254:	00000806 	br	417278 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  417258:	e0bffd17 	ldw	r2,-12(fp)
  41725c:	10800017 	ldw	r2,0(r2)
  417260:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  417264:	e0fffd17 	ldw	r3,-12(fp)
  417268:	00801074 	movhi	r2,65
  41726c:	109f3704 	addi	r2,r2,31964
  417270:	18bfcb1e 	bne	r3,r2,4171a0 <_gp+0xffff74d0>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  417274:	0005883a 	mov	r2,zero
}
  417278:	e037883a 	mov	sp,fp
  41727c:	dfc00117 	ldw	ra,4(sp)
  417280:	df000017 	ldw	fp,0(sp)
  417284:	dec00204 	addi	sp,sp,8
  417288:	f800283a 	ret

0041728c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  41728c:	defffa04 	addi	sp,sp,-24
  417290:	dfc00515 	stw	ra,20(sp)
  417294:	df000415 	stw	fp,16(sp)
  417298:	dc000315 	stw	r16,12(sp)
  41729c:	df000404 	addi	fp,sp,16
  4172a0:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
  4172a4:	00bffa04 	movi	r2,-24
  4172a8:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  4172ac:	e03ffc15 	stw	zero,-16(fp)
  4172b0:	00002106 	br	417338 <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
  4172b4:	04001074 	movhi	r16,65
  4172b8:	841ed404 	addi	r16,r16,31568
  4172bc:	e0bffc17 	ldw	r2,-16(fp)
  4172c0:	1009883a 	mov	r4,r2
  4172c4:	01400304 	movi	r5,12
  4172c8:	0411f000 	call	411f00 <__mulsi3>
  4172cc:	8085883a 	add	r2,r16,r2
  4172d0:	10800017 	ldw	r2,0(r2)
  4172d4:	1000151e 	bne	r2,zero,41732c <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
  4172d8:	04001074 	movhi	r16,65
  4172dc:	841ed404 	addi	r16,r16,31568
  4172e0:	e0bffc17 	ldw	r2,-16(fp)
  4172e4:	1009883a 	mov	r4,r2
  4172e8:	01400304 	movi	r5,12
  4172ec:	0411f000 	call	411f00 <__mulsi3>
  4172f0:	8085883a 	add	r2,r16,r2
  4172f4:	e0fffe17 	ldw	r3,-8(fp)
  4172f8:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  4172fc:	00801074 	movhi	r2,65
  417300:	109f3b04 	addi	r2,r2,31980
  417304:	10c00017 	ldw	r3,0(r2)
  417308:	e0bffc17 	ldw	r2,-16(fp)
  41730c:	1880040e 	bge	r3,r2,417320 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
  417310:	00801074 	movhi	r2,65
  417314:	109f3b04 	addi	r2,r2,31980
  417318:	e0fffc17 	ldw	r3,-16(fp)
  41731c:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  417320:	e0bffc17 	ldw	r2,-16(fp)
  417324:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
  417328:	00000606 	br	417344 <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  41732c:	e0bffc17 	ldw	r2,-16(fp)
  417330:	10800044 	addi	r2,r2,1
  417334:	e0bffc15 	stw	r2,-16(fp)
  417338:	e0bffc17 	ldw	r2,-16(fp)
  41733c:	10800810 	cmplti	r2,r2,32
  417340:	103fdc1e 	bne	r2,zero,4172b4 <_gp+0xffff75e4>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  417344:	e0bffd17 	ldw	r2,-12(fp)
}
  417348:	e6ffff04 	addi	sp,fp,-4
  41734c:	dfc00217 	ldw	ra,8(sp)
  417350:	df000117 	ldw	fp,4(sp)
  417354:	dc000017 	ldw	r16,0(sp)
  417358:	dec00304 	addi	sp,sp,12
  41735c:	f800283a 	ret

00417360 <atexit>:
  417360:	200b883a 	mov	r5,r4
  417364:	000d883a 	mov	r6,zero
  417368:	0009883a 	mov	r4,zero
  41736c:	000f883a 	mov	r7,zero
  417370:	04173c41 	jmpi	4173c4 <__register_exitproc>

00417374 <exit>:
  417374:	defffe04 	addi	sp,sp,-8
  417378:	000b883a 	mov	r5,zero
  41737c:	dc000015 	stw	r16,0(sp)
  417380:	dfc00115 	stw	ra,4(sp)
  417384:	2021883a 	mov	r16,r4
  417388:	04175140 	call	417514 <__call_exitprocs>
  41738c:	8009883a 	mov	r4,r16
  417390:	04176b00 	call	4176b0 <_exit>

00417394 <memcmp>:
  417394:	218d883a 	add	r6,r4,r6
  417398:	21800826 	beq	r4,r6,4173bc <memcmp+0x28>
  41739c:	20800003 	ldbu	r2,0(r4)
  4173a0:	28c00003 	ldbu	r3,0(r5)
  4173a4:	10c00226 	beq	r2,r3,4173b0 <memcmp+0x1c>
  4173a8:	10c5c83a 	sub	r2,r2,r3
  4173ac:	f800283a 	ret
  4173b0:	21000044 	addi	r4,r4,1
  4173b4:	29400044 	addi	r5,r5,1
  4173b8:	003ff706 	br	417398 <_gp+0xffff76c8>
  4173bc:	0005883a 	mov	r2,zero
  4173c0:	f800283a 	ret

004173c4 <__register_exitproc>:
  4173c4:	00801074 	movhi	r2,65
  4173c8:	defff904 	addi	sp,sp,-28
  4173cc:	109f3404 	addi	r2,r2,31952
  4173d0:	dcc00315 	stw	r19,12(sp)
  4173d4:	14c00017 	ldw	r19,0(r2)
  4173d8:	dc000015 	stw	r16,0(sp)
  4173dc:	dd400515 	stw	r21,20(sp)
  4173e0:	9c000c17 	ldw	r16,48(r19)
  4173e4:	dd000415 	stw	r20,16(sp)
  4173e8:	dc800215 	stw	r18,8(sp)
  4173ec:	dc400115 	stw	r17,4(sp)
  4173f0:	dfc00615 	stw	ra,24(sp)
  4173f4:	202b883a 	mov	r21,r4
  4173f8:	2823883a 	mov	r17,r5
  4173fc:	3029883a 	mov	r20,r6
  417400:	3825883a 	mov	r18,r7
  417404:	8000021e 	bne	r16,zero,417410 <__register_exitproc+0x4c>
  417408:	9c000d04 	addi	r16,r19,52
  41740c:	9c000c15 	stw	r16,48(r19)
  417410:	80800117 	ldw	r2,4(r16)
  417414:	00c007c4 	movi	r3,31
  417418:	1880100e 	bge	r3,r2,41745c <__register_exitproc+0x98>
  41741c:	00800034 	movhi	r2,0
  417420:	10800004 	addi	r2,r2,0
  417424:	1000021e 	bne	r2,zero,417430 <__register_exitproc+0x6c>
  417428:	00bfffc4 	movi	r2,-1
  41742c:	00003006 	br	4174f0 <__register_exitproc+0x12c>
  417430:	01002304 	movi	r4,140
  417434:	00000000 	call	0 <__alt_mem_epcs_flash_controller_0-0x21000>
  417438:	1021883a 	mov	r16,r2
  41743c:	103ffa26 	beq	r2,zero,417428 <_gp+0xffff7758>
  417440:	10000115 	stw	zero,4(r2)
  417444:	98800c17 	ldw	r2,48(r19)
  417448:	80800015 	stw	r2,0(r16)
  41744c:	9c000c15 	stw	r16,48(r19)
  417450:	80002215 	stw	zero,136(r16)
  417454:	a800071e 	bne	r21,zero,417474 <__register_exitproc+0xb0>
  417458:	00001c06 	br	4174cc <__register_exitproc+0x108>
  41745c:	a8001b26 	beq	r21,zero,4174cc <__register_exitproc+0x108>
  417460:	80802217 	ldw	r2,136(r16)
  417464:	1000091e 	bne	r2,zero,41748c <__register_exitproc+0xc8>
  417468:	00800034 	movhi	r2,0
  41746c:	10800004 	addi	r2,r2,0
  417470:	103fed26 	beq	r2,zero,417428 <_gp+0xffff7758>
  417474:	01004204 	movi	r4,264
  417478:	00000000 	call	0 <__alt_mem_epcs_flash_controller_0-0x21000>
  41747c:	103fea26 	beq	r2,zero,417428 <_gp+0xffff7758>
  417480:	10004015 	stw	zero,256(r2)
  417484:	10004115 	stw	zero,260(r2)
  417488:	80802215 	stw	r2,136(r16)
  41748c:	81000117 	ldw	r4,4(r16)
  417490:	01400044 	movi	r5,1
  417494:	2107883a 	add	r3,r4,r4
  417498:	18c7883a 	add	r3,r3,r3
  41749c:	10c7883a 	add	r3,r2,r3
  4174a0:	1d000015 	stw	r20,0(r3)
  4174a4:	290a983a 	sll	r5,r5,r4
  4174a8:	11004017 	ldw	r4,256(r2)
  4174ac:	2148b03a 	or	r4,r4,r5
  4174b0:	11004015 	stw	r4,256(r2)
  4174b4:	1c802015 	stw	r18,128(r3)
  4174b8:	00c00084 	movi	r3,2
  4174bc:	a8c0031e 	bne	r21,r3,4174cc <__register_exitproc+0x108>
  4174c0:	10c04117 	ldw	r3,260(r2)
  4174c4:	194ab03a 	or	r5,r3,r5
  4174c8:	11404115 	stw	r5,260(r2)
  4174cc:	80800117 	ldw	r2,4(r16)
  4174d0:	10c00044 	addi	r3,r2,1
  4174d4:	10800084 	addi	r2,r2,2
  4174d8:	1085883a 	add	r2,r2,r2
  4174dc:	1085883a 	add	r2,r2,r2
  4174e0:	80c00115 	stw	r3,4(r16)
  4174e4:	80a1883a 	add	r16,r16,r2
  4174e8:	84400015 	stw	r17,0(r16)
  4174ec:	0005883a 	mov	r2,zero
  4174f0:	dfc00617 	ldw	ra,24(sp)
  4174f4:	dd400517 	ldw	r21,20(sp)
  4174f8:	dd000417 	ldw	r20,16(sp)
  4174fc:	dcc00317 	ldw	r19,12(sp)
  417500:	dc800217 	ldw	r18,8(sp)
  417504:	dc400117 	ldw	r17,4(sp)
  417508:	dc000017 	ldw	r16,0(sp)
  41750c:	dec00704 	addi	sp,sp,28
  417510:	f800283a 	ret

00417514 <__call_exitprocs>:
  417514:	00801074 	movhi	r2,65
  417518:	109f3404 	addi	r2,r2,31952
  41751c:	10800017 	ldw	r2,0(r2)
  417520:	defff304 	addi	sp,sp,-52
  417524:	ddc00a15 	stw	r23,40(sp)
  417528:	d8800015 	stw	r2,0(sp)
  41752c:	05c00034 	movhi	r23,0
  417530:	10800c04 	addi	r2,r2,48
  417534:	dc800515 	stw	r18,20(sp)
  417538:	dfc00c15 	stw	ra,48(sp)
  41753c:	df000b15 	stw	fp,44(sp)
  417540:	dd800915 	stw	r22,36(sp)
  417544:	dd400815 	stw	r21,32(sp)
  417548:	dd000715 	stw	r20,28(sp)
  41754c:	dcc00615 	stw	r19,24(sp)
  417550:	dc400415 	stw	r17,16(sp)
  417554:	dc000315 	stw	r16,12(sp)
  417558:	d9000115 	stw	r4,4(sp)
  41755c:	2825883a 	mov	r18,r5
  417560:	d8800215 	stw	r2,8(sp)
  417564:	bdc00004 	addi	r23,r23,0
  417568:	d8800017 	ldw	r2,0(sp)
  41756c:	dc400217 	ldw	r17,8(sp)
  417570:	14c00c17 	ldw	r19,48(r2)
  417574:	98004226 	beq	r19,zero,417680 <__call_exitprocs+0x16c>
  417578:	9c000117 	ldw	r16,4(r19)
  41757c:	00900034 	movhi	r2,16384
  417580:	10bfffc4 	addi	r2,r2,-1
  417584:	9d002217 	ldw	r20,136(r19)
  417588:	857fffc4 	addi	r21,r16,-1
  41758c:	80a1883a 	add	r16,r16,r2
  417590:	8421883a 	add	r16,r16,r16
  417594:	8421883a 	add	r16,r16,r16
  417598:	a42d883a 	add	r22,r20,r16
  41759c:	84000204 	addi	r16,r16,8
  4175a0:	9c21883a 	add	r16,r19,r16
  4175a4:	a8002616 	blt	r21,zero,417640 <__call_exitprocs+0x12c>
  4175a8:	90000326 	beq	r18,zero,4175b8 <__call_exitprocs+0xa4>
  4175ac:	a0002026 	beq	r20,zero,417630 <__call_exitprocs+0x11c>
  4175b0:	b1002017 	ldw	r4,128(r22)
  4175b4:	24801e1e 	bne	r4,r18,417630 <__call_exitprocs+0x11c>
  4175b8:	99000117 	ldw	r4,4(r19)
  4175bc:	82000017 	ldw	r8,0(r16)
  4175c0:	213fffc4 	addi	r4,r4,-1
  4175c4:	a900021e 	bne	r21,r4,4175d0 <__call_exitprocs+0xbc>
  4175c8:	9d400115 	stw	r21,4(r19)
  4175cc:	00000106 	br	4175d4 <__call_exitprocs+0xc0>
  4175d0:	80000015 	stw	zero,0(r16)
  4175d4:	40001626 	beq	r8,zero,417630 <__call_exitprocs+0x11c>
  4175d8:	9f000117 	ldw	fp,4(r19)
  4175dc:	a0000526 	beq	r20,zero,4175f4 <__call_exitprocs+0xe0>
  4175e0:	00800044 	movi	r2,1
  4175e4:	1552983a 	sll	r9,r2,r21
  4175e8:	a1404017 	ldw	r5,256(r20)
  4175ec:	494a703a 	and	r5,r9,r5
  4175f0:	2800021e 	bne	r5,zero,4175fc <__call_exitprocs+0xe8>
  4175f4:	403ee83a 	callr	r8
  4175f8:	00000906 	br	417620 <__call_exitprocs+0x10c>
  4175fc:	a1004117 	ldw	r4,260(r20)
  417600:	4908703a 	and	r4,r9,r4
  417604:	2000041e 	bne	r4,zero,417618 <__call_exitprocs+0x104>
  417608:	d9000117 	ldw	r4,4(sp)
  41760c:	b1400017 	ldw	r5,0(r22)
  417610:	403ee83a 	callr	r8
  417614:	00000206 	br	417620 <__call_exitprocs+0x10c>
  417618:	b1000017 	ldw	r4,0(r22)
  41761c:	403ee83a 	callr	r8
  417620:	99000117 	ldw	r4,4(r19)
  417624:	e13fd01e 	bne	fp,r4,417568 <_gp+0xffff7898>
  417628:	89000017 	ldw	r4,0(r17)
  41762c:	24ffce1e 	bne	r4,r19,417568 <_gp+0xffff7898>
  417630:	ad7fffc4 	addi	r21,r21,-1
  417634:	b5bfff04 	addi	r22,r22,-4
  417638:	843fff04 	addi	r16,r16,-4
  41763c:	003fd906 	br	4175a4 <_gp+0xffff78d4>
  417640:	b8000f26 	beq	r23,zero,417680 <__call_exitprocs+0x16c>
  417644:	99400117 	ldw	r5,4(r19)
  417648:	99000017 	ldw	r4,0(r19)
  41764c:	2800091e 	bne	r5,zero,417674 <__call_exitprocs+0x160>
  417650:	20000826 	beq	r4,zero,417674 <__call_exitprocs+0x160>
  417654:	89000015 	stw	r4,0(r17)
  417658:	a0000226 	beq	r20,zero,417664 <__call_exitprocs+0x150>
  41765c:	a009883a 	mov	r4,r20
  417660:	00000000 	call	0 <__alt_mem_epcs_flash_controller_0-0x21000>
  417664:	9809883a 	mov	r4,r19
  417668:	00000000 	call	0 <__alt_mem_epcs_flash_controller_0-0x21000>
  41766c:	8cc00017 	ldw	r19,0(r17)
  417670:	003fc006 	br	417574 <_gp+0xffff78a4>
  417674:	9823883a 	mov	r17,r19
  417678:	2027883a 	mov	r19,r4
  41767c:	003fbd06 	br	417574 <_gp+0xffff78a4>
  417680:	dfc00c17 	ldw	ra,48(sp)
  417684:	df000b17 	ldw	fp,44(sp)
  417688:	ddc00a17 	ldw	r23,40(sp)
  41768c:	dd800917 	ldw	r22,36(sp)
  417690:	dd400817 	ldw	r21,32(sp)
  417694:	dd000717 	ldw	r20,28(sp)
  417698:	dcc00617 	ldw	r19,24(sp)
  41769c:	dc800517 	ldw	r18,20(sp)
  4176a0:	dc400417 	ldw	r17,16(sp)
  4176a4:	dc000317 	ldw	r16,12(sp)
  4176a8:	dec00d04 	addi	sp,sp,52
  4176ac:	f800283a 	ret

004176b0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  4176b0:	defffd04 	addi	sp,sp,-12
  4176b4:	df000215 	stw	fp,8(sp)
  4176b8:	df000204 	addi	fp,sp,8
  4176bc:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  4176c0:	0001883a 	nop
  4176c4:	e0bfff17 	ldw	r2,-4(fp)
  4176c8:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  4176cc:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  4176d0:	10000226 	beq	r2,zero,4176dc <_exit+0x2c>
    ALT_SIM_FAIL();
  4176d4:	002af070 	cmpltui	zero,zero,43969
  4176d8:	00000106 	br	4176e0 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  4176dc:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  4176e0:	003fff06 	br	4176e0 <_gp+0xffff7a10>
