
NiosII.elf:     file format elf32-littlenios2
NiosII.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0041022c

Program Header:
    LOAD off    0x00001000 vaddr 0x00410000 paddr 0x00410000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00410020 paddr 0x00410020 align 2**12
         filesz 0x00007398 memsz 0x00007398 flags r-x
    LOAD off    0x000083b8 vaddr 0x004173b8 paddr 0x00417830 align 2**12
         filesz 0x00000478 memsz 0x00000478 flags rw-
    LOAD off    0x00008ca8 vaddr 0x00417ca8 paddr 0x00417ca8 align 2**12
         filesz 0x00000000 memsz 0x000003f4 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00410000  00410000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000020c  00410020  00410020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000702c  0041022c  0041022c  0000122c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000160  00417258  00417258  00008258  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000478  004173b8  00417830  000083b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000003f4  00417ca8  00417ca8  00008ca8  2**2
                  ALLOC, SMALL_DATA
  6 .epcs_flash_controller_0 00000000  00021000  00021000  00008830  2**0
                  CONTENTS
  7 .onchip_memory2_0 00000000  0041809c  0041809c  00008830  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00008830  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000998  00000000  00000000  00008858  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000bfc9  00000000  00000000  000091f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000498e  00000000  00000000  000151b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00004f09  00000000  00000000  00019b47  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001dc4  00000000  00000000  0001ea50  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000302f  00000000  00000000  00020814  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00003859  00000000  00000000  00023843  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000010  00000000  00000000  0002709c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000005e0  00000000  00000000  000270b0  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  0002a68c  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0002a68f  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0002a69b  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0002a69c  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   0000000b  00000000  00000000  0002a69d  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    0000000b  00000000  00000000  0002a6a8  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   0000000b  00000000  00000000  0002a6b3  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 00000006  00000000  00000000  0002a6be  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 00000035  00000000  00000000  0002a6c4  2**0
                  CONTENTS, READONLY
 27 .jdi          00003e87  00000000  00000000  0002a6f9  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     00064959  00000000  00000000  0002e580  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00410000 l    d  .entry	00000000 .entry
00410020 l    d  .exceptions	00000000 .exceptions
0041022c l    d  .text	00000000 .text
00417258 l    d  .rodata	00000000 .rodata
004173b8 l    d  .rwdata	00000000 .rwdata
00417ca8 l    d  .bss	00000000 .bss
00021000 l    d  .epcs_flash_controller_0	00000000 .epcs_flash_controller_0
0041809c l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../NiosII_Bsp/obj/HAL/src/crt0.o
00410264 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 Ap.c
00000000 l    df *ABS*	00000000 MSP.c
00417cf4 l     O .bss	00000043 Cmd
00417d37 l     O .bss	00000044 Resp
00417ca8 l     O .bss	00000001 Cmd_State
00417ca9 l     O .bss	00000001 Index_Data
00417cac l     O .bss	00000004 CurrentTime
00417cb0 l     O .bss	00000004 PreviousTime
00417cb4 l     O .bss	00000001 CmdReceived
00417cb6 l     O .bss	00000008 RcCmd.2903
00000000 l    df *ABS*	00000000 Hw_DcMotor.c
00417d7c l     O .bss	0000000c Hw_DcMotor_State
00000000 l    df *ABS*	00000000 Hw_ISR.c
00000000 l    df *ABS*	00000000 Hw_Pwm.c
00000000 l    df *ABS*	00000000 Hw_Timer.c
00417cc0 l     O .bss	00000004 Hw_Timer_Counter
00417cc4 l     O .bss	00000002 Tmr_Ctn
00417cc6 l     O .bss	00000002 Tmr_HandleIndex
00417d88 l     O .bss	000000a0 Timer_Tbl
00417cc8 l     O .bss	00000001 Excute.2842
00000000 l    df *ABS*	00000000 Hw_Uart.c
004113e4 l     F .text	000000d8 Hw_Uart_ISR_Handler
00000000 l    df *ABS*	00000000 Hw_Uart_Q.c
00000000 l    df *ABS*	00000000 Hw_Led.c
00000000 l    df *ABS*	00000000 Hw.c
00000000 l    df *ABS*	00000000 Lb_Printf.c
00000000 l    df *ABS*	00000000 Lb_Util.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
004122b4 l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 addsf3.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 subsf3.c
00000000 l    df *ABS*	00000000 fixsfsi.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 fvwrite_small_str.c
00000000 l    df *ABS*	00000000 impure.c
004173b8 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 vfprintf.c
004135c0 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00413ea8 l     F .text	00000064 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00414004 l     F .text	00000038 alt_dev_reg
00417498 l     O .rwdata	000000cc epcs_flash_controller_0
00417564 l     O .rwdata	0000002c jtag_uart_0
00417590 l     O .rwdata	000000c4 uart_0
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
0041410c l     F .text	00000038 alt_flash_device_register
00414198 l     F .text	000003f8 alt_epcs_flash_query
00414590 l     F .text	000000e8 alt_epcs_flash_memcmp
00414964 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00414e3c l     F .text	00000074 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_ts.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_vars.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
00415230 l     F .text	00000098 altera_avalon_uart_irq
004152c8 l     F .text	000000e0 altera_avalon_uart_rxirq
004153a8 l     F .text	00000144 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00415540 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0041576c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 epcs_commands.c
004159c4 l     F .text	00000038 epcs_test_wip
004159fc l     F .text	00000038 epcs_await_wip_released
00000000 l    df *ABS*	00000000 alt_close.c
00415f94 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
004160d8 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00416104 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00416420 l     F .text	000000e0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
00416578 l     F .text	00000050 alt_get_errno
004165c8 l     F .text	000000f4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00417ce4 g     O .bss	00000004 alt_instruction_exception_handler
004148d8 g     F .text	0000008c alt_epcs_flash_get_info
00413f8c g     F .text	00000078 alt_main
00417f9c g     O .bss	00000100 alt_irq
004105ec g     F .text	00000024 MSP_Get_RespPtr
004120cc g     F .text	00000034 Uart1_ISR
00417830 g       *ABS*	00000000 __flash_rwdata_start
00411b5c g     F .text	00000138 Hw_Uart_Q_Push
004134a0 g     F .text	00000024 vsprintf
004111e0 g     F .text	0000004c Hw_Timer_Start
004114bc g     F .text	000000a8 Hw_Uart_Init
00411878 g     F .text	0000007c Hw_Uart_PrintEx
004128e8 g     F .text	00000450 .hidden __divsf3
00417ce0 g     O .bss	00000004 altera_avalon_timer_ts_freq
00413560 g     F .text	00000060 memmove
00410fa4 g     F .text	00000170 Hw_Timer_Tick
00413234 g     F .text	00000078 .hidden __fixsfsi
004105c8 g     F .text	00000024 MSP_Get_CmdPtr
00416a38 g     F .text	00000020 altera_nios2_gen2_irq_init
00000000  w      *UND*	00000000 __errno
00415a34 g     F .text	000000f8 epcs_sector_erase
004134c4 g     F .text	0000009c __sfvwrite_small_str
00410000 g     F .entry	0000000c __reset
00410020 g       *ABS*	00000000 __flash_exceptions_start
004106c0 g     F .text	00000154 MSP_SendResp
00417cf0 g     O .bss	00000004 errno
00411ac8 g     F .text	00000038 HW_UART_Q_VAILD
00417cd4 g     O .bss	00000004 alt_argv
0041f7fc g       *ABS*	00000000 _gp
00412d38 g     F .text	000004fc .hidden __subsf3
0041767c g     O .rwdata	00000180 alt_fd_list
00415c70 g     F .text	00000068 epcs_write_status_register
00416c5c g     F .text	00000090 alt_find_dev
00416500 g     F .text	00000078 alt_io_redirect
00417258 g       *ABS*	00000000 __DTOR_END__
00416384 g     F .text	0000009c alt_exception_cause_generated_bad_addr
00414a6c g     F .text	00000100 alt_epcs_flash_write_block
00411f18 g     F .text	00000040 Hw_Led_Wait
00410e80 g     F .text	000000d0 Hw_Timer_Init
00414cc4 g     F .text	000000e4 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
004108f8 g     F .text	0000003c Hw_DcMotor_Stop
00410000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
004123d0 g     F .text	00000008 .hidden __udivsi3
004102f0 g     F .text	0000003c MSP_Init
00417e88 g     O .bss	000000e7 Hw_Uart_Q_Buffer
00411b00 g     F .text	0000005c Hw_Uart_Q_PushReady
00417818 g     O .rwdata	00000004 alt_max_fd
00410814 g     F .text	000000e4 Hw_DcMotor_Init
00410290 g     F .text	00000060 MSP_ISR
004149f8 g     F .text	00000074 alt_epcs_flash_erase_block
004177fc g     O .rwdata	00000004 _global_impure_ptr
00415f38 g     F .text	0000005c epcs_exit_4_bytes_mode
0041809c g       *ABS*	00000000 __bss_end
00413db8 g     F .text	000000f0 alt_iic_isr_register
00416934 g     F .text	00000104 alt_tick
00411dc0 g     F .text	00000034 Hw_Led_Init
00415188 g     F .text	000000a8 altera_avalon_uart_init
00411df4 g     F .text	00000060 Hw_Led_On
00413d6c g     F .text	0000004c alt_ic_irq_enabled
0041689c g     F .text	00000098 alt_alarm_stop
00410e58 g     F .text	00000028 Hw_Timer_ISR
00417ccc g     O .bss	00000004 alt_irq_active
004100fc g     F .exceptions	000000d0 alt_irq_handler
00417654 g     O .rwdata	00000028 alt_dev_null
004116bc g     F .text	00000044 Hw_Uart_Open_COM2
00411748 g     F .text	0000005c Hw_Uart_Getch
00417e28 g     O .bss	00000060 Hw_Uart_Ch
004160bc g     F .text	0000001c alt_dcache_flush_all
00411fd0 g     F .text	0000003c Hw_Wait_Usec
00410358 g     F .text	00000270 MSP_Update
00417830 g       *ABS*	00000000 __ram_rwdata_end
00410bf0 g     F .text	00000060 Hw_Pwm_Init
00417810 g     O .rwdata	00000008 alt_dev_list
00410dd8 g     F .text	00000080 Hw_Pwm_SetPercent
00415050 g     F .text	00000028 alt_timestamp_freq
004173b8 g       *ABS*	00000000 __ram_rodata_end
00411580 g     F .text	00000090 Hw_Uart_Open
004123d8 g     F .text	00000008 .hidden __umodsi3
00411c94 g     F .text	0000012c Hw_Uart_Q_Pop
00415df4 g     F .text	00000068 epcs_read_electronic_signature
0041809c g       *ABS*	00000000 end
004157bc g     F .text	000001ac altera_avalon_uart_write
004101cc g     F .exceptions	00000060 alt_instruction_exception_entry
00417258 g       *ABS*	00000000 __CTOR_LIST__
0041bb80 g       *ABS*	00000000 __alt_stack_pointer
00414eb0 g     F .text	00000088 alt_avalon_timer_sc_init
004150d8 g     F .text	00000060 altera_avalon_uart_write_fd
004133e0 g     F .text	00000064 .hidden __clzsi2
00415138 g     F .text	00000050 altera_avalon_uart_close_fd
00414da8 g     F .text	00000094 altera_avalon_jtag_uart_write
00417088 g     F .text	0000019c __call_exitprocs
00411320 g     F .text	00000034 Hw_Timer_Get_Handle
00411354 g     F .text	00000028 Hw_Timer_Get_CountValue
0041022c g     F .text	0000003c _start
00417ce8 g     O .bss	00000004 _alt_tick_rate
004118f4 g     F .text	00000064 Hw_Uart_Printf
00416a58 g     F .text	00000204 alt_avalon_spi_command
00417cec g     O .bss	00000004 _alt_nticks
00414070 g     F .text	0000009c alt_sys_init
004132ac g     F .text	00000134 .hidden __floatsisf
00416f38 g     F .text	00000150 __register_exitproc
004123e0 g     F .text	00000028 .hidden __mulsi3
004173b8 g       *ABS*	00000000 __ram_rwdata_start
00417258 g       *ABS*	00000000 __ram_rodata_start
00415968 g     F .text	0000005c epcs_read_status_register
00414c04 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00416e00 g     F .text	000000d4 alt_get_fd
00415e5c g     F .text	00000080 epcs_read_device_id
00416f08 g     F .text	00000030 memcmp
0041809c g       *ABS*	00000000 __alt_stack_base
00021000 g       *ABS*	00000000 __alt_mem_epcs_flash_controller_0
004119b4 g     F .text	00000080 Hw_Uart_Q_Init
00410268 g     F .text	00000028 Ap_Init
00411958 g     F .text	0000005c Hw_Uart_GetchNoWait
00411eb8 g     F .text	00000060 Hw_Led_Toggle
00411a34 g     F .text	00000094 HW_UART_Q_SIZE
00416cec g     F .text	00000114 alt_find_file
00416154 g     F .text	000000a4 alt_dev_llist_insert
0041362c g     F .text	0000056c ___svfprintf_internal_r
00417820 g     O .rwdata	00000008 alt_flash_dev_list
00417f70 g     O .bss	0000000e Hw_Uart_Q_Size
004109d0 g     F .text	00000084 Hw_DcMotor_SetDir
00410bd0 g     F .text	00000020 Hw_ISR_Init
00417ca8 g       *ABS*	00000000 __bss_start
00410f6c g     F .text	0000001c Hw_Timer_SetupISR
00410d28 g     F .text	000000b0 Hw_Pwm_SetDuty
00412100 g     F .text	00000188 main
00417cd8 g     O .bss	00000004 alt_envp
00414c64 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00411700 g     F .text	00000048 Hw_Uart_SetReceiveFuncISR
004112e4 g     F .text	0000003c Hw_Timer_Delay_ms
00414f38 g     F .text	00000088 alt_timestamp_start
0041781c g     O .rwdata	00000004 alt_errno
00412040 g     F .text	00000028 micros
00412320 g     F .text	00000054 .hidden __divsi3
00411274 g     F .text	00000070 Hw_Timer_Reset
00417258 g       *ABS*	00000000 __CTOR_END__
00414678 g     F .text	00000260 alt_epcs_flash_write
00417258 g       *ABS*	00000000 __flash_rodata_start
00410c50 g     F .text	000000d8 Hw_Pwm_SetDir
00417258 g       *ABS*	00000000 __DTOR_LIST__
00412068 g     F .text	00000034 delay
0041403c g     F .text	00000034 alt_irq_init
0041681c g     F .text	00000080 alt_release_fd
0041032c g     F .text	0000002c MSP_GetReceived
00417258 g     O .rodata	00000100 .hidden __clz_tab
00416ed4 g     F .text	00000014 atexit
00413444 g     F .text	0000005c _vsprintf_r
00411564 g     F .text	0000001c Hw_Uart_DeInit
00417800 g     O .rwdata	00000004 _impure_ptr
00417cd0 g     O .bss	00000004 alt_argc
00417cdc g     O .bss	00000004 altera_avalon_timer_ts_base
00416254 g     F .text	0000005c _do_dtors
00410020 g       .exceptions	00000000 alt_irq_entry
0041209c g     F .text	00000030 delay_second
00417808 g     O .rwdata	00000008 alt_fs_list
00413b98 g     F .text	00000024 __vfprintf_internal_unused
00410a54 g     F .text	0000017c Hw_DcMotor_Handle
00410020 g       *ABS*	00000000 __ram_exceptions_start
00411114 g     F .text	000000cc Hw_Timer_Set
00414fc0 g     F .text	00000090 alt_timestamp
00415b2c g     F .text	000000f4 epcs_read_buffer
00414144 g     F .text	00000054 alt_epcs_flash_init
00413bd8 g     F .text	00000050 alt_ic_isr_register
00417830 g       *ABS*	00000000 _edata
00415078 g     F .text	00000060 altera_avalon_uart_read_fd
0041809c g       *ABS*	00000000 _end
004162b0 g     F .text	00000068 alt_flash_open_dev
00411f58 g     F .text	00000038 Hw_Init
0041022c g       *ABS*	00000000 __ram_exceptions_end
0041137c g     F .text	00000038 Hw_Timer_TimeStart
00413cc8 g     F .text	000000a4 alt_ic_irq_disable
00415edc g     F .text	0000005c epcs_enter_4_bytes_mode
00417f7e g     O .bss	0000000e Hw_Uart_Q_End
00416ee8 g     F .text	00000020 exit
00411610 g     F .text	000000ac Hw_Uart_Open_COM1
00410610 g     F .text	000000b0 MSP_Get_CmdRcPtr
00416318 g     F .text	00000050 alt_flash_close_dev
00412374 g     F .text	0000005c .hidden __modsi3
0041bb80 g       *ABS*	00000000 __alt_data_end
00410020 g     F .exceptions	00000000 alt_exception
004154ec g     F .text	00000054 altera_avalon_uart_close
00417224 g     F .text	00000034 _exit
00411f90 g     F .text	00000040 Hw_Wait
00412288 g     F .text	0000002c Main_Init
00413bbc g     F .text	0000001c strlen
00415c20 g     F .text	00000050 epcs_write_enable
00411e54 g     F .text	00000064 Hw_Led_Off
004166bc g     F .text	00000160 open
0041122c g     F .text	00000048 Hw_Timer_Stop
00410934 g     F .text	0000009c Hw_DcMotor_SetPwm
00416368 g     F .text	0000001c alt_icache_flush_all
00417804 g     O .rwdata	00000004 alt_priority_mask
00413c28 g     F .text	000000a0 alt_ic_irq_enable
00410f50 g     F .text	0000001c Hw_Timer_DeInit
00415590 g     F .text	000001dc altera_avalon_uart_read
004113b4 g     F .text	00000030 Hw_Timer_TimeGetElapse
00414b6c g     F .text	00000098 alt_epcs_flash_read
00417828 g     O .rwdata	00000008 alt_alarm_list
004161f8 g     F .text	0000005c _do_ctors
0041200c g     F .text	00000034 millis
00415fe4 g     F .text	000000d8 close
00412408 g     F .text	000004e0 .hidden __addsf3
00413f0c g     F .text	00000080 alt_load
00410f88 g     F .text	0000001c Hw_Timer_Setup
00000000  w      *UND*	00000000 free
00415cd8 g     F .text	0000011c epcs_write_buffer
00417f8c g     O .bss	0000000e Hw_Uart_Q_Start
004117a4 g     F .text	000000d4 Hw_Uart_Putch



Disassembly of section .entry:

00410000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  410000:	00401074 	movhi	at,65
    ori r1, r1, %lo(_start)
  410004:	08408b14 	ori	at,at,556
    jmp r1
  410008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

00410020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  410020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  410024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  410028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  41002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  410030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  410034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  410038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  41003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  410040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  410044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  410048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  41004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  410050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  410054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  410058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  41005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  410060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  410064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  410068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  41006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  410070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  410074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  410078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  41007c:	10000326 	beq	r2,zero,41008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  410080:	20000226 	beq	r4,zero,41008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  410084:	04100fc0 	call	4100fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  410088:	00000706 	br	4100a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  41008c:	df401215 	stw	ea,72(sp)
        ldhu.n  r2, 0(r4)
        ldhu.n  r3, 2(r4)
        slli.n  r3, r3, 16
        or.n    r2, r2, r3 /* Instruction that caused exception */
#else
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  410090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
  410094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
  410098:	04101cc0 	call	4101cc <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
  41009c:	1000021e 	bne	r2,zero,4100a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
  4100a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  4100a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  4100a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  4100ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  4100b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  4100b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  4100b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  4100bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  4100c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  4100c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  4100c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  4100cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  4100d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  4100d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  4100d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  4100dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  4100e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  4100e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  4100e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  4100ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  4100f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  4100f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  4100f8:	ef80083a 	eret

004100fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  4100fc:	defff904 	addi	sp,sp,-28
  410100:	dfc00615 	stw	ra,24(sp)
  410104:	df000515 	stw	fp,20(sp)
  410108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  41010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  410110:	0005313a 	rdctl	r2,ipending
  410114:	e0bffe15 	stw	r2,-8(fp)

  return active;
  410118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  41011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  410120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  410124:	00800044 	movi	r2,1
  410128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  41012c:	e0fffb17 	ldw	r3,-20(fp)
  410130:	e0bffc17 	ldw	r2,-16(fp)
  410134:	1884703a 	and	r2,r3,r2
  410138:	10001426 	beq	r2,zero,41018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  41013c:	00801074 	movhi	r2,65
  410140:	109fe704 	addi	r2,r2,32668
  410144:	e0fffd17 	ldw	r3,-12(fp)
  410148:	180690fa 	slli	r3,r3,3
  41014c:	10c5883a 	add	r2,r2,r3
  410150:	10c00017 	ldw	r3,0(r2)
  410154:	00801074 	movhi	r2,65
  410158:	109fe704 	addi	r2,r2,32668
  41015c:	e13ffd17 	ldw	r4,-12(fp)
  410160:	200890fa 	slli	r4,r4,3
  410164:	21000104 	addi	r4,r4,4
  410168:	1105883a 	add	r2,r2,r4
  41016c:	10800017 	ldw	r2,0(r2)
  410170:	1009883a 	mov	r4,r2
  410174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  410178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  41017c:	0005313a 	rdctl	r2,ipending
  410180:	e0bfff15 	stw	r2,-4(fp)

  return active;
  410184:	e0bfff17 	ldw	r2,-4(fp)
  410188:	00000706 	br	4101a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
  41018c:	e0bffc17 	ldw	r2,-16(fp)
  410190:	1085883a 	add	r2,r2,r2
  410194:	e0bffc15 	stw	r2,-16(fp)
      i++;
  410198:	e0bffd17 	ldw	r2,-12(fp)
  41019c:	10800044 	addi	r2,r2,1
  4101a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  4101a4:	003fe106 	br	41012c <_gp+0xffff0930>

    active = alt_irq_pending ();
  4101a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  4101ac:	e0bffb17 	ldw	r2,-20(fp)
  4101b0:	103fdb1e 	bne	r2,zero,410120 <_gp+0xffff0924>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  4101b4:	0001883a 	nop
}
  4101b8:	e037883a 	mov	sp,fp
  4101bc:	dfc00117 	ldw	ra,4(sp)
  4101c0:	df000017 	ldw	fp,0(sp)
  4101c4:	dec00204 	addi	sp,sp,8
  4101c8:	f800283a 	ret

004101cc <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
  4101cc:	defffb04 	addi	sp,sp,-20
  4101d0:	dfc00415 	stw	ra,16(sp)
  4101d4:	df000315 	stw	fp,12(sp)
  4101d8:	df000304 	addi	fp,sp,12
  4101dc:	e13fff15 	stw	r4,-4(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  4101e0:	00bfffc4 	movi	r2,-1
  4101e4:	e0bffd15 	stw	r2,-12(fp)
  badaddr = 0;
  4101e8:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
  4101ec:	d0a13a17 	ldw	r2,-31512(gp)
  4101f0:	10000726 	beq	r2,zero,410210 <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
  4101f4:	d0a13a17 	ldw	r2,-31512(gp)
  4101f8:	e0fffd17 	ldw	r3,-12(fp)
  4101fc:	1809883a 	mov	r4,r3
  410200:	e17fff17 	ldw	r5,-4(fp)
  410204:	e1bffe17 	ldw	r6,-8(fp)
  410208:	103ee83a 	callr	r2
  41020c:	00000206 	br	410218 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
  410210:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
  410214:	0005883a 	mov	r2,zero
}
  410218:	e037883a 	mov	sp,fp
  41021c:	dfc00117 	ldw	ra,4(sp)
  410220:	df000017 	ldw	fp,0(sp)
  410224:	dec00204 	addi	sp,sp,8
  410228:	f800283a 	ret

Disassembly of section .text:

0041022c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  41022c:	06c01074 	movhi	sp,65
    ori sp, sp, %lo(__alt_stack_pointer)
  410230:	deeee014 	ori	sp,sp,48000
    movhi gp, %hi(_gp)
  410234:	06801074 	movhi	gp,65
    ori gp, gp, %lo(_gp)
  410238:	d6bdff14 	ori	gp,gp,63484
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  41023c:	00801074 	movhi	r2,65
    ori r2, r2, %lo(__bss_start)
  410240:	109f2a14 	ori	r2,r2,31912

    movhi r3, %hi(__bss_end)
  410244:	00c01074 	movhi	r3,65
    ori r3, r3, %lo(__bss_end)
  410248:	18e02714 	ori	r3,r3,32924

    beq r2, r3, 1f
  41024c:	10c00326 	beq	r2,r3,41025c <_start+0x30>

0:
    stw zero, (r2)
  410250:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  410254:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  410258:	10fffd36 	bltu	r2,r3,410250 <_gp+0xffff0a54>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  41025c:	0413f0c0 	call	413f0c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  410260:	0413f8c0 	call	413f8c <alt_main>

00410264 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  410264:	003fff06 	br	410264 <_gp+0xffff0a68>

00410268 <Ap_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Ap_Init( void )
{
  410268:	defffe04 	addi	sp,sp,-8
  41026c:	dfc00115 	stw	ra,4(sp)
  410270:	df000015 	stw	fp,0(sp)
  410274:	d839883a 	mov	fp,sp
	MSP_Init();
  410278:	04102f00 	call	4102f0 <MSP_Init>
}
  41027c:	e037883a 	mov	sp,fp
  410280:	dfc00117 	ldw	ra,4(sp)
  410284:	df000017 	ldw	fp,0(sp)
  410288:	dec00204 	addi	sp,sp,8
  41028c:	f800283a 	ret

00410290 <MSP_ISR>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void MSP_ISR(char Ch)
{
  410290:	defffc04 	addi	sp,sp,-16
  410294:	dfc00315 	stw	ra,12(sp)
  410298:	df000215 	stw	fp,8(sp)
  41029c:	df000204 	addi	fp,sp,8
  4102a0:	2005883a 	mov	r2,r4
  4102a4:	e0bfff05 	stb	r2,-4(fp)
	BOOL Ret;

	Ret = MSP_Update(Ch);
  4102a8:	e0bfff03 	ldbu	r2,-4(fp)
  4102ac:	10803fcc 	andi	r2,r2,255
  4102b0:	1009883a 	mov	r4,r2
  4102b4:	04103580 	call	410358 <MSP_Update>
  4102b8:	e0bffe05 	stb	r2,-8(fp)

	if( Ret == TRUE && CmdReceived == FALSE )
  4102bc:	e0bffe03 	ldbu	r2,-8(fp)
  4102c0:	10800058 	cmpnei	r2,r2,1
  4102c4:	1000051e 	bne	r2,zero,4102dc <MSP_ISR+0x4c>
  4102c8:	d0a12e03 	ldbu	r2,-31560(gp)
  4102cc:	10803fcc 	andi	r2,r2,255
  4102d0:	1000021e 	bne	r2,zero,4102dc <MSP_ISR+0x4c>
	{
		CmdReceived = TRUE;
  4102d4:	00800044 	movi	r2,1
  4102d8:	d0a12e05 	stb	r2,-31560(gp)
	}
}
  4102dc:	e037883a 	mov	sp,fp
  4102e0:	dfc00117 	ldw	ra,4(sp)
  4102e4:	df000017 	ldw	fp,0(sp)
  4102e8:	dec00204 	addi	sp,sp,8
  4102ec:	f800283a 	ret

004102f0 <MSP_Init>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void MSP_Init( void )
{
  4102f0:	defffe04 	addi	sp,sp,-8
  4102f4:	dfc00115 	stw	ra,4(sp)
  4102f8:	df000015 	stw	fp,0(sp)
  4102fc:	d839883a 	mov	fp,sp
	CmdReceived = FALSE;
  410300:	d0212e05 	stb	zero,-31560(gp)
	Cmd_State   = MSP_CMD_STATE_WAIT_START;
  410304:	d0212b05 	stb	zero,-31572(gp)

	Hw_Uart_SetReceiveFuncISR( HW_UART_CH_MSP, MSP_ISR );
  410308:	0009883a 	mov	r4,zero
  41030c:	01401074 	movhi	r5,65
  410310:	2940a404 	addi	r5,r5,656
  410314:	04117000 	call	411700 <Hw_Uart_SetReceiveFuncISR>
}
  410318:	e037883a 	mov	sp,fp
  41031c:	dfc00117 	ldw	ra,4(sp)
  410320:	df000017 	ldw	fp,0(sp)
  410324:	dec00204 	addi	sp,sp,8
  410328:	f800283a 	ret

0041032c <MSP_GetReceived>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
BOOL MSP_GetReceived( void )
{
  41032c:	defffe04 	addi	sp,sp,-8
  410330:	df000115 	stw	fp,4(sp)
  410334:	df000104 	addi	fp,sp,4
	BOOL Ret;

	Ret = CmdReceived;
  410338:	d0a12e03 	ldbu	r2,-31560(gp)
  41033c:	e0bfff05 	stb	r2,-4(fp)
	CmdReceived = FALSE;
  410340:	d0212e05 	stb	zero,-31560(gp)

	return Ret;
  410344:	e0bfff03 	ldbu	r2,-4(fp)
}
  410348:	e037883a 	mov	sp,fp
  41034c:	df000017 	ldw	fp,0(sp)
  410350:	dec00104 	addi	sp,sp,4
  410354:	f800283a 	ret

00410358 <MSP_Update>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
BOOL MSP_Update( uint8_t ch )
{
  410358:	defffc04 	addi	sp,sp,-16
  41035c:	dfc00315 	stw	ra,12(sp)
  410360:	df000215 	stw	fp,8(sp)
  410364:	df000204 	addi	fp,sp,8
  410368:	2005883a 	mov	r2,r4
  41036c:	e0bfff05 	stb	r2,-4(fp)
	BOOL Ret = FALSE;
  410370:	e03ffe05 	stb	zero,-8(fp)



	//-- 바이트간 타임아웃 설정(200ms)
	//
	CurrentTime = micros();
  410374:	04120400 	call	412040 <micros>
  410378:	d0a12c15 	stw	r2,-31568(gp)

	if( (CurrentTime - PreviousTime) > 200000 )
  41037c:	d0e12c17 	ldw	r3,-31568(gp)
  410380:	d0a12d17 	ldw	r2,-31564(gp)
  410384:	1887c83a 	sub	r3,r3,r2
  410388:	008000f4 	movhi	r2,3
  41038c:	10835004 	addi	r2,r2,3392
  410390:	10c0032e 	bgeu	r2,r3,4103a0 <MSP_Update+0x48>
	{
		Cmd_State    = MSP_CMD_STATE_WAIT_START;
  410394:	d0212b05 	stb	zero,-31572(gp)
		PreviousTime = CurrentTime;
  410398:	d0a12c17 	ldw	r2,-31568(gp)
  41039c:	d0a12d15 	stw	r2,-31564(gp)



	//-- 명령어 상태
	//
	switch( Cmd_State )
  4103a0:	d0a12b03 	ldbu	r2,-31572(gp)
  4103a4:	10803fcc 	andi	r2,r2,255
  4103a8:	10c001e8 	cmpgeui	r3,r2,7
  4103ac:	1800801e 	bne	r3,zero,4105b0 <MSP_Update+0x258>
  4103b0:	100690ba 	slli	r3,r2,2
  4103b4:	00801074 	movhi	r2,65
  4103b8:	1080f204 	addi	r2,r2,968
  4103bc:	1885883a 	add	r2,r3,r2
  4103c0:	10800017 	ldw	r2,0(r2)
  4103c4:	1000683a 	jmp	r2
  4103c8:	004103e4 	muli	at,zero,1039
  4103cc:	00410400 	call	41040 <__alt_mem_epcs_flash_controller_0+0x20040>
  4103d0:	00410420 	cmpeqi	at,zero,1040
  4103d4:	00410458 	cmpnei	at,zero,1041
  4103d8:	004104b0 	cmpltui	at,zero,1042
  4103dc:	00410510 	cmplti	at,zero,1044
  4103e0:	00410588 	cmpgei	at,zero,1046
		//-- 시작 문자 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_START:

			// 시작 문자를 기다림
			if( ch == MSP_CMD_START )
  4103e4:	e0bfff03 	ldbu	r2,-4(fp)
  4103e8:	10800918 	cmpnei	r2,r2,36
  4103ec:	1000031e 	bne	r2,zero,4103fc <MSP_Update+0xa4>
			{
				Cmd_State    = MSP_CMD_STATE_WAIT_HEADER_M;
  4103f0:	00800044 	movi	r2,1
  4103f4:	d0a12b05 	stb	r2,-31572(gp)
			}
			break;
  4103f8:	00006d06 	br	4105b0 <MSP_Update+0x258>
  4103fc:	00006c06 	br	4105b0 <MSP_Update+0x258>


		//-- 'M' 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_HEADER_M:
			if( ch == MSP_CMD_HEADER_M )
  410400:	e0bfff03 	ldbu	r2,-4(fp)
  410404:	10801358 	cmpnei	r2,r2,77
  410408:	1000031e 	bne	r2,zero,410418 <MSP_Update+0xc0>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_HEADER_ARROW;
  41040c:	00800084 	movi	r2,2
  410410:	d0a12b05 	stb	r2,-31572(gp)
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
			}
			break;
  410414:	00006606 	br	4105b0 <MSP_Update+0x258>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_HEADER_ARROW;
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
  410418:	d0212b05 	stb	zero,-31572(gp)
			}
			break;
  41041c:	00006406 	br	4105b0 <MSP_Update+0x258>


		//-- '<' 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_HEADER_ARROW:
			if( ch == MSP_CMD_HEADER_ARROW )
  410420:	e0bfff03 	ldbu	r2,-4(fp)
  410424:	10800f18 	cmpnei	r2,r2,60
  410428:	1000091e 	bne	r2,zero,410450 <MSP_Update+0xf8>
			{
				Cmd.CheckSum = 0x00;
  41042c:	00801074 	movhi	r2,65
  410430:	109f3d04 	addi	r2,r2,31988
  410434:	10000085 	stb	zero,2(r2)
				Cmd.Length   = 0;
  410438:	00801074 	movhi	r2,65
  41043c:	109f3d04 	addi	r2,r2,31988
  410440:	10000045 	stb	zero,1(r2)
				Cmd_State = MSP_CMD_STATE_WAIT_DATA_SIZE;
  410444:	008000c4 	movi	r2,3
  410448:	d0a12b05 	stb	r2,-31572(gp)
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
			}
			break;
  41044c:	00005806 	br	4105b0 <MSP_Update+0x258>
				Cmd.Length   = 0;
				Cmd_State = MSP_CMD_STATE_WAIT_DATA_SIZE;
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
  410450:	d0212b05 	stb	zero,-31572(gp)
			}
			break;
  410454:	00005606 	br	4105b0 <MSP_Update+0x258>

		//-- 데이터 사이즈 기다리는 상태(64까지)
		//
		case MSP_CMD_STATE_WAIT_DATA_SIZE:

			if( ch <= MSP_CMD_MAX_LENGTH )
  410458:	e0bfff03 	ldbu	r2,-4(fp)
  41045c:	10801068 	cmpgeui	r2,r2,65
  410460:	1000111e 	bne	r2,zero,4104a8 <MSP_Update+0x150>
			{
				Cmd.Length    = ch;
  410464:	00801074 	movhi	r2,65
  410468:	109f3d04 	addi	r2,r2,31988
  41046c:	e0ffff03 	ldbu	r3,-4(fp)
  410470:	10c00045 	stb	r3,1(r2)
				Index_Data    = 0;
  410474:	d0212b45 	stb	zero,-31571(gp)
				Cmd.CheckSum ^= ch;
  410478:	00801074 	movhi	r2,65
  41047c:	109f3d04 	addi	r2,r2,31988
  410480:	10c00083 	ldbu	r3,2(r2)
  410484:	e0bfff03 	ldbu	r2,-4(fp)
  410488:	1884f03a 	xor	r2,r3,r2
  41048c:	1007883a 	mov	r3,r2
  410490:	00801074 	movhi	r2,65
  410494:	109f3d04 	addi	r2,r2,31988
  410498:	10c00085 	stb	r3,2(r2)
				Cmd_State     = MSP_CMD_STATE_WAIT_CMD;
  41049c:	00800104 	movi	r2,4
  4104a0:	d0a12b05 	stb	r2,-31572(gp)
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
			}
			break;
  4104a4:	00004206 	br	4105b0 <MSP_Update+0x258>
				Cmd.CheckSum ^= ch;
				Cmd_State     = MSP_CMD_STATE_WAIT_CMD;
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_START;
  4104a8:	d0212b05 	stb	zero,-31572(gp)
			}
			break;
  4104ac:	00004006 	br	4105b0 <MSP_Update+0x258>

		//-- 명령어를 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_CMD:

			Cmd.Cmd       = ch;
  4104b0:	00801074 	movhi	r2,65
  4104b4:	109f3d04 	addi	r2,r2,31988
  4104b8:	e0ffff03 	ldbu	r3,-4(fp)
  4104bc:	10c00005 	stb	r3,0(r2)
			Cmd.CheckSum ^= ch;
  4104c0:	00801074 	movhi	r2,65
  4104c4:	109f3d04 	addi	r2,r2,31988
  4104c8:	10c00083 	ldbu	r3,2(r2)
  4104cc:	e0bfff03 	ldbu	r2,-4(fp)
  4104d0:	1884f03a 	xor	r2,r3,r2
  4104d4:	1007883a 	mov	r3,r2
  4104d8:	00801074 	movhi	r2,65
  4104dc:	109f3d04 	addi	r2,r2,31988
  4104e0:	10c00085 	stb	r3,2(r2)

			if( Cmd.Length == 0 )
  4104e4:	00801074 	movhi	r2,65
  4104e8:	109f3d04 	addi	r2,r2,31988
  4104ec:	10800043 	ldbu	r2,1(r2)
  4104f0:	10803fcc 	andi	r2,r2,255
  4104f4:	1000031e 	bne	r2,zero,410504 <MSP_Update+0x1ac>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_CHECKSUM;
  4104f8:	00800184 	movi	r2,6
  4104fc:	d0a12b05 	stb	r2,-31572(gp)
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_DATA;
			}
			break;
  410500:	00002b06 	br	4105b0 <MSP_Update+0x258>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_CHECKSUM;
			}
			else
			{
				Cmd_State = MSP_CMD_STATE_WAIT_DATA;
  410504:	00800144 	movi	r2,5
  410508:	d0a12b05 	stb	r2,-31572(gp)
			}
			break;
  41050c:	00002806 	br	4105b0 <MSP_Update+0x258>

		//-- 데이터를 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_DATA:

			Cmd.CheckSum          ^= ch;
  410510:	00801074 	movhi	r2,65
  410514:	109f3d04 	addi	r2,r2,31988
  410518:	10c00083 	ldbu	r3,2(r2)
  41051c:	e0bfff03 	ldbu	r2,-4(fp)
  410520:	1884f03a 	xor	r2,r3,r2
  410524:	1007883a 	mov	r3,r2
  410528:	00801074 	movhi	r2,65
  41052c:	109f3d04 	addi	r2,r2,31988
  410530:	10c00085 	stb	r3,2(r2)
			Cmd.Data[ Index_Data ] = ch;
  410534:	d0a12b43 	ldbu	r2,-31571(gp)
  410538:	10c03fcc 	andi	r3,r2,255
  41053c:	00801074 	movhi	r2,65
  410540:	109f3d04 	addi	r2,r2,31988
  410544:	10c5883a 	add	r2,r2,r3
  410548:	e0ffff03 	ldbu	r3,-4(fp)
  41054c:	10c000c5 	stb	r3,3(r2)

			Index_Data++;
  410550:	d0a12b43 	ldbu	r2,-31571(gp)
  410554:	10800044 	addi	r2,r2,1
  410558:	d0a12b45 	stb	r2,-31571(gp)

			if( Index_Data >= Cmd.Length )
  41055c:	00801074 	movhi	r2,65
  410560:	109f3d04 	addi	r2,r2,31988
  410564:	10800043 	ldbu	r2,1(r2)
  410568:	d0e12b43 	ldbu	r3,-31571(gp)
  41056c:	10803fcc 	andi	r2,r2,255
  410570:	18c03fcc 	andi	r3,r3,255
  410574:	18800336 	bltu	r3,r2,410584 <MSP_Update+0x22c>
			{
				Cmd_State = MSP_CMD_STATE_WAIT_CHECKSUM;
  410578:	00800184 	movi	r2,6
  41057c:	d0a12b05 	stb	r2,-31572(gp)
			}
			break;
  410580:	00000b06 	br	4105b0 <MSP_Update+0x258>
  410584:	00000a06 	br	4105b0 <MSP_Update+0x258>

		//-- 체크섬을 기다리는 상태
		//
		case MSP_CMD_STATE_WAIT_CHECKSUM:

			if( Cmd.CheckSum == ch )
  410588:	00801074 	movhi	r2,65
  41058c:	109f3d04 	addi	r2,r2,31988
  410590:	10800083 	ldbu	r2,2(r2)
  410594:	10c03fcc 	andi	r3,r2,255
  410598:	e0bfff03 	ldbu	r2,-4(fp)
  41059c:	1880021e 	bne	r3,r2,4105a8 <MSP_Update+0x250>
			{
				Ret = TRUE;
  4105a0:	00800044 	movi	r2,1
  4105a4:	e0bffe05 	stb	r2,-8(fp)
			}

			Cmd_State = MSP_CMD_STATE_WAIT_START;
  4105a8:	d0212b05 	stb	zero,-31572(gp)
			break;
  4105ac:	0001883a 	nop
	}

	return Ret;
  4105b0:	e0bffe03 	ldbu	r2,-8(fp)
}
  4105b4:	e037883a 	mov	sp,fp
  4105b8:	dfc00117 	ldw	ra,4(sp)
  4105bc:	df000017 	ldw	fp,0(sp)
  4105c0:	dec00204 	addi	sp,sp,8
  4105c4:	f800283a 	ret

004105c8 <MSP_Get_CmdPtr>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
MSP_CMD_OBJ *MSP_Get_CmdPtr( void )
{
  4105c8:	deffff04 	addi	sp,sp,-4
  4105cc:	df000015 	stw	fp,0(sp)
  4105d0:	d839883a 	mov	fp,sp
	return &Cmd;
  4105d4:	00801074 	movhi	r2,65
  4105d8:	109f3d04 	addi	r2,r2,31988
}
  4105dc:	e037883a 	mov	sp,fp
  4105e0:	df000017 	ldw	fp,0(sp)
  4105e4:	dec00104 	addi	sp,sp,4
  4105e8:	f800283a 	ret

004105ec <MSP_Get_RespPtr>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
MSP_RESP_OBJ *MSP_Get_RespPtr( void )
{
  4105ec:	deffff04 	addi	sp,sp,-4
  4105f0:	df000015 	stw	fp,0(sp)
  4105f4:	d839883a 	mov	fp,sp
	return &Resp;
  4105f8:	00801074 	movhi	r2,65
  4105fc:	109f4dc4 	addi	r2,r2,32055
}
  410600:	e037883a 	mov	sp,fp
  410604:	df000017 	ldw	fp,0(sp)
  410608:	dec00104 	addi	sp,sp,4
  41060c:	f800283a 	ret

00410610 <MSP_Get_CmdRcPtr>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
MSP_CMD_RC_OBJ *MSP_Get_CmdRcPtr( void )
{
  410610:	defffe04 	addi	sp,sp,-8
  410614:	df000115 	stw	fp,4(sp)
  410618:	df000104 	addi	fp,sp,4
	static MSP_CMD_RC_OBJ RcCmd;
	MSP_CMD_OBJ *pCmd = &Cmd;
  41061c:	00801074 	movhi	r2,65
  410620:	109f3d04 	addi	r2,r2,31988
  410624:	e0bfff15 	stw	r2,-4(fp)


	RcCmd.Roll     = pCmd->Data[0] * 4 - 500;
  410628:	e0bfff17 	ldw	r2,-4(fp)
  41062c:	108000c3 	ldbu	r2,3(r2)
  410630:	10803fcc 	andi	r2,r2,255
  410634:	10bfe0c4 	addi	r2,r2,-125
  410638:	1085883a 	add	r2,r2,r2
  41063c:	1085883a 	add	r2,r2,r2
  410640:	d0a12e8d 	sth	r2,-31558(gp)
	RcCmd.Pitch    = pCmd->Data[1] * 4 - 500;
  410644:	e0bfff17 	ldw	r2,-4(fp)
  410648:	10800103 	ldbu	r2,4(r2)
  41064c:	10803fcc 	andi	r2,r2,255
  410650:	10bfe0c4 	addi	r2,r2,-125
  410654:	1085883a 	add	r2,r2,r2
  410658:	1085883a 	add	r2,r2,r2
  41065c:	1007883a 	mov	r3,r2
  410660:	d0a12f04 	addi	r2,gp,-31556
  410664:	10c0000d 	sth	r3,0(r2)
	RcCmd.Yaw      = pCmd->Data[2] * 4 - 500;
  410668:	e0bfff17 	ldw	r2,-4(fp)
  41066c:	10800143 	ldbu	r2,5(r2)
  410670:	10803fcc 	andi	r2,r2,255
  410674:	10bfe0c4 	addi	r2,r2,-125
  410678:	1085883a 	add	r2,r2,r2
  41067c:	1085883a 	add	r2,r2,r2
  410680:	1007883a 	mov	r3,r2
  410684:	d0a12f84 	addi	r2,gp,-31554
  410688:	10c0000d 	sth	r3,0(r2)
	RcCmd.Throthle = pCmd->Data[3] * 4;
  41068c:	e0bfff17 	ldw	r2,-4(fp)
  410690:	10800183 	ldbu	r2,6(r2)
  410694:	10803fcc 	andi	r2,r2,255
  410698:	1085883a 	add	r2,r2,r2
  41069c:	1085883a 	add	r2,r2,r2
  4106a0:	1007883a 	mov	r3,r2
  4106a4:	d0a13004 	addi	r2,gp,-31552
  4106a8:	10c0000d 	sth	r3,0(r2)


	return &RcCmd;
  4106ac:	d0a12e84 	addi	r2,gp,-31558
}
  4106b0:	e037883a 	mov	sp,fp
  4106b4:	df000017 	ldw	fp,0(sp)
  4106b8:	dec00104 	addi	sp,sp,4
  4106bc:	f800283a 	ret

004106c0 <MSP_SendResp>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void MSP_SendResp( MSP_RESP_OBJ *pResp )
{
  4106c0:	defffc04 	addi	sp,sp,-16
  4106c4:	dfc00315 	stw	ra,12(sp)
  4106c8:	df000215 	stw	fp,8(sp)
  4106cc:	df000204 	addi	fp,sp,8
  4106d0:	e13fff15 	stw	r4,-4(fp)
	uint8_t i;
	uint8_t CheckSum = 0;
  4106d4:	e03ffe45 	stb	zero,-7(fp)


	Hw_Uart_Putch(HW_UART_CH_MSP, MSP_CMD_START );
  4106d8:	0009883a 	mov	r4,zero
  4106dc:	01400904 	movi	r5,36
  4106e0:	04117a40 	call	4117a4 <Hw_Uart_Putch>
	Hw_Uart_Putch(HW_UART_CH_MSP, MSP_CMD_HEADER_M );
  4106e4:	0009883a 	mov	r4,zero
  4106e8:	01401344 	movi	r5,77
  4106ec:	04117a40 	call	4117a4 <Hw_Uart_Putch>

	if( pResp->ErrorCode > 0 )	Hw_Uart_Putch(HW_UART_CH_MSP, '!');
  4106f0:	e0bfff17 	ldw	r2,-4(fp)
  4106f4:	10800083 	ldbu	r2,2(r2)
  4106f8:	10803fcc 	andi	r2,r2,255
  4106fc:	10000426 	beq	r2,zero,410710 <MSP_SendResp+0x50>
  410700:	0009883a 	mov	r4,zero
  410704:	01400844 	movi	r5,33
  410708:	04117a40 	call	4117a4 <Hw_Uart_Putch>
  41070c:	00000306 	br	41071c <MSP_SendResp+0x5c>
	else						Hw_Uart_Putch(HW_UART_CH_MSP, '>');
  410710:	0009883a 	mov	r4,zero
  410714:	01400f84 	movi	r5,62
  410718:	04117a40 	call	4117a4 <Hw_Uart_Putch>

	Hw_Uart_Putch(HW_UART_CH_MSP, pResp->Length );
  41071c:	e0bfff17 	ldw	r2,-4(fp)
  410720:	10800043 	ldbu	r2,1(r2)
  410724:	10803fcc 	andi	r2,r2,255
  410728:	1080201c 	xori	r2,r2,128
  41072c:	10bfe004 	addi	r2,r2,-128
  410730:	0009883a 	mov	r4,zero
  410734:	100b883a 	mov	r5,r2
  410738:	04117a40 	call	4117a4 <Hw_Uart_Putch>
	Hw_Uart_Putch(HW_UART_CH_MSP, pResp->Cmd );
  41073c:	e0bfff17 	ldw	r2,-4(fp)
  410740:	10800003 	ldbu	r2,0(r2)
  410744:	10803fcc 	andi	r2,r2,255
  410748:	1080201c 	xori	r2,r2,128
  41074c:	10bfe004 	addi	r2,r2,-128
  410750:	0009883a 	mov	r4,zero
  410754:	100b883a 	mov	r5,r2
  410758:	04117a40 	call	4117a4 <Hw_Uart_Putch>
	CheckSum ^= pResp->Cmd;
  41075c:	e0bfff17 	ldw	r2,-4(fp)
  410760:	10c00003 	ldbu	r3,0(r2)
  410764:	e0bffe43 	ldbu	r2,-7(fp)
  410768:	1884f03a 	xor	r2,r3,r2
  41076c:	e0bffe45 	stb	r2,-7(fp)

	for( i=0; i<pResp->Length; i++ )
  410770:	e03ffe05 	stb	zero,-8(fp)
  410774:	00001606 	br	4107d0 <MSP_SendResp+0x110>
	{
		Hw_Uart_Putch( HW_UART_CH_MSP, pResp->Data[i] );
  410778:	e0bffe03 	ldbu	r2,-8(fp)
  41077c:	e0ffff17 	ldw	r3,-4(fp)
  410780:	1885883a 	add	r2,r3,r2
  410784:	10800104 	addi	r2,r2,4
  410788:	10800003 	ldbu	r2,0(r2)
  41078c:	10803fcc 	andi	r2,r2,255
  410790:	1080201c 	xori	r2,r2,128
  410794:	10bfe004 	addi	r2,r2,-128
  410798:	0009883a 	mov	r4,zero
  41079c:	100b883a 	mov	r5,r2
  4107a0:	04117a40 	call	4117a4 <Hw_Uart_Putch>
		CheckSum ^= pResp->Data[i];
  4107a4:	e0bffe03 	ldbu	r2,-8(fp)
  4107a8:	e0ffff17 	ldw	r3,-4(fp)
  4107ac:	1885883a 	add	r2,r3,r2
  4107b0:	10800104 	addi	r2,r2,4
  4107b4:	10c00003 	ldbu	r3,0(r2)
  4107b8:	e0bffe43 	ldbu	r2,-7(fp)
  4107bc:	1884f03a 	xor	r2,r3,r2
  4107c0:	e0bffe45 	stb	r2,-7(fp)

	Hw_Uart_Putch(HW_UART_CH_MSP, pResp->Length );
	Hw_Uart_Putch(HW_UART_CH_MSP, pResp->Cmd );
	CheckSum ^= pResp->Cmd;

	for( i=0; i<pResp->Length; i++ )
  4107c4:	e0bffe03 	ldbu	r2,-8(fp)
  4107c8:	10800044 	addi	r2,r2,1
  4107cc:	e0bffe05 	stb	r2,-8(fp)
  4107d0:	e0bfff17 	ldw	r2,-4(fp)
  4107d4:	10800043 	ldbu	r2,1(r2)
  4107d8:	10803fcc 	andi	r2,r2,255
  4107dc:	e0fffe03 	ldbu	r3,-8(fp)
  4107e0:	18bfe536 	bltu	r3,r2,410778 <_gp+0xffff0f7c>
	{
		Hw_Uart_Putch( HW_UART_CH_MSP, pResp->Data[i] );
		CheckSum ^= pResp->Data[i];
	}

	Hw_Uart_Putch(HW_UART_CH_MSP, CheckSum );
  4107e4:	e0bffe43 	ldbu	r2,-7(fp)
  4107e8:	10803fcc 	andi	r2,r2,255
  4107ec:	1080201c 	xori	r2,r2,128
  4107f0:	10bfe004 	addi	r2,r2,-128
  4107f4:	0009883a 	mov	r4,zero
  4107f8:	100b883a 	mov	r5,r2
  4107fc:	04117a40 	call	4117a4 <Hw_Uart_Putch>
}
  410800:	e037883a 	mov	sp,fp
  410804:	dfc00117 	ldw	ra,4(sp)
  410808:	df000017 	ldw	fp,0(sp)
  41080c:	dec00204 	addi	sp,sp,8
  410810:	f800283a 	ret

00410814 <Hw_DcMotor_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_DcMotor_Init( void )
{
  410814:	defffc04 	addi	sp,sp,-16
  410818:	dfc00315 	stw	ra,12(sp)
  41081c:	df000215 	stw	fp,8(sp)
  410820:	dc000115 	stw	r16,4(sp)
  410824:	df000204 	addi	fp,sp,8

	//-- GPIO 설정
	//


	for( i=0; i<HW_DCMOTOR_MAX_CH; i++ )
  410828:	e03ffe05 	stb	zero,-8(fp)
  41082c:	00002906 	br	4108d4 <Hw_DcMotor_Init+0xc0>
	{
		Hw_DcMotor_Stop( i );
  410830:	e0bffe03 	ldbu	r2,-8(fp)
  410834:	1009883a 	mov	r4,r2
  410838:	04108f80 	call	4108f8 <Hw_DcMotor_Stop>

		Hw_DcMotor_State[i].Dir   = HW_DCMOTOR_STOP;
  41083c:	e0bffe03 	ldbu	r2,-8(fp)
  410840:	04001074 	movhi	r16,65
  410844:	841f5f04 	addi	r16,r16,32124
  410848:	1009883a 	mov	r4,r2
  41084c:	01400184 	movi	r5,6
  410850:	04123e00 	call	4123e0 <__mulsi3>
  410854:	8085883a 	add	r2,r16,r2
  410858:	00c00084 	movi	r3,2
  41085c:	10c00045 	stb	r3,1(r2)
		Hw_DcMotor_State[i].Pin   = FALSE;
  410860:	e0bffe03 	ldbu	r2,-8(fp)
  410864:	04001074 	movhi	r16,65
  410868:	841f5f04 	addi	r16,r16,32124
  41086c:	1009883a 	mov	r4,r2
  410870:	01400184 	movi	r5,6
  410874:	04123e00 	call	4123e0 <__mulsi3>
  410878:	8085883a 	add	r2,r16,r2
  41087c:	10000085 	stb	zero,2(r2)
		Hw_DcMotor_State[i].Speed = 0;
  410880:	e0bffe03 	ldbu	r2,-8(fp)
  410884:	04001074 	movhi	r16,65
  410888:	841f5f04 	addi	r16,r16,32124
  41088c:	1009883a 	mov	r4,r2
  410890:	01400184 	movi	r5,6
  410894:	04123e00 	call	4123e0 <__mulsi3>
  410898:	10800104 	addi	r2,r2,4
  41089c:	8085883a 	add	r2,r16,r2
  4108a0:	1000000d 	sth	zero,0(r2)
		Hw_DcMotor_State[i].State = HW_DCMOTOR_STATE_STOP;
  4108a4:	e0bffe03 	ldbu	r2,-8(fp)
  4108a8:	04001074 	movhi	r16,65
  4108ac:	841f5f04 	addi	r16,r16,32124
  4108b0:	1009883a 	mov	r4,r2
  4108b4:	01400184 	movi	r5,6
  4108b8:	04123e00 	call	4123e0 <__mulsi3>
  4108bc:	8085883a 	add	r2,r16,r2
  4108c0:	00c00044 	movi	r3,1
  4108c4:	10c00005 	stb	r3,0(r2)

	//-- GPIO 설정
	//


	for( i=0; i<HW_DCMOTOR_MAX_CH; i++ )
  4108c8:	e0bffe03 	ldbu	r2,-8(fp)
  4108cc:	10800044 	addi	r2,r2,1
  4108d0:	e0bffe05 	stb	r2,-8(fp)
  4108d4:	e0bffe03 	ldbu	r2,-8(fp)
  4108d8:	108000b0 	cmpltui	r2,r2,2
  4108dc:	103fd41e 	bne	r2,zero,410830 <_gp+0xffff1034>
		Hw_DcMotor_State[i].Pin   = FALSE;
		Hw_DcMotor_State[i].Speed = 0;
		Hw_DcMotor_State[i].State = HW_DCMOTOR_STATE_STOP;
	}

}
  4108e0:	e6ffff04 	addi	sp,fp,-4
  4108e4:	dfc00217 	ldw	ra,8(sp)
  4108e8:	df000117 	ldw	fp,4(sp)
  4108ec:	dc000017 	ldw	r16,0(sp)
  4108f0:	dec00304 	addi	sp,sp,12
  4108f4:	f800283a 	ret

004108f8 <Hw_DcMotor_Stop>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_DcMotor_Stop( u8 Ch )
{
  4108f8:	defffd04 	addi	sp,sp,-12
  4108fc:	dfc00215 	stw	ra,8(sp)
  410900:	df000115 	stw	fp,4(sp)
  410904:	df000104 	addi	fp,sp,4
  410908:	2005883a 	mov	r2,r4
  41090c:	e0bfff05 	stb	r2,-4(fp)
	Hw_DcMotor_SetPwm( Ch, 0 );
  410910:	e0bfff03 	ldbu	r2,-4(fp)
  410914:	1009883a 	mov	r4,r2
  410918:	000b883a 	mov	r5,zero
  41091c:	04109340 	call	410934 <Hw_DcMotor_SetPwm>
}
  410920:	e037883a 	mov	sp,fp
  410924:	dfc00117 	ldw	ra,4(sp)
  410928:	df000017 	ldw	fp,0(sp)
  41092c:	dec00204 	addi	sp,sp,8
  410930:	f800283a 	ret

00410934 <Hw_DcMotor_SetPwm>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_DcMotor_SetPwm( u8 Ch, u16 Pwm  )
{
  410934:	defffb04 	addi	sp,sp,-20
  410938:	dfc00415 	stw	ra,16(sp)
  41093c:	df000315 	stw	fp,12(sp)
  410940:	dc000215 	stw	r16,8(sp)
  410944:	df000304 	addi	fp,sp,12
  410948:	2007883a 	mov	r3,r4
  41094c:	2805883a 	mov	r2,r5
  410950:	e0fffd05 	stb	r3,-12(fp)
  410954:	e0bffe0d 	sth	r2,-8(fp)
	if( Ch >= HW_DCMOTOR_MAX_CH ) return;
  410958:	e0bffd03 	ldbu	r2,-12(fp)
  41095c:	108000b0 	cmpltui	r2,r2,2
  410960:	1000011e 	bne	r2,zero,410968 <Hw_DcMotor_SetPwm+0x34>
  410964:	00001406 	br	4109b8 <Hw_DcMotor_SetPwm+0x84>

	if( Pwm > HW_DCMOTOR_MAX_PWM ) Pwm = HW_DCMOTOR_MAX_PWM;
  410968:	e0bffe0b 	ldhu	r2,-8(fp)
  41096c:	10801970 	cmpltui	r2,r2,101
  410970:	1000021e 	bne	r2,zero,41097c <Hw_DcMotor_SetPwm+0x48>
  410974:	00801904 	movi	r2,100
  410978:	e0bffe0d 	sth	r2,-8(fp)

	Hw_DcMotor_State[Ch].Speed = Pwm;
  41097c:	e0bffd03 	ldbu	r2,-12(fp)
  410980:	04001074 	movhi	r16,65
  410984:	841f5f04 	addi	r16,r16,32124
  410988:	1009883a 	mov	r4,r2
  41098c:	01400184 	movi	r5,6
  410990:	04123e00 	call	4123e0 <__mulsi3>
  410994:	10800104 	addi	r2,r2,4
  410998:	8085883a 	add	r2,r16,r2
  41099c:	e0fffe0b 	ldhu	r3,-8(fp)
  4109a0:	10c0000d 	sth	r3,0(r2)

	Hw_Pwm_SetPercent( Ch, Pwm );
  4109a4:	e0fffd03 	ldbu	r3,-12(fp)
  4109a8:	e0bffe0b 	ldhu	r2,-8(fp)
  4109ac:	1809883a 	mov	r4,r3
  4109b0:	100b883a 	mov	r5,r2
  4109b4:	0410dd80 	call	410dd8 <Hw_Pwm_SetPercent>
}
  4109b8:	e6ffff04 	addi	sp,fp,-4
  4109bc:	dfc00217 	ldw	ra,8(sp)
  4109c0:	df000117 	ldw	fp,4(sp)
  4109c4:	dc000017 	ldw	r16,0(sp)
  4109c8:	dec00304 	addi	sp,sp,12
  4109cc:	f800283a 	ret

004109d0 <Hw_DcMotor_SetDir>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_DcMotor_SetDir( u8 Ch, u8 Dir  )
{
  4109d0:	defffb04 	addi	sp,sp,-20
  4109d4:	dfc00415 	stw	ra,16(sp)
  4109d8:	df000315 	stw	fp,12(sp)
  4109dc:	dc000215 	stw	r16,8(sp)
  4109e0:	df000304 	addi	fp,sp,12
  4109e4:	2007883a 	mov	r3,r4
  4109e8:	2805883a 	mov	r2,r5
  4109ec:	e0fffd05 	stb	r3,-12(fp)
  4109f0:	e0bffe05 	stb	r2,-8(fp)
	if( Ch >= HW_DCMOTOR_MAX_CH ) return;
  4109f4:	e0bffd03 	ldbu	r2,-12(fp)
  4109f8:	108000b0 	cmpltui	r2,r2,2
  4109fc:	1000011e 	bne	r2,zero,410a04 <Hw_DcMotor_SetDir+0x34>
  410a00:	00000e06 	br	410a3c <Hw_DcMotor_SetDir+0x6c>

	Hw_DcMotor_State[Ch].Dir = Dir;
  410a04:	e0bffd03 	ldbu	r2,-12(fp)
  410a08:	04001074 	movhi	r16,65
  410a0c:	841f5f04 	addi	r16,r16,32124
  410a10:	1009883a 	mov	r4,r2
  410a14:	01400184 	movi	r5,6
  410a18:	04123e00 	call	4123e0 <__mulsi3>
  410a1c:	8085883a 	add	r2,r16,r2
  410a20:	e0fffe03 	ldbu	r3,-8(fp)
  410a24:	10c00045 	stb	r3,1(r2)

	Hw_Pwm_SetDir( Ch, Dir );
  410a28:	e0fffd03 	ldbu	r3,-12(fp)
  410a2c:	e0bffe03 	ldbu	r2,-8(fp)
  410a30:	1809883a 	mov	r4,r3
  410a34:	100b883a 	mov	r5,r2
  410a38:	0410c500 	call	410c50 <Hw_Pwm_SetDir>
}
  410a3c:	e6ffff04 	addi	sp,fp,-4
  410a40:	dfc00217 	ldw	ra,8(sp)
  410a44:	df000117 	ldw	fp,4(sp)
  410a48:	dc000017 	ldw	r16,0(sp)
  410a4c:	dec00304 	addi	sp,sp,12
  410a50:	f800283a 	ret

00410a54 <Hw_DcMotor_Handle>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_DcMotor_Handle( s16 SpeedLeft, s16 SpeedRight )
{
  410a54:	defffb04 	addi	sp,sp,-20
  410a58:	dfc00415 	stw	ra,16(sp)
  410a5c:	df000315 	stw	fp,12(sp)
  410a60:	df000304 	addi	fp,sp,12
  410a64:	2007883a 	mov	r3,r4
  410a68:	2805883a 	mov	r2,r5
  410a6c:	e0fffe0d 	sth	r3,-8(fp)
  410a70:	e0bfff0d 	sth	r2,-4(fp)
	u16 Pwm;


	if( SpeedLeft  >  HW_DCMOTOR_MAX_PWM )	SpeedLeft  =  HW_DCMOTOR_MAX_PWM;
  410a74:	e0bffe0f 	ldh	r2,-8(fp)
  410a78:	10801950 	cmplti	r2,r2,101
  410a7c:	1000021e 	bne	r2,zero,410a88 <Hw_DcMotor_Handle+0x34>
  410a80:	00801904 	movi	r2,100
  410a84:	e0bffe0d 	sth	r2,-8(fp)
	if( SpeedLeft  < -HW_DCMOTOR_MAX_PWM )	SpeedLeft  = -HW_DCMOTOR_MAX_PWM;
  410a88:	e0bffe0f 	ldh	r2,-8(fp)
  410a8c:	10bfe708 	cmpgei	r2,r2,-100
  410a90:	1000021e 	bne	r2,zero,410a9c <Hw_DcMotor_Handle+0x48>
  410a94:	00bfe704 	movi	r2,-100
  410a98:	e0bffe0d 	sth	r2,-8(fp)
	if( SpeedRight >  HW_DCMOTOR_MAX_PWM )	SpeedRight =  HW_DCMOTOR_MAX_PWM;
  410a9c:	e0bfff0f 	ldh	r2,-4(fp)
  410aa0:	10801950 	cmplti	r2,r2,101
  410aa4:	1000021e 	bne	r2,zero,410ab0 <Hw_DcMotor_Handle+0x5c>
  410aa8:	00801904 	movi	r2,100
  410aac:	e0bfff0d 	sth	r2,-4(fp)
	if( SpeedRight < -HW_DCMOTOR_MAX_PWM )	SpeedRight = -HW_DCMOTOR_MAX_PWM;
  410ab0:	e0bfff0f 	ldh	r2,-4(fp)
  410ab4:	10bfe708 	cmpgei	r2,r2,-100
  410ab8:	1000021e 	bne	r2,zero,410ac4 <Hw_DcMotor_Handle+0x70>
  410abc:	00bfe704 	movi	r2,-100
  410ac0:	e0bfff0d 	sth	r2,-4(fp)


	if( SpeedLeft > 0 )
  410ac4:	e0bffe0f 	ldh	r2,-8(fp)
  410ac8:	00800a0e 	bge	zero,r2,410af4 <Hw_DcMotor_Handle+0xa0>
	{
		Pwm = SpeedLeft;
  410acc:	e0bffe0b 	ldhu	r2,-8(fp)
  410ad0:	e0bffd0d 	sth	r2,-12(fp)
		Hw_DcMotor_SetPwm( HW_DCMOTOR_L, Pwm );
  410ad4:	e0bffd0b 	ldhu	r2,-12(fp)
  410ad8:	0009883a 	mov	r4,zero
  410adc:	100b883a 	mov	r5,r2
  410ae0:	04109340 	call	410934 <Hw_DcMotor_SetPwm>
		Hw_DcMotor_SetDir( HW_DCMOTOR_L, HW_DCMOTOR_FOR );
  410ae4:	0009883a 	mov	r4,zero
  410ae8:	000b883a 	mov	r5,zero
  410aec:	04109d00 	call	4109d0 <Hw_DcMotor_SetDir>
  410af0:	00001306 	br	410b40 <Hw_DcMotor_Handle+0xec>
	}
	else
	if( SpeedLeft < 0 )
  410af4:	e0bffe0f 	ldh	r2,-8(fp)
  410af8:	10000b0e 	bge	r2,zero,410b28 <Hw_DcMotor_Handle+0xd4>
	{
		Pwm = -SpeedLeft;
  410afc:	e0bffe0b 	ldhu	r2,-8(fp)
  410b00:	0085c83a 	sub	r2,zero,r2
  410b04:	e0bffd0d 	sth	r2,-12(fp)
		Hw_DcMotor_SetPwm( HW_DCMOTOR_L, Pwm );
  410b08:	e0bffd0b 	ldhu	r2,-12(fp)
  410b0c:	0009883a 	mov	r4,zero
  410b10:	100b883a 	mov	r5,r2
  410b14:	04109340 	call	410934 <Hw_DcMotor_SetPwm>
		Hw_DcMotor_SetDir( HW_DCMOTOR_L, HW_DCMOTOR_BACK );
  410b18:	0009883a 	mov	r4,zero
  410b1c:	01400044 	movi	r5,1
  410b20:	04109d00 	call	4109d0 <Hw_DcMotor_SetDir>
  410b24:	00000606 	br	410b40 <Hw_DcMotor_Handle+0xec>
	}
	else
	{
		Hw_DcMotor_SetPwm( HW_DCMOTOR_L, 0 );
  410b28:	0009883a 	mov	r4,zero
  410b2c:	000b883a 	mov	r5,zero
  410b30:	04109340 	call	410934 <Hw_DcMotor_SetPwm>
		Hw_DcMotor_SetDir( HW_DCMOTOR_L, HW_DCMOTOR_STOP );
  410b34:	0009883a 	mov	r4,zero
  410b38:	01400084 	movi	r5,2
  410b3c:	04109d00 	call	4109d0 <Hw_DcMotor_SetDir>
	}


	if( SpeedRight > 0 )
  410b40:	e0bfff0f 	ldh	r2,-4(fp)
  410b44:	00800a0e 	bge	zero,r2,410b70 <Hw_DcMotor_Handle+0x11c>
	{
		Pwm = SpeedRight;
  410b48:	e0bfff0b 	ldhu	r2,-4(fp)
  410b4c:	e0bffd0d 	sth	r2,-12(fp)
		Hw_DcMotor_SetPwm( HW_DCMOTOR_R, Pwm );
  410b50:	e0bffd0b 	ldhu	r2,-12(fp)
  410b54:	01000044 	movi	r4,1
  410b58:	100b883a 	mov	r5,r2
  410b5c:	04109340 	call	410934 <Hw_DcMotor_SetPwm>
		Hw_DcMotor_SetDir( HW_DCMOTOR_R, HW_DCMOTOR_FOR );
  410b60:	01000044 	movi	r4,1
  410b64:	000b883a 	mov	r5,zero
  410b68:	04109d00 	call	4109d0 <Hw_DcMotor_SetDir>
  410b6c:	00001306 	br	410bbc <Hw_DcMotor_Handle+0x168>
	}
	else
	if( SpeedRight < 0 )
  410b70:	e0bfff0f 	ldh	r2,-4(fp)
  410b74:	10000b0e 	bge	r2,zero,410ba4 <Hw_DcMotor_Handle+0x150>
	{
		Pwm = -SpeedRight;
  410b78:	e0bfff0b 	ldhu	r2,-4(fp)
  410b7c:	0085c83a 	sub	r2,zero,r2
  410b80:	e0bffd0d 	sth	r2,-12(fp)
		Hw_DcMotor_SetPwm( HW_DCMOTOR_R, Pwm );
  410b84:	e0bffd0b 	ldhu	r2,-12(fp)
  410b88:	01000044 	movi	r4,1
  410b8c:	100b883a 	mov	r5,r2
  410b90:	04109340 	call	410934 <Hw_DcMotor_SetPwm>
		Hw_DcMotor_SetDir( HW_DCMOTOR_R, HW_DCMOTOR_BACK );
  410b94:	01000044 	movi	r4,1
  410b98:	01400044 	movi	r5,1
  410b9c:	04109d00 	call	4109d0 <Hw_DcMotor_SetDir>
  410ba0:	00000606 	br	410bbc <Hw_DcMotor_Handle+0x168>
	}
	else
	{
		Hw_DcMotor_SetPwm( HW_DCMOTOR_R, 0 );
  410ba4:	01000044 	movi	r4,1
  410ba8:	000b883a 	mov	r5,zero
  410bac:	04109340 	call	410934 <Hw_DcMotor_SetPwm>
		Hw_DcMotor_SetDir( HW_DCMOTOR_R, HW_DCMOTOR_STOP );
  410bb0:	01000044 	movi	r4,1
  410bb4:	01400084 	movi	r5,2
  410bb8:	04109d00 	call	4109d0 <Hw_DcMotor_SetDir>
	}

}
  410bbc:	e037883a 	mov	sp,fp
  410bc0:	dfc00117 	ldw	ra,4(sp)
  410bc4:	df000017 	ldw	fp,0(sp)
  410bc8:	dec00204 	addi	sp,sp,8
  410bcc:	f800283a 	ret

00410bd0 <Hw_ISR_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
s32 Hw_ISR_Init( void )
{
  410bd0:	deffff04 	addi	sp,sp,-4
  410bd4:	df000015 	stw	fp,0(sp)
  410bd8:	d839883a 	mov	fp,sp


	return 1;
  410bdc:	00800044 	movi	r2,1
}
  410be0:	e037883a 	mov	sp,fp
  410be4:	df000017 	ldw	fp,0(sp)
  410be8:	dec00104 	addi	sp,sp,4
  410bec:	f800283a 	ret

00410bf0 <Hw_Pwm_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Pwm_Init(void)
{	
  410bf0:	defffe04 	addi	sp,sp,-8
  410bf4:	df000115 	stw	fp,4(sp)
  410bf8:	df000104 	addi	fp,sp,4
	u32 Reg;


	//-- PWM Ch1
	//
	Reg =	( 0 << 8 ) |	// Dir
  410bfc:	e03fff15 	stw	zero,-4(fp)
			( 0 << 0 );		// Clock
	IOWR(IP_PWM_0_BASE, 0, Reg);
  410c00:	e0ffff17 	ldw	r3,-4(fp)
  410c04:	008010b4 	movhi	r2,66
  410c08:	10850004 	addi	r2,r2,5120
  410c0c:	10c00035 	stwio	r3,0(r2)
	IOWR(IP_PWM_0_BASE, 1, 0);
  410c10:	0007883a 	mov	r3,zero
  410c14:	008010b4 	movhi	r2,66
  410c18:	10850104 	addi	r2,r2,5124
  410c1c:	10c00035 	stwio	r3,0(r2)

	//-- PWM Ch2
	//
	IOWR(IP_PWM_0_BASE, 2, Reg);
  410c20:	e0ffff17 	ldw	r3,-4(fp)
  410c24:	008010b4 	movhi	r2,66
  410c28:	10850204 	addi	r2,r2,5128
  410c2c:	10c00035 	stwio	r3,0(r2)
	IOWR(IP_PWM_0_BASE, 3, 0);
  410c30:	0007883a 	mov	r3,zero
  410c34:	008010b4 	movhi	r2,66
  410c38:	10850304 	addi	r2,r2,5132
  410c3c:	10c00035 	stwio	r3,0(r2)
}
  410c40:	e037883a 	mov	sp,fp
  410c44:	df000017 	ldw	fp,0(sp)
  410c48:	dec00104 	addi	sp,sp,4
  410c4c:	f800283a 	ret

00410c50 <Hw_Pwm_SetDir>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Pwm_SetDir( u8 Ch, u8 Dir )
{
  410c50:	defffc04 	addi	sp,sp,-16
  410c54:	df000315 	stw	fp,12(sp)
  410c58:	df000304 	addi	fp,sp,12
  410c5c:	2007883a 	mov	r3,r4
  410c60:	2805883a 	mov	r2,r5
  410c64:	e0fffe05 	stb	r3,-8(fp)
  410c68:	e0bfff05 	stb	r2,-4(fp)
	u32 Reg;


	switch( Ch )
  410c6c:	e0bffe03 	ldbu	r2,-8(fp)
  410c70:	10000326 	beq	r2,zero,410c80 <Hw_Pwm_SetDir+0x30>
  410c74:	10800060 	cmpeqi	r2,r2,1
  410c78:	1000141e 	bne	r2,zero,410ccc <Hw_Pwm_SetDir+0x7c>
  410c7c:	00002606 	br	410d18 <Hw_Pwm_SetDir+0xc8>
	{
		case 0:
			Reg = IORD(IP_PWM_0_BASE, 0);
  410c80:	008010b4 	movhi	r2,66
  410c84:	10850004 	addi	r2,r2,5120
  410c88:	10800037 	ldwio	r2,0(r2)
  410c8c:	e0bffd15 	stw	r2,-12(fp)

			if( Dir == 0 ) CLR_BIT( Reg, 8 );
  410c90:	e0bfff03 	ldbu	r2,-4(fp)
  410c94:	1000051e 	bne	r2,zero,410cac <Hw_Pwm_SetDir+0x5c>
  410c98:	e0fffd17 	ldw	r3,-12(fp)
  410c9c:	00bfbfc4 	movi	r2,-257
  410ca0:	1884703a 	and	r2,r3,r2
  410ca4:	e0bffd15 	stw	r2,-12(fp)
  410ca8:	00000306 	br	410cb8 <Hw_Pwm_SetDir+0x68>
			else           SET_BIT( Reg, 8 );
  410cac:	e0bffd17 	ldw	r2,-12(fp)
  410cb0:	10804014 	ori	r2,r2,256
  410cb4:	e0bffd15 	stw	r2,-12(fp)

			IOWR(IP_PWM_0_BASE, 0, Reg);
  410cb8:	e0fffd17 	ldw	r3,-12(fp)
  410cbc:	008010b4 	movhi	r2,66
  410cc0:	10850004 	addi	r2,r2,5120
  410cc4:	10c00035 	stwio	r3,0(r2)
			break;
  410cc8:	00001306 	br	410d18 <Hw_Pwm_SetDir+0xc8>

		case 1:
			Reg = IORD(IP_PWM_0_BASE, 2);
  410ccc:	008010b4 	movhi	r2,66
  410cd0:	10850204 	addi	r2,r2,5128
  410cd4:	10800037 	ldwio	r2,0(r2)
  410cd8:	e0bffd15 	stw	r2,-12(fp)

			if( Dir == 0 ) CLR_BIT( Reg, 8 );
  410cdc:	e0bfff03 	ldbu	r2,-4(fp)
  410ce0:	1000051e 	bne	r2,zero,410cf8 <Hw_Pwm_SetDir+0xa8>
  410ce4:	e0fffd17 	ldw	r3,-12(fp)
  410ce8:	00bfbfc4 	movi	r2,-257
  410cec:	1884703a 	and	r2,r3,r2
  410cf0:	e0bffd15 	stw	r2,-12(fp)
  410cf4:	00000306 	br	410d04 <Hw_Pwm_SetDir+0xb4>
			else           SET_BIT( Reg, 8 );
  410cf8:	e0bffd17 	ldw	r2,-12(fp)
  410cfc:	10804014 	ori	r2,r2,256
  410d00:	e0bffd15 	stw	r2,-12(fp)

			IOWR(IP_PWM_0_BASE, 2, Reg);
  410d04:	e0fffd17 	ldw	r3,-12(fp)
  410d08:	008010b4 	movhi	r2,66
  410d0c:	10850204 	addi	r2,r2,5128
  410d10:	10c00035 	stwio	r3,0(r2)
			break;
  410d14:	0001883a 	nop
	}
}
  410d18:	e037883a 	mov	sp,fp
  410d1c:	df000017 	ldw	fp,0(sp)
  410d20:	dec00104 	addi	sp,sp,4
  410d24:	f800283a 	ret

00410d28 <Hw_Pwm_SetDuty>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Pwm_SetDuty( u8 Ch, u16 DutyRatio )
{
  410d28:	defffb04 	addi	sp,sp,-20
  410d2c:	dfc00415 	stw	ra,16(sp)
  410d30:	df000315 	stw	fp,12(sp)
  410d34:	df000304 	addi	fp,sp,12
  410d38:	2007883a 	mov	r3,r4
  410d3c:	2805883a 	mov	r2,r5
  410d40:	e0fffe05 	stb	r3,-8(fp)
  410d44:	e0bfff0d 	sth	r2,-4(fp)
	u32 Reg;


	switch( Ch )
  410d48:	e0bffe03 	ldbu	r2,-8(fp)
  410d4c:	10000326 	beq	r2,zero,410d5c <Hw_Pwm_SetDuty+0x34>
  410d50:	10800060 	cmpeqi	r2,r2,1
  410d54:	10000e1e 	bne	r2,zero,410d90 <Hw_Pwm_SetDuty+0x68>
  410d58:	00001a06 	br	410dc4 <Hw_Pwm_SetDuty+0x9c>
	{
		case 0:
			Reg = DutyRatio * HW_PWM_PERIOD / HW_PWM_MAX_DUTY;
  410d5c:	e0bfff0b 	ldhu	r2,-4(fp)
  410d60:	1009883a 	mov	r4,r2
  410d64:	01403fc4 	movi	r5,255
  410d68:	04123e00 	call	4123e0 <__mulsi3>
  410d6c:	1009883a 	mov	r4,r2
  410d70:	01403fc4 	movi	r5,255
  410d74:	04123200 	call	412320 <__divsi3>
  410d78:	e0bffd15 	stw	r2,-12(fp)
			IOWR(IP_PWM_0_BASE, 1, Reg);
  410d7c:	e0fffd17 	ldw	r3,-12(fp)
  410d80:	008010b4 	movhi	r2,66
  410d84:	10850104 	addi	r2,r2,5124
  410d88:	10c00035 	stwio	r3,0(r2)
			break;
  410d8c:	00000d06 	br	410dc4 <Hw_Pwm_SetDuty+0x9c>

		case 1:
			Reg = DutyRatio * HW_PWM_PERIOD / HW_PWM_MAX_DUTY;
  410d90:	e0bfff0b 	ldhu	r2,-4(fp)
  410d94:	1009883a 	mov	r4,r2
  410d98:	01403fc4 	movi	r5,255
  410d9c:	04123e00 	call	4123e0 <__mulsi3>
  410da0:	1009883a 	mov	r4,r2
  410da4:	01403fc4 	movi	r5,255
  410da8:	04123200 	call	412320 <__divsi3>
  410dac:	e0bffd15 	stw	r2,-12(fp)
			IOWR(IP_PWM_0_BASE, 3, Reg);
  410db0:	e0fffd17 	ldw	r3,-12(fp)
  410db4:	008010b4 	movhi	r2,66
  410db8:	10850304 	addi	r2,r2,5132
  410dbc:	10c00035 	stwio	r3,0(r2)
			break;
  410dc0:	0001883a 	nop
	}
}
  410dc4:	e037883a 	mov	sp,fp
  410dc8:	dfc00117 	ldw	ra,4(sp)
  410dcc:	df000017 	ldw	fp,0(sp)
  410dd0:	dec00204 	addi	sp,sp,8
  410dd4:	f800283a 	ret

00410dd8 <Hw_Pwm_SetPercent>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Pwm_SetPercent( u8 Ch, u16 PercentRatio )
{
  410dd8:	defffb04 	addi	sp,sp,-20
  410ddc:	dfc00415 	stw	ra,16(sp)
  410de0:	df000315 	stw	fp,12(sp)
  410de4:	dc000215 	stw	r16,8(sp)
  410de8:	df000304 	addi	fp,sp,12
  410dec:	2007883a 	mov	r3,r4
  410df0:	2805883a 	mov	r2,r5
  410df4:	e0fffd05 	stb	r3,-12(fp)
  410df8:	e0bffe0d 	sth	r2,-8(fp)
	if( PercentRatio > 100 ) PercentRatio = 100;
  410dfc:	e0bffe0b 	ldhu	r2,-8(fp)
  410e00:	10801970 	cmpltui	r2,r2,101
  410e04:	1000021e 	bne	r2,zero,410e10 <Hw_Pwm_SetPercent+0x38>
  410e08:	00801904 	movi	r2,100
  410e0c:	e0bffe0d 	sth	r2,-8(fp)

	Hw_Pwm_SetDuty( Ch, PercentRatio * HW_PWM_PERIOD / 100 );
  410e10:	e43ffd03 	ldbu	r16,-12(fp)
  410e14:	e0bffe0b 	ldhu	r2,-8(fp)
  410e18:	1009883a 	mov	r4,r2
  410e1c:	01403fc4 	movi	r5,255
  410e20:	04123e00 	call	4123e0 <__mulsi3>
  410e24:	1009883a 	mov	r4,r2
  410e28:	01401904 	movi	r5,100
  410e2c:	04123200 	call	412320 <__divsi3>
  410e30:	10bfffcc 	andi	r2,r2,65535
  410e34:	8009883a 	mov	r4,r16
  410e38:	100b883a 	mov	r5,r2
  410e3c:	0410d280 	call	410d28 <Hw_Pwm_SetDuty>
}
  410e40:	e6ffff04 	addi	sp,fp,-4
  410e44:	dfc00217 	ldw	ra,8(sp)
  410e48:	df000117 	ldw	fp,4(sp)
  410e4c:	dc000017 	ldw	r16,0(sp)
  410e50:	dec00304 	addi	sp,sp,12
  410e54:	f800283a 	ret

00410e58 <Hw_Timer_ISR>:
void Hw_Timer_Setup( void );



void Hw_Timer_ISR(void)
{
  410e58:	defffe04 	addi	sp,sp,-8
  410e5c:	dfc00115 	stw	ra,4(sp)
  410e60:	df000015 	stw	fp,0(sp)
  410e64:	d839883a 	mov	fp,sp

	Hw_Timer_Tick();  
  410e68:	0410fa40 	call	410fa4 <Hw_Timer_Tick>

}
  410e6c:	e037883a 	mov	sp,fp
  410e70:	dfc00117 	ldw	ra,4(sp)
  410e74:	df000017 	ldw	fp,0(sp)
  410e78:	dec00204 	addi	sp,sp,8
  410e7c:	f800283a 	ret

00410e80 <Hw_Timer_Init>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Timer_Init( void )
{
  410e80:	defffd04 	addi	sp,sp,-12
  410e84:	dfc00215 	stw	ra,8(sp)
  410e88:	df000115 	stw	fp,4(sp)
  410e8c:	df000104 	addi	fp,sp,4
	u8 i;
	static u8 Excute = 0;

	
	if( Excute == 1 ) return;  // 이미 한번 실행했다면 정지.
  410e90:	d0a13303 	ldbu	r2,-31540(gp)
  410e94:	10803fcc 	andi	r2,r2,255
  410e98:	10800058 	cmpnei	r2,r2,1
  410e9c:	1000011e 	bne	r2,zero,410ea4 <Hw_Timer_Init+0x24>
  410ea0:	00002606 	br	410f3c <Hw_Timer_Init+0xbc>
	
	
	// 구조체 초기화
	for(i=0; i<TIMER_MAX; i++)
  410ea4:	e03fff05 	stb	zero,-4(fp)
  410ea8:	00001d06 	br	410f20 <Hw_Timer_Init+0xa0>
	{
		Timer_Tbl[i].Timer_En   = OFF;
  410eac:	e0ffff03 	ldbu	r3,-4(fp)
  410eb0:	00801074 	movhi	r2,65
  410eb4:	109f6204 	addi	r2,r2,32136
  410eb8:	1806913a 	slli	r3,r3,4
  410ebc:	10c5883a 	add	r2,r2,r3
  410ec0:	10000005 	stb	zero,0(r2)
		Timer_Tbl[i].Timer_Ctn  = 0;
  410ec4:	e0ffff03 	ldbu	r3,-4(fp)
  410ec8:	00801074 	movhi	r2,65
  410ecc:	109f6204 	addi	r2,r2,32136
  410ed0:	1806913a 	slli	r3,r3,4
  410ed4:	10c5883a 	add	r2,r2,r3
  410ed8:	1000008d 	sth	zero,2(r2)
		Timer_Tbl[i].Timer_Init = 0;
  410edc:	e0ffff03 	ldbu	r3,-4(fp)
  410ee0:	00801074 	movhi	r2,65
  410ee4:	109f6204 	addi	r2,r2,32136
  410ee8:	1806913a 	slli	r3,r3,4
  410eec:	18c00104 	addi	r3,r3,4
  410ef0:	10c5883a 	add	r2,r2,r3
  410ef4:	1000000d 	sth	zero,0(r2)
		Timer_Tbl[i].TmrFnct    = NULL;
  410ef8:	e0ffff03 	ldbu	r3,-4(fp)
  410efc:	00801074 	movhi	r2,65
  410f00:	109f6204 	addi	r2,r2,32136
  410f04:	1806913a 	slli	r3,r3,4
  410f08:	18c00204 	addi	r3,r3,8
  410f0c:	10c5883a 	add	r2,r2,r3
  410f10:	10000015 	stw	zero,0(r2)
	
	if( Excute == 1 ) return;  // 이미 한번 실행했다면 정지.
	
	
	// 구조체 초기화
	for(i=0; i<TIMER_MAX; i++)
  410f14:	e0bfff03 	ldbu	r2,-4(fp)
  410f18:	10800044 	addi	r2,r2,1
  410f1c:	e0bfff05 	stb	r2,-4(fp)
  410f20:	e0bfff03 	ldbu	r2,-4(fp)
  410f24:	108002b0 	cmpltui	r2,r2,10
  410f28:	103fe01e 	bne	r2,zero,410eac <_gp+0xffff16b0>
		Timer_Tbl[i].Timer_Init = 0;
		Timer_Tbl[i].TmrFnct    = NULL;
	}	                   
	
	
	Hw_Timer_SetupISR();
  410f2c:	0410f6c0 	call	410f6c <Hw_Timer_SetupISR>
	Hw_Timer_Setup();	
  410f30:	0410f880 	call	410f88 <Hw_Timer_Setup>

	Excute = 1;
  410f34:	00800044 	movi	r2,1
  410f38:	d0a13305 	stb	r2,-31540(gp)

}
  410f3c:	e037883a 	mov	sp,fp
  410f40:	dfc00117 	ldw	ra,4(sp)
  410f44:	df000017 	ldw	fp,0(sp)
  410f48:	dec00204 	addi	sp,sp,8
  410f4c:	f800283a 	ret

00410f50 <Hw_Timer_DeInit>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Timer_DeInit( void )
{
  410f50:	deffff04 	addi	sp,sp,-4
  410f54:	df000015 	stw	fp,0(sp)
  410f58:	d839883a 	mov	fp,sp

}
  410f5c:	e037883a 	mov	sp,fp
  410f60:	df000017 	ldw	fp,0(sp)
  410f64:	dec00104 	addi	sp,sp,4
  410f68:	f800283a 	ret

00410f6c <Hw_Timer_SetupISR>:
     	 	 	 타이머 H/W 기능을 초기화 한다.
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Timer_SetupISR( void )
{	
  410f6c:	deffff04 	addi	sp,sp,-4
  410f70:	df000015 	stw	fp,0(sp)
  410f74:	d839883a 	mov	fp,sp

}
  410f78:	e037883a 	mov	sp,fp
  410f7c:	df000017 	ldw	fp,0(sp)
  410f80:	dec00104 	addi	sp,sp,4
  410f84:	f800283a 	ret

00410f88 <Hw_Timer_Setup>:
     	 	 	 타이머 H/W 기능을 초기화 한다.
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Timer_Setup( void )
{
  410f88:	deffff04 	addi	sp,sp,-4
  410f8c:	df000015 	stw	fp,0(sp)
  410f90:	d839883a 	mov	fp,sp
	
}
  410f94:	e037883a 	mov	sp,fp
  410f98:	df000017 	ldw	fp,0(sp)
  410f9c:	dec00104 	addi	sp,sp,4
  410fa0:	f800283a 	ret

00410fa4 <Hw_Timer_Tick>:
			타이머인터럽트 발생시에 실행되는 함수(1ms 혹은 10ms 단위로 실행)
     ARG	: void
     RET	: void
---------------------------------------------------------------------------*/
void Hw_Timer_Tick(void)
{
  410fa4:	defffd04 	addi	sp,sp,-12
  410fa8:	dfc00215 	stw	ra,8(sp)
  410fac:	df000115 	stw	fp,4(sp)
  410fb0:	df000104 	addi	fp,sp,4
	u8 i;

	
	Hw_Timer_Counter++;
  410fb4:	d0a13117 	ldw	r2,-31548(gp)
  410fb8:	10800044 	addi	r2,r2,1
  410fbc:	d0a13115 	stw	r2,-31548(gp)


	if( Tmr_Ctn ) Tmr_Ctn--;
  410fc0:	d0a1320b 	ldhu	r2,-31544(gp)
  410fc4:	10bfffcc 	andi	r2,r2,65535
  410fc8:	10000326 	beq	r2,zero,410fd8 <Hw_Timer_Tick+0x34>
  410fcc:	d0a1320b 	ldhu	r2,-31544(gp)
  410fd0:	10bfffc4 	addi	r2,r2,-1
  410fd4:	d0a1320d 	sth	r2,-31544(gp)
	
	
			   
	for(i=0; i<TIMER_MAX; i++)								// 타이머 갯수만큼
  410fd8:	e03fff05 	stb	zero,-4(fp)
  410fdc:	00004506 	br	4110f4 <Hw_Timer_Tick+0x150>
	{
		if( Timer_Tbl[i].Timer_En == ON)   					// 타이머가 활성화 됬니?
  410fe0:	e0ffff03 	ldbu	r3,-4(fp)
  410fe4:	00801074 	movhi	r2,65
  410fe8:	109f6204 	addi	r2,r2,32136
  410fec:	1806913a 	slli	r3,r3,4
  410ff0:	10c5883a 	add	r2,r2,r3
  410ff4:	10800003 	ldbu	r2,0(r2)
  410ff8:	10803fcc 	andi	r2,r2,255
  410ffc:	10800058 	cmpnei	r2,r2,1
  411000:	1000391e 	bne	r2,zero,4110e8 <Hw_Timer_Tick+0x144>
		{
			Timer_Tbl[i].Timer_Ctn--;  						// 타이머값 감소
  411004:	e0ffff03 	ldbu	r3,-4(fp)
  411008:	00801074 	movhi	r2,65
  41100c:	109f6204 	addi	r2,r2,32136
  411010:	1808913a 	slli	r4,r3,4
  411014:	1105883a 	add	r2,r2,r4
  411018:	1080008b 	ldhu	r2,2(r2)
  41101c:	10bfffc4 	addi	r2,r2,-1
  411020:	1009883a 	mov	r4,r2
  411024:	00801074 	movhi	r2,65
  411028:	109f6204 	addi	r2,r2,32136
  41102c:	1806913a 	slli	r3,r3,4
  411030:	10c5883a 	add	r2,r2,r3
  411034:	1100008d 	sth	r4,2(r2)

			if(Timer_Tbl[i].Timer_Ctn == 0) 				// 타이머 오버플로어
  411038:	e0ffff03 	ldbu	r3,-4(fp)
  41103c:	00801074 	movhi	r2,65
  411040:	109f6204 	addi	r2,r2,32136
  411044:	1806913a 	slli	r3,r3,4
  411048:	10c5883a 	add	r2,r2,r3
  41104c:	1080008b 	ldhu	r2,2(r2)
  411050:	10bfffcc 	andi	r2,r2,65535
  411054:	1000241e 	bne	r2,zero,4110e8 <Hw_Timer_Tick+0x144>
			{
				if(Timer_Tbl[i].Timer_Mode == ONE_TIME)  	// 한번만 실행하는거면
  411058:	e0ffff03 	ldbu	r3,-4(fp)
  41105c:	00801074 	movhi	r2,65
  411060:	109f6204 	addi	r2,r2,32136
  411064:	1806913a 	slli	r3,r3,4
  411068:	10c5883a 	add	r2,r2,r3
  41106c:	10800043 	ldbu	r2,1(r2)
  411070:	10803fcc 	andi	r2,r2,255
  411074:	10800058 	cmpnei	r2,r2,1
  411078:	1000061e 	bne	r2,zero,411094 <Hw_Timer_Tick+0xf0>

				Timer_Tbl[i].Timer_En = OFF;     			// 타이머 OFF 한다.
  41107c:	e0ffff03 	ldbu	r3,-4(fp)
  411080:	00801074 	movhi	r2,65
  411084:	109f6204 	addi	r2,r2,32136
  411088:	1806913a 	slli	r3,r3,4
  41108c:	10c5883a 	add	r2,r2,r3
  411090:	10000005 	stb	zero,0(r2)

				Timer_Tbl[i].Timer_Ctn = Timer_Tbl[i].Timer_Init; // 타이머 초기화
  411094:	e13fff03 	ldbu	r4,-4(fp)
  411098:	e0ffff03 	ldbu	r3,-4(fp)
  41109c:	00801074 	movhi	r2,65
  4110a0:	109f6204 	addi	r2,r2,32136
  4110a4:	1806913a 	slli	r3,r3,4
  4110a8:	18c00104 	addi	r3,r3,4
  4110ac:	10c5883a 	add	r2,r2,r3
  4110b0:	10c0000b 	ldhu	r3,0(r2)
  4110b4:	00801074 	movhi	r2,65
  4110b8:	109f6204 	addi	r2,r2,32136
  4110bc:	2008913a 	slli	r4,r4,4
  4110c0:	1105883a 	add	r2,r2,r4
  4110c4:	10c0008d 	sth	r3,2(r2)

				(*Timer_Tbl[i].TmrFnct)();  				// 전달변수 없이 함수 실행
  4110c8:	e0ffff03 	ldbu	r3,-4(fp)
  4110cc:	00801074 	movhi	r2,65
  4110d0:	109f6204 	addi	r2,r2,32136
  4110d4:	1806913a 	slli	r3,r3,4
  4110d8:	18c00204 	addi	r3,r3,8
  4110dc:	10c5883a 	add	r2,r2,r3
  4110e0:	10800017 	ldw	r2,0(r2)
  4110e4:	103ee83a 	callr	r2

	if( Tmr_Ctn ) Tmr_Ctn--;
	
	
			   
	for(i=0; i<TIMER_MAX; i++)								// 타이머 갯수만큼
  4110e8:	e0bfff03 	ldbu	r2,-4(fp)
  4110ec:	10800044 	addi	r2,r2,1
  4110f0:	e0bfff05 	stb	r2,-4(fp)
  4110f4:	e0bfff03 	ldbu	r2,-4(fp)
  4110f8:	108002b0 	cmpltui	r2,r2,10
  4110fc:	103fb81e 	bne	r2,zero,410fe0 <_gp+0xffff17e4>
				(*Timer_Tbl[i].TmrFnct)();  				// 전달변수 없이 함수 실행
			}
		}
	}
	
}
  411100:	e037883a 	mov	sp,fp
  411104:	dfc00117 	ldw	ra,4(sp)
  411108:	df000017 	ldw	fp,0(sp)
  41110c:	dec00204 	addi	sp,sp,8
  411110:	f800283a 	ret

00411114 <Hw_Timer_Set>:
			void (*Fnct)(void),void *arg : 실행할 타이머 함수.
     RET
     	 	void
---------------------------------------------------------------------------*/
void Hw_Timer_Set(u8 TmrNum, u16 TmrData, u8 TmrMode, void (*Fnct)(void),void *arg)
{
  411114:	defffb04 	addi	sp,sp,-20
  411118:	df000415 	stw	fp,16(sp)
  41111c:	df000404 	addi	fp,sp,16
  411120:	2807883a 	mov	r3,r5
  411124:	3005883a 	mov	r2,r6
  411128:	e1ffff15 	stw	r7,-4(fp)
  41112c:	e13ffc05 	stb	r4,-16(fp)
  411130:	e0fffd0d 	sth	r3,-12(fp)
  411134:	e0bffe05 	stb	r2,-8(fp)
	Timer_Tbl[TmrNum].Timer_Mode = TmrMode;    // 모트설정
  411138:	e0fffc03 	ldbu	r3,-16(fp)
  41113c:	00801074 	movhi	r2,65
  411140:	109f6204 	addi	r2,r2,32136
  411144:	1806913a 	slli	r3,r3,4
  411148:	10c5883a 	add	r2,r2,r3
  41114c:	e0fffe03 	ldbu	r3,-8(fp)
  411150:	10c00045 	stb	r3,1(r2)
	Timer_Tbl[TmrNum].TmrFnct    = Fnct;       // 실행할 함수
  411154:	e0fffc03 	ldbu	r3,-16(fp)
  411158:	00801074 	movhi	r2,65
  41115c:	109f6204 	addi	r2,r2,32136
  411160:	1806913a 	slli	r3,r3,4
  411164:	18c00204 	addi	r3,r3,8
  411168:	10c5883a 	add	r2,r2,r3
  41116c:	e0ffff17 	ldw	r3,-4(fp)
  411170:	10c00015 	stw	r3,0(r2)
	Timer_Tbl[TmrNum].TmrFnctArg = arg;        // 매개변수
  411174:	e0fffc03 	ldbu	r3,-16(fp)
  411178:	00801074 	movhi	r2,65
  41117c:	109f6204 	addi	r2,r2,32136
  411180:	1806913a 	slli	r3,r3,4
  411184:	18c00304 	addi	r3,r3,12
  411188:	10c5883a 	add	r2,r2,r3
  41118c:	e0c00117 	ldw	r3,4(fp)
  411190:	10c00015 	stw	r3,0(r2)
	Timer_Tbl[TmrNum].Timer_Ctn  = TmrData;
  411194:	e0fffc03 	ldbu	r3,-16(fp)
  411198:	00801074 	movhi	r2,65
  41119c:	109f6204 	addi	r2,r2,32136
  4111a0:	1806913a 	slli	r3,r3,4
  4111a4:	10c5883a 	add	r2,r2,r3
  4111a8:	e0fffd0b 	ldhu	r3,-12(fp)
  4111ac:	10c0008d 	sth	r3,2(r2)
	Timer_Tbl[TmrNum].Timer_Init = TmrData;
  4111b0:	e0fffc03 	ldbu	r3,-16(fp)
  4111b4:	00801074 	movhi	r2,65
  4111b8:	109f6204 	addi	r2,r2,32136
  4111bc:	1806913a 	slli	r3,r3,4
  4111c0:	18c00104 	addi	r3,r3,4
  4111c4:	10c5883a 	add	r2,r2,r3
  4111c8:	e0fffd0b 	ldhu	r3,-12(fp)
  4111cc:	10c0000d 	sth	r3,0(r2)
}
  4111d0:	e037883a 	mov	sp,fp
  4111d4:	df000017 	ldw	fp,0(sp)
  4111d8:	dec00104 	addi	sp,sp,4
  4111dc:	f800283a 	ret

004111e0 <Hw_Timer_Start>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_Start(u8 TmrNum)
{
  4111e0:	defffe04 	addi	sp,sp,-8
  4111e4:	df000115 	stw	fp,4(sp)
  4111e8:	df000104 	addi	fp,sp,4
  4111ec:	2005883a 	mov	r2,r4
  4111f0:	e0bfff05 	stb	r2,-4(fp)
	if(TmrNum < TIMER_MAX)
  4111f4:	e0bfff03 	ldbu	r2,-4(fp)
  4111f8:	108002a8 	cmpgeui	r2,r2,10
  4111fc:	1000071e 	bne	r2,zero,41121c <Hw_Timer_Start+0x3c>
		Timer_Tbl[TmrNum].Timer_En = ON;
  411200:	e0ffff03 	ldbu	r3,-4(fp)
  411204:	00801074 	movhi	r2,65
  411208:	109f6204 	addi	r2,r2,32136
  41120c:	1806913a 	slli	r3,r3,4
  411210:	10c5883a 	add	r2,r2,r3
  411214:	00c00044 	movi	r3,1
  411218:	10c00005 	stb	r3,0(r2)
}
  41121c:	e037883a 	mov	sp,fp
  411220:	df000017 	ldw	fp,0(sp)
  411224:	dec00104 	addi	sp,sp,4
  411228:	f800283a 	ret

0041122c <Hw_Timer_Stop>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_Stop(u8 TmrNum)
{
  41122c:	defffe04 	addi	sp,sp,-8
  411230:	df000115 	stw	fp,4(sp)
  411234:	df000104 	addi	fp,sp,4
  411238:	2005883a 	mov	r2,r4
  41123c:	e0bfff05 	stb	r2,-4(fp)
	if(TmrNum < TIMER_MAX)
  411240:	e0bfff03 	ldbu	r2,-4(fp)
  411244:	108002a8 	cmpgeui	r2,r2,10
  411248:	1000061e 	bne	r2,zero,411264 <Hw_Timer_Stop+0x38>
		Timer_Tbl[TmrNum].Timer_En = OFF;
  41124c:	e0ffff03 	ldbu	r3,-4(fp)
  411250:	00801074 	movhi	r2,65
  411254:	109f6204 	addi	r2,r2,32136
  411258:	1806913a 	slli	r3,r3,4
  41125c:	10c5883a 	add	r2,r2,r3
  411260:	10000005 	stb	zero,0(r2)
}
  411264:	e037883a 	mov	sp,fp
  411268:	df000017 	ldw	fp,0(sp)
  41126c:	dec00104 	addi	sp,sp,4
  411270:	f800283a 	ret

00411274 <Hw_Timer_Reset>:
     	 	 - 타이머값 초기화
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_Reset(u8 TmrNum)
{
  411274:	defffe04 	addi	sp,sp,-8
  411278:	df000115 	stw	fp,4(sp)
  41127c:	df000104 	addi	fp,sp,4
  411280:	2005883a 	mov	r2,r4
  411284:	e0bfff05 	stb	r2,-4(fp)
	Timer_Tbl[TmrNum].Timer_En   = OFF;
  411288:	e0ffff03 	ldbu	r3,-4(fp)
  41128c:	00801074 	movhi	r2,65
  411290:	109f6204 	addi	r2,r2,32136
  411294:	1806913a 	slli	r3,r3,4
  411298:	10c5883a 	add	r2,r2,r3
  41129c:	10000005 	stb	zero,0(r2)
	Timer_Tbl[TmrNum].Timer_Ctn  = Timer_Tbl[TmrNum].Timer_Init;
  4112a0:	e13fff03 	ldbu	r4,-4(fp)
  4112a4:	e0ffff03 	ldbu	r3,-4(fp)
  4112a8:	00801074 	movhi	r2,65
  4112ac:	109f6204 	addi	r2,r2,32136
  4112b0:	1806913a 	slli	r3,r3,4
  4112b4:	18c00104 	addi	r3,r3,4
  4112b8:	10c5883a 	add	r2,r2,r3
  4112bc:	10c0000b 	ldhu	r3,0(r2)
  4112c0:	00801074 	movhi	r2,65
  4112c4:	109f6204 	addi	r2,r2,32136
  4112c8:	2008913a 	slli	r4,r4,4
  4112cc:	1105883a 	add	r2,r2,r4
  4112d0:	10c0008d 	sth	r3,2(r2)
}
  4112d4:	e037883a 	mov	sp,fp
  4112d8:	df000017 	ldw	fp,0(sp)
  4112dc:	dec00104 	addi	sp,sp,4
  4112e0:	f800283a 	ret

004112e4 <Hw_Timer_Delay_ms>:
     	 	 ms 단위로 딜레이를 준다.
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_Delay_ms( u16 DelayData )
{
  4112e4:	defffe04 	addi	sp,sp,-8
  4112e8:	df000115 	stw	fp,4(sp)
  4112ec:	df000104 	addi	fp,sp,4
  4112f0:	2005883a 	mov	r2,r4
  4112f4:	e0bfff0d 	sth	r2,-4(fp)
	Tmr_Ctn = DelayData;
  4112f8:	e0bfff0b 	ldhu	r2,-4(fp)
  4112fc:	d0a1320d 	sth	r2,-31544(gp)
	
	while( Tmr_Ctn );
  411300:	0001883a 	nop
  411304:	d0a1320b 	ldhu	r2,-31544(gp)
  411308:	10bfffcc 	andi	r2,r2,65535
  41130c:	103ffd1e 	bne	r2,zero,411304 <_gp+0xffff1b08>
}
  411310:	e037883a 	mov	sp,fp
  411314:	df000017 	ldw	fp,0(sp)
  411318:	dec00104 	addi	sp,sp,4
  41131c:	f800283a 	ret

00411320 <Hw_Timer_Get_Handle>:
     	 	 ms 단위로 딜레이를 준다.
     ARG
     RET
---------------------------------------------------------------------------*/
s16 Hw_Timer_Get_Handle( void )
{
  411320:	defffe04 	addi	sp,sp,-8
  411324:	df000115 	stw	fp,4(sp)
  411328:	df000104 	addi	fp,sp,4
	s16 TmrIndex = Tmr_HandleIndex;
  41132c:	d0a1328b 	ldhu	r2,-31542(gp)
  411330:	e0bfff0d 	sth	r2,-4(fp)
	
	Tmr_HandleIndex++;
  411334:	d0a1328b 	ldhu	r2,-31542(gp)
  411338:	10800044 	addi	r2,r2,1
  41133c:	d0a1328d 	sth	r2,-31542(gp)
	
	return TmrIndex;
  411340:	e0bfff0b 	ldhu	r2,-4(fp)
}
  411344:	e037883a 	mov	sp,fp
  411348:	df000017 	ldw	fp,0(sp)
  41134c:	dec00104 	addi	sp,sp,4
  411350:	f800283a 	ret

00411354 <Hw_Timer_Get_CountValue>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
u32 Hw_Timer_Get_CountValue( void )
{
  411354:	defffe04 	addi	sp,sp,-8
  411358:	dfc00115 	stw	ra,4(sp)
  41135c:	df000015 	stw	fp,0(sp)
  411360:	d839883a 	mov	fp,sp
	return millis();
  411364:	041200c0 	call	41200c <millis>
}
  411368:	e037883a 	mov	sp,fp
  41136c:	dfc00117 	ldw	ra,4(sp)
  411370:	df000017 	ldw	fp,0(sp)
  411374:	dec00204 	addi	sp,sp,8
  411378:	f800283a 	ret

0041137c <Hw_Timer_TimeStart>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Timer_TimeStart( HW_TIMER_TIME_OBJ *TimerTimePtr )
{
  41137c:	defffd04 	addi	sp,sp,-12
  411380:	dfc00215 	stw	ra,8(sp)
  411384:	df000115 	stw	fp,4(sp)
  411388:	df000104 	addi	fp,sp,4
  41138c:	e13fff15 	stw	r4,-4(fp)
	TimerTimePtr->Start = Hw_Timer_Get_CountValue();
  411390:	04113540 	call	411354 <Hw_Timer_Get_CountValue>
  411394:	1007883a 	mov	r3,r2
  411398:	e0bfff17 	ldw	r2,-4(fp)
  41139c:	10c00015 	stw	r3,0(r2)
}
  4113a0:	e037883a 	mov	sp,fp
  4113a4:	dfc00117 	ldw	ra,4(sp)
  4113a8:	df000017 	ldw	fp,0(sp)
  4113ac:	dec00204 	addi	sp,sp,8
  4113b0:	f800283a 	ret

004113b4 <Hw_Timer_TimeGetElapse>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
u32 Hw_Timer_TimeGetElapse( HW_TIMER_TIME_OBJ *TimerTimePtr )
{
  4113b4:	defffe04 	addi	sp,sp,-8
  4113b8:	df000115 	stw	fp,4(sp)
  4113bc:	df000104 	addi	fp,sp,4
  4113c0:	e13fff15 	stw	r4,-4(fp)
	return (Hw_Timer_Counter - TimerTimePtr->Start);
  4113c4:	d0e13117 	ldw	r3,-31548(gp)
  4113c8:	e0bfff17 	ldw	r2,-4(fp)
  4113cc:	10800017 	ldw	r2,0(r2)
  4113d0:	1885c83a 	sub	r2,r3,r2
}
  4113d4:	e037883a 	mov	sp,fp
  4113d8:	df000017 	ldw	fp,0(sp)
  4113dc:	dec00104 	addi	sp,sp,4
  4113e0:	f800283a 	ret

004113e4 <Hw_Uart_ISR_Handler>:




static void Hw_Uart_ISR_Handler(void* context)
{
  4113e4:	defffa04 	addi	sp,sp,-24
  4113e8:	dfc00515 	stw	ra,20(sp)
  4113ec:	df000415 	stw	fp,16(sp)
  4113f0:	df000404 	addi	fp,sp,16
  4113f4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 status;
	u8      UartData;

	HW_UART_OBJ *pUart = (HW_UART_OBJ *)context;
  4113f8:	e0bfff17 	ldw	r2,-4(fp)
  4113fc:	e0bffc15 	stw	r2,-16(fp)



	//-- 상태 읽기
	//
	status = IORD_ALTERA_AVALON_UART_STATUS(pUart->pBase);
  411400:	e0bffc17 	ldw	r2,-16(fp)
  411404:	10800317 	ldw	r2,12(r2)
  411408:	10800204 	addi	r2,r2,8
  41140c:	10800037 	ldwio	r2,0(r2)
  411410:	e0bffd15 	stw	r2,-12(fp)

	//-- Clear any error flags set at the device
	//
	IOWR_ALTERA_AVALON_UART_STATUS(pUart->pBase, 0);
  411414:	e0bffc17 	ldw	r2,-16(fp)
  411418:	10800317 	ldw	r2,12(r2)
  41141c:	10800204 	addi	r2,r2,8
  411420:	0007883a 	mov	r3,zero
  411424:	10c00035 	stwio	r3,0(r2)

	//-- Dummy read to ensure IRQ is negated before ISR returns
	//
	IORD_ALTERA_AVALON_UART_STATUS(pUart->pBase);
  411428:	e0bffc17 	ldw	r2,-16(fp)
  41142c:	10800317 	ldw	r2,12(r2)
  411430:	10800204 	addi	r2,r2,8
  411434:	10800037 	ldwio	r2,0(r2)


	//-- RX 인터럽트 처리
	//
	if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  411438:	e0bffd17 	ldw	r2,-12(fp)
  41143c:	1080200c 	andi	r2,r2,128
  411440:	10001926 	beq	r2,zero,4114a8 <Hw_Uart_ISR_Handler+0xc4>
	{
		if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | ALTERA_AVALON_UART_STATUS_FE_MSK))
  411444:	e0bffd17 	ldw	r2,-12(fp)
  411448:	108000cc 	andi	r2,r2,3
  41144c:	1000161e 	bne	r2,zero,4114a8 <Hw_Uart_ISR_Handler+0xc4>
		{
			return;
		}

		UartData = IORD_ALTERA_AVALON_UART_RXDATA(pUart->pBase);
  411450:	e0bffc17 	ldw	r2,-16(fp)
  411454:	10800317 	ldw	r2,12(r2)
  411458:	10800037 	ldwio	r2,0(r2)
  41145c:	e0bffe05 	stb	r2,-8(fp)

		Hw_Uart_Q_Push( pUart->Port, &UartData );
  411460:	e0bffc17 	ldw	r2,-16(fp)
  411464:	10800017 	ldw	r2,0(r2)
  411468:	10c03fcc 	andi	r3,r2,255
  41146c:	e0bffe04 	addi	r2,fp,-8
  411470:	1809883a 	mov	r4,r3
  411474:	100b883a 	mov	r5,r2
  411478:	0411b5c0 	call	411b5c <Hw_Uart_Q_Push>

		if( pUart->ISR_FuncPtr != NULL )
  41147c:	e0bffc17 	ldw	r2,-16(fp)
  411480:	10800217 	ldw	r2,8(r2)
  411484:	10000826 	beq	r2,zero,4114a8 <Hw_Uart_ISR_Handler+0xc4>
		{
			(*pUart->ISR_FuncPtr)(UartData);
  411488:	e0bffc17 	ldw	r2,-16(fp)
  41148c:	10800217 	ldw	r2,8(r2)
  411490:	e0fffe03 	ldbu	r3,-8(fp)
  411494:	18c03fcc 	andi	r3,r3,255
  411498:	18c0201c 	xori	r3,r3,128
  41149c:	18ffe004 	addi	r3,r3,-128
  4114a0:	1809883a 	mov	r4,r3
  4114a4:	103ee83a 	callr	r2
		}
	}
}
  4114a8:	e037883a 	mov	sp,fp
  4114ac:	dfc00117 	ldw	ra,4(sp)
  4114b0:	df000017 	ldw	fp,0(sp)
  4114b4:	dec00204 	addi	sp,sp,8
  4114b8:	f800283a 	ret

004114bc <Hw_Uart_Init>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Init( void )
{
  4114bc:	defffd04 	addi	sp,sp,-12
  4114c0:	dfc00215 	stw	ra,8(sp)
  4114c4:	df000115 	stw	fp,4(sp)
  4114c8:	df000104 	addi	fp,sp,4
	u32 i;
	
	Hw_Uart_Q_Init();
  4114cc:	04119b40 	call	4119b4 <Hw_Uart_Q_Init>
	
	
	for( i=0; i<HW_UART_MAX_CH; i++ )
  4114d0:	e03fff15 	stw	zero,-4(fp)
  4114d4:	00001106 	br	41151c <Hw_Uart_Init+0x60>
	{
		Hw_Uart_Ch[i].Baud 		  = 0;
  4114d8:	00801074 	movhi	r2,65
  4114dc:	109f8a04 	addi	r2,r2,32296
  4114e0:	e0ffff17 	ldw	r3,-4(fp)
  4114e4:	1806913a 	slli	r3,r3,4
  4114e8:	18c00104 	addi	r3,r3,4
  4114ec:	10c5883a 	add	r2,r2,r3
  4114f0:	10000015 	stw	zero,0(r2)
		Hw_Uart_Ch[i].ISR_FuncPtr = NULL;
  4114f4:	00801074 	movhi	r2,65
  4114f8:	109f8a04 	addi	r2,r2,32296
  4114fc:	e0ffff17 	ldw	r3,-4(fp)
  411500:	1806913a 	slli	r3,r3,4
  411504:	18c00204 	addi	r3,r3,8
  411508:	10c5883a 	add	r2,r2,r3
  41150c:	10000015 	stw	zero,0(r2)
	u32 i;
	
	Hw_Uart_Q_Init();
	
	
	for( i=0; i<HW_UART_MAX_CH; i++ )
  411510:	e0bfff17 	ldw	r2,-4(fp)
  411514:	10800044 	addi	r2,r2,1
  411518:	e0bfff15 	stw	r2,-4(fp)
  41151c:	e0bfff17 	ldw	r2,-4(fp)
  411520:	108001b0 	cmpltui	r2,r2,6
  411524:	103fec1e 	bne	r2,zero,4114d8 <_gp+0xffff1cdc>
		Hw_Uart_Ch[i].Baud 		  = 0;
		Hw_Uart_Ch[i].ISR_FuncPtr = NULL;
	}	
	
	
	Hw_Uart_Open( HW_UART_COM1, 115200, NULL );
  411528:	0009883a 	mov	r4,zero
  41152c:	014000b4 	movhi	r5,2
  411530:	29708004 	addi	r5,r5,-15872
  411534:	000d883a 	mov	r6,zero
  411538:	04115800 	call	411580 <Hw_Uart_Open>
	Hw_Uart_Open( HW_UART_COM2, 115200, NULL );	
  41153c:	01000044 	movi	r4,1
  411540:	014000b4 	movhi	r5,2
  411544:	29708004 	addi	r5,r5,-15872
  411548:	000d883a 	mov	r6,zero
  41154c:	04115800 	call	411580 <Hw_Uart_Open>
}
  411550:	e037883a 	mov	sp,fp
  411554:	dfc00117 	ldw	ra,4(sp)
  411558:	df000017 	ldw	fp,0(sp)
  41155c:	dec00204 	addi	sp,sp,8
  411560:	f800283a 	ret

00411564 <Hw_Uart_DeInit>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_DeInit( void )
{
  411564:	deffff04 	addi	sp,sp,-4
  411568:	df000015 	stw	fp,0(sp)
  41156c:	d839883a 	mov	fp,sp

}
  411570:	e037883a 	mov	sp,fp
  411574:	df000017 	ldw	fp,0(sp)
  411578:	dec00104 	addi	sp,sp,4
  41157c:	f800283a 	ret

00411580 <Hw_Uart_Open>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Open( u8 Ch, u32 BaudData, void (*ISR_FuncPtr)(char Ch) )
{	
  411580:	defffb04 	addi	sp,sp,-20
  411584:	dfc00415 	stw	ra,16(sp)
  411588:	df000315 	stw	fp,12(sp)
  41158c:	df000304 	addi	fp,sp,12
  411590:	2005883a 	mov	r2,r4
  411594:	e17ffe15 	stw	r5,-8(fp)
  411598:	e1bfff15 	stw	r6,-4(fp)
  41159c:	e0bffd05 	stb	r2,-12(fp)
	switch( Ch )
  4115a0:	e0bffd03 	ldbu	r2,-12(fp)
  4115a4:	10c00168 	cmpgeui	r3,r2,5
  4115a8:	1800141e 	bne	r3,zero,4115fc <Hw_Uart_Open+0x7c>
  4115ac:	100690ba 	slli	r3,r2,2
  4115b0:	00801074 	movhi	r2,65
  4115b4:	10857104 	addi	r2,r2,5572
  4115b8:	1885883a 	add	r2,r3,r2
  4115bc:	10800017 	ldw	r2,0(r2)
  4115c0:	1000683a 	jmp	r2
  4115c4:	004115d8 	cmpnei	at,zero,1111
  4115c8:	004115e8 	cmpgeui	at,zero,1111
  4115cc:	004115f8 	rdprs	at,zero,1111
  4115d0:	004115f8 	rdprs	at,zero,1111
  4115d4:	004115f8 	rdprs	at,zero,1111
	{
		case HW_UART_COM1:
			Hw_Uart_Open_COM1( BaudData, ISR_FuncPtr );
  4115d8:	e13ffe17 	ldw	r4,-8(fp)
  4115dc:	e17fff17 	ldw	r5,-4(fp)
  4115e0:	04116100 	call	411610 <Hw_Uart_Open_COM1>
			break;
  4115e4:	00000506 	br	4115fc <Hw_Uart_Open+0x7c>
			
		case HW_UART_COM2:
			Hw_Uart_Open_COM2( BaudData, ISR_FuncPtr );
  4115e8:	e13ffe17 	ldw	r4,-8(fp)
  4115ec:	e17fff17 	ldw	r5,-4(fp)
  4115f0:	04116bc0 	call	4116bc <Hw_Uart_Open_COM2>
			break;
  4115f4:	00000106 	br	4115fc <Hw_Uart_Open+0x7c>

		case HW_UART_COM4:
			break;

		case HW_UART_COM5:
			break;			
  4115f8:	0001883a 	nop
	}
}
  4115fc:	e037883a 	mov	sp,fp
  411600:	dfc00117 	ldw	ra,4(sp)
  411604:	df000017 	ldw	fp,0(sp)
  411608:	dec00204 	addi	sp,sp,8
  41160c:	f800283a 	ret

00411610 <Hw_Uart_Open_COM1>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Open_COM1( u32 BaudData, void (*ISR_FuncPtr)(char Ch) )
{	
  411610:	defff904 	addi	sp,sp,-28
  411614:	dfc00615 	stw	ra,24(sp)
  411618:	df000515 	stw	fp,20(sp)
  41161c:	df000504 	addi	fp,sp,20
  411620:	e13ffe15 	stw	r4,-8(fp)
  411624:	e17fff15 	stw	r5,-4(fp)
	u32 Reg;
	void *pBase = (void *)UART_0_BASE;
  411628:	008010b4 	movhi	r2,66
  41162c:	10863804 	addi	r2,r2,6368
  411630:	e0bffc15 	stw	r2,-16(fp)


	Hw_Uart_Ch[HW_UART_COM1].Port 		 = HW_UART_COM1;
  411634:	00801074 	movhi	r2,65
  411638:	109f8a04 	addi	r2,r2,32296
  41163c:	10000015 	stw	zero,0(r2)
	Hw_Uart_Ch[HW_UART_COM1].Baud 		 = BaudData;
  411640:	00801074 	movhi	r2,65
  411644:	109f8a04 	addi	r2,r2,32296
  411648:	e0fffe17 	ldw	r3,-8(fp)
  41164c:	10c00115 	stw	r3,4(r2)
	Hw_Uart_Ch[HW_UART_COM1].ISR_FuncPtr = ISR_FuncPtr;
  411650:	00801074 	movhi	r2,65
  411654:	109f8a04 	addi	r2,r2,32296
  411658:	e0ffff17 	ldw	r3,-4(fp)
  41165c:	10c00215 	stw	r3,8(r2)
	Hw_Uart_Ch[HW_UART_COM1].pBase       = pBase;
  411660:	00801074 	movhi	r2,65
  411664:	109f8a04 	addi	r2,r2,32296
  411668:	e0fffc17 	ldw	r3,-16(fp)
  41166c:	10c00315 	stw	r3,12(r2)


	//-- 인터럽트 활성화
	//
	Reg = ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  411670:	00802004 	movi	r2,128
  411674:	e0bffd15 	stw	r2,-12(fp)


	IOWR_ALTERA_AVALON_UART_CONTROL(pBase, Reg);
  411678:	e0bffc17 	ldw	r2,-16(fp)
  41167c:	10800304 	addi	r2,r2,12
  411680:	e0fffd17 	ldw	r3,-12(fp)
  411684:	10c00035 	stwio	r3,0(r2)


	//-- 인터럽트 연결
	//
    alt_ic_isr_register( UART_0_IRQ_INTERRUPT_CONTROLLER_ID, UART_0_IRQ, Hw_Uart_ISR_Handler, (void *)&Hw_Uart_Ch[HW_UART_COM1], 0x0);
  411688:	d8000015 	stw	zero,0(sp)
  41168c:	0009883a 	mov	r4,zero
  411690:	01400044 	movi	r5,1
  411694:	01801074 	movhi	r6,65
  411698:	3184f904 	addi	r6,r6,5092
  41169c:	01c01074 	movhi	r7,65
  4116a0:	39df8a04 	addi	r7,r7,32296
  4116a4:	0413bd80 	call	413bd8 <alt_ic_isr_register>
}
  4116a8:	e037883a 	mov	sp,fp
  4116ac:	dfc00117 	ldw	ra,4(sp)
  4116b0:	df000017 	ldw	fp,0(sp)
  4116b4:	dec00204 	addi	sp,sp,8
  4116b8:	f800283a 	ret

004116bc <Hw_Uart_Open_COM2>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Open_COM2( u32 BaudData, void (*ISR_FuncPtr)(char Ch) )
{	
  4116bc:	defffd04 	addi	sp,sp,-12
  4116c0:	df000215 	stw	fp,8(sp)
  4116c4:	df000204 	addi	fp,sp,8
  4116c8:	e13ffe15 	stw	r4,-8(fp)
  4116cc:	e17fff15 	stw	r5,-4(fp)

	Hw_Uart_Ch[HW_UART_COM2].Baud 		 = BaudData;
  4116d0:	00801074 	movhi	r2,65
  4116d4:	109f8a04 	addi	r2,r2,32296
  4116d8:	e0fffe17 	ldw	r3,-8(fp)
  4116dc:	10c00515 	stw	r3,20(r2)
	Hw_Uart_Ch[HW_UART_COM2].ISR_FuncPtr = ISR_FuncPtr;
  4116e0:	00801074 	movhi	r2,65
  4116e4:	109f8a04 	addi	r2,r2,32296
  4116e8:	e0ffff17 	ldw	r3,-4(fp)
  4116ec:	10c00615 	stw	r3,24(r2)
}
  4116f0:	e037883a 	mov	sp,fp
  4116f4:	df000017 	ldw	fp,0(sp)
  4116f8:	dec00104 	addi	sp,sp,4
  4116fc:	f800283a 	ret

00411700 <Hw_Uart_SetReceiveFuncISR>:
			: 시리얼 포트에서 데이터 수신시 실행할 함수 설정 .
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_SetReceiveFuncISR( u8 Ch, void (*ISR_FuncPtr)(char Ch) )
{
  411700:	defffd04 	addi	sp,sp,-12
  411704:	df000215 	stw	fp,8(sp)
  411708:	df000204 	addi	fp,sp,8
  41170c:	2005883a 	mov	r2,r4
  411710:	e17fff15 	stw	r5,-4(fp)
  411714:	e0bffe05 	stb	r2,-8(fp)
	Hw_Uart_Ch[Ch].ISR_FuncPtr = ISR_FuncPtr;
  411718:	e0fffe03 	ldbu	r3,-8(fp)
  41171c:	00801074 	movhi	r2,65
  411720:	109f8a04 	addi	r2,r2,32296
  411724:	1806913a 	slli	r3,r3,4
  411728:	18c00204 	addi	r3,r3,8
  41172c:	10c5883a 	add	r2,r2,r3
  411730:	e0ffff17 	ldw	r3,-4(fp)
  411734:	10c00015 	stw	r3,0(r2)
}
  411738:	e037883a 	mov	sp,fp
  41173c:	df000017 	ldw	fp,0(sp)
  411740:	dec00104 	addi	sp,sp,4
  411744:	f800283a 	ret

00411748 <Hw_Uart_Getch>:
			: 시리얼 포트에서 문자 1바이트 읽는다.
     ARG
     RET
---------------------------------------------------------------------------*/
u8 Hw_Uart_Getch( u8 Ch )
{
  411748:	defffc04 	addi	sp,sp,-16
  41174c:	dfc00315 	stw	ra,12(sp)
  411750:	df000215 	stw	fp,8(sp)
  411754:	df000204 	addi	fp,sp,8
  411758:	2005883a 	mov	r2,r4
  41175c:	e0bfff05 	stb	r2,-4(fp)
	u8 Uart_GetData = 0;
  411760:	e03ffe05 	stb	zero,-8(fp)

	while( 1 )
	{
		// 버퍼에 데이터 들어올때까지 기다린다.
		if( HW_UART_Q_VAILD(Ch) > 0 ) break;
  411764:	e0bfff03 	ldbu	r2,-4(fp)
  411768:	1009883a 	mov	r4,r2
  41176c:	0411ac80 	call	411ac8 <HW_UART_Q_VAILD>
  411770:	10000126 	beq	r2,zero,411778 <Hw_Uart_Getch+0x30>
  411774:	00000106 	br	41177c <Hw_Uart_Getch+0x34>
	}
  411778:	003ffa06 	br	411764 <_gp+0xffff1f68>

	Hw_Uart_Q_Pop( Ch, &Uart_GetData );
  41177c:	e0bfff03 	ldbu	r2,-4(fp)
  411780:	1009883a 	mov	r4,r2
  411784:	e17ffe04 	addi	r5,fp,-8
  411788:	0411c940 	call	411c94 <Hw_Uart_Q_Pop>

	return Uart_GetData;
  41178c:	e0bffe03 	ldbu	r2,-8(fp)
}
  411790:	e037883a 	mov	sp,fp
  411794:	dfc00117 	ldw	ra,4(sp)
  411798:	df000017 	ldw	fp,0(sp)
  41179c:	dec00204 	addi	sp,sp,8
  4117a0:	f800283a 	ret

004117a4 <Hw_Uart_Putch>:
			: 시리얼 포트로 문자 1바이트 전송
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_Putch( u8 Ch,  char Uart_PutData )
{
  4117a4:	defffc04 	addi	sp,sp,-16
  4117a8:	df000315 	stw	fp,12(sp)
  4117ac:	df000304 	addi	fp,sp,12
  4117b0:	2007883a 	mov	r3,r4
  4117b4:	2805883a 	mov	r2,r5
  4117b8:	e0fffe05 	stb	r3,-8(fp)
  4117bc:	e0bfff05 	stb	r2,-4(fp)
	u32 Reg;


	switch( Ch )
  4117c0:	e0bffe03 	ldbu	r2,-8(fp)
  4117c4:	10c001a8 	cmpgeui	r3,r2,6
  4117c8:	1800271e 	bne	r3,zero,411868 <Hw_Uart_Putch+0xc4>
  4117cc:	100690ba 	slli	r3,r2,2
  4117d0:	00801074 	movhi	r2,65
  4117d4:	1085f904 	addi	r2,r2,6116
  4117d8:	1885883a 	add	r2,r3,r2
  4117dc:	10800017 	ldw	r2,0(r2)
  4117e0:	1000683a 	jmp	r2
  4117e4:	004117fc 	xorhi	at,zero,1119
  4117e8:	00411864 	muli	at,zero,1121
  4117ec:	00411864 	muli	at,zero,1121
  4117f0:	00411864 	muli	at,zero,1121
  4117f4:	00411864 	muli	at,zero,1121
  4117f8:	00411864 	muli	at,zero,1121
	{
		case HW_UART_COM1:
			while(1)
			{
				Reg = IORD_ALTERA_AVALON_UART_STATUS( Hw_Uart_Ch[Ch].pBase );
  4117fc:	e0fffe03 	ldbu	r3,-8(fp)
  411800:	00801074 	movhi	r2,65
  411804:	109f8a04 	addi	r2,r2,32296
  411808:	1806913a 	slli	r3,r3,4
  41180c:	18c00304 	addi	r3,r3,12
  411810:	10c5883a 	add	r2,r2,r3
  411814:	10800017 	ldw	r2,0(r2)
  411818:	10800204 	addi	r2,r2,8
  41181c:	10800037 	ldwio	r2,0(r2)
  411820:	e0bffd15 	stw	r2,-12(fp)
				if( Reg & ALTERA_AVALON_UART_STATUS_TRDY_MSK )
  411824:	e0bffd17 	ldw	r2,-12(fp)
  411828:	1080100c 	andi	r2,r2,64
  41182c:	10000c26 	beq	r2,zero,411860 <Hw_Uart_Putch+0xbc>
				{
					IOWR_ALTERA_AVALON_UART_TXDATA( Hw_Uart_Ch[Ch].pBase, Uart_PutData );
  411830:	e0fffe03 	ldbu	r3,-8(fp)
  411834:	00801074 	movhi	r2,65
  411838:	109f8a04 	addi	r2,r2,32296
  41183c:	1806913a 	slli	r3,r3,4
  411840:	18c00304 	addi	r3,r3,12
  411844:	10c5883a 	add	r2,r2,r3
  411848:	10800017 	ldw	r2,0(r2)
  41184c:	10800104 	addi	r2,r2,4
  411850:	e0ffff07 	ldb	r3,-4(fp)
  411854:	10c00035 	stwio	r3,0(r2)
					break;
  411858:	0001883a 	nop
				}
			}
			break;
  41185c:	00000206 	br	411868 <Hw_Uart_Putch+0xc4>
				if( Reg & ALTERA_AVALON_UART_STATUS_TRDY_MSK )
				{
					IOWR_ALTERA_AVALON_UART_TXDATA( Hw_Uart_Ch[Ch].pBase, Uart_PutData );
					break;
				}
			}
  411860:	003fe606 	br	4117fc <_gp+0xffff2000>

		case HW_UART_COM5:
			break;		

		case HW_UART_VCOM:
			break;	
  411864:	0001883a 	nop
	}	
}
  411868:	e037883a 	mov	sp,fp
  41186c:	df000017 	ldw	fp,0(sp)
  411870:	dec00104 	addi	sp,sp,4
  411874:	f800283a 	ret

00411878 <Hw_Uart_PrintEx>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_PrintEx( u8 Ch, char *UartPrintData )
{
  411878:	defffc04 	addi	sp,sp,-16
  41187c:	dfc00315 	stw	ra,12(sp)
  411880:	df000215 	stw	fp,8(sp)
  411884:	df000204 	addi	fp,sp,8
  411888:	2005883a 	mov	r2,r4
  41188c:	e17fff15 	stw	r5,-4(fp)
  411890:	e0bffe05 	stb	r2,-8(fp)
	while( *UartPrintData != '\0' )
  411894:	00000c06 	br	4118c8 <Hw_Uart_PrintEx+0x50>
	{
		Hw_Uart_Putch( Ch, *UartPrintData );
  411898:	e0fffe03 	ldbu	r3,-8(fp)
  41189c:	e0bfff17 	ldw	r2,-4(fp)
  4118a0:	10800003 	ldbu	r2,0(r2)
  4118a4:	10803fcc 	andi	r2,r2,255
  4118a8:	1080201c 	xori	r2,r2,128
  4118ac:	10bfe004 	addi	r2,r2,-128
  4118b0:	1809883a 	mov	r4,r3
  4118b4:	100b883a 	mov	r5,r2
  4118b8:	04117a40 	call	4117a4 <Hw_Uart_Putch>
		UartPrintData++;
  4118bc:	e0bfff17 	ldw	r2,-4(fp)
  4118c0:	10800044 	addi	r2,r2,1
  4118c4:	e0bfff15 	stw	r2,-4(fp)
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_PrintEx( u8 Ch, char *UartPrintData )
{
	while( *UartPrintData != '\0' )
  4118c8:	e0bfff17 	ldw	r2,-4(fp)
  4118cc:	10800003 	ldbu	r2,0(r2)
  4118d0:	10803fcc 	andi	r2,r2,255
  4118d4:	1080201c 	xori	r2,r2,128
  4118d8:	10bfe004 	addi	r2,r2,-128
  4118dc:	103fee1e 	bne	r2,zero,411898 <_gp+0xffff209c>
	{
		Hw_Uart_Putch( Ch, *UartPrintData );
		UartPrintData++;
	}        
}
  4118e0:	e037883a 	mov	sp,fp
  4118e4:	dfc00117 	ldw	ra,4(sp)
  4118e8:	df000017 	ldw	fp,0(sp)
  4118ec:	dec00204 	addi	sp,sp,8
  4118f0:	f800283a 	ret

004118f4 <Hw_Uart_Printf>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
void Hw_Uart_Printf( u8 Ch,  char *format, ... )
{
  4118f4:	deffc704 	addi	sp,sp,-228
  4118f8:	dfc03615 	stw	ra,216(sp)
  4118fc:	df003515 	stw	fp,212(sp)
  411900:	df003504 	addi	fp,sp,212
  411904:	2005883a 	mov	r2,r4
  411908:	e1800215 	stw	r6,8(fp)
  41190c:	e1c00315 	stw	r7,12(fp)
  411910:	e17fff15 	stw	r5,-4(fp)
  411914:	e0bffe05 	stb	r2,-8(fp)
	char Str[200];
	
	va_list ap;
	
	va_start( ap, format );
  411918:	e0800204 	addi	r2,fp,8
  41191c:	e0bffd15 	stw	r2,-12(fp)

	//vsprintf( Str, format, ap );	

	Lb_vsprintf(Str, format, ap );
  411920:	e0bffd17 	ldw	r2,-12(fp)
  411924:	e13fcb04 	addi	r4,fp,-212
  411928:	e17fff17 	ldw	r5,-4(fp)
  41192c:	100d883a 	mov	r6,r2
  411930:	04134a00 	call	4134a0 <vsprintf>
	va_end(ap);
	
	
	
	
	Hw_Uart_PrintEx( Ch, Str );
  411934:	e0bffe03 	ldbu	r2,-8(fp)
  411938:	1009883a 	mov	r4,r2
  41193c:	e17fcb04 	addi	r5,fp,-212
  411940:	04118780 	call	411878 <Hw_Uart_PrintEx>
}
  411944:	e037883a 	mov	sp,fp
  411948:	dfc00117 	ldw	ra,4(sp)
  41194c:	df000017 	ldw	fp,0(sp)
  411950:	dec00404 	addi	sp,sp,16
  411954:	f800283a 	ret

00411958 <Hw_Uart_GetchNoWait>:
     WORK
     ARG
     RET
---------------------------------------------------------------------------*/
u8 Hw_Uart_GetchNoWait( u8 Ch, u8 *cReturn )
{
  411958:	defffc04 	addi	sp,sp,-16
  41195c:	dfc00315 	stw	ra,12(sp)
  411960:	df000215 	stw	fp,8(sp)
  411964:	df000204 	addi	fp,sp,8
  411968:	2005883a 	mov	r2,r4
  41196c:	e17fff15 	stw	r5,-4(fp)
  411970:	e0bffe05 	stb	r2,-8(fp)
	// 버퍼에 데이터 없으면 실패로 종료.
	if( HW_UART_Q_VAILD(Ch) == 0 )
  411974:	e0bffe03 	ldbu	r2,-8(fp)
  411978:	1009883a 	mov	r4,r2
  41197c:	0411ac80 	call	411ac8 <HW_UART_Q_VAILD>
  411980:	1000021e 	bne	r2,zero,41198c <Hw_Uart_GetchNoWait+0x34>
	{
		return FALSE;
  411984:	0005883a 	mov	r2,zero
  411988:	00000506 	br	4119a0 <Hw_Uart_GetchNoWait+0x48>
	}
		   
	Hw_Uart_Q_Pop( Ch, cReturn );
  41198c:	e0bffe03 	ldbu	r2,-8(fp)
  411990:	1009883a 	mov	r4,r2
  411994:	e17fff17 	ldw	r5,-4(fp)
  411998:	0411c940 	call	411c94 <Hw_Uart_Q_Pop>
	
	return TRUE;
  41199c:	00800044 	movi	r2,1
}
  4119a0:	e037883a 	mov	sp,fp
  4119a4:	dfc00117 	ldw	ra,4(sp)
  4119a8:	df000017 	ldw	fp,0(sp)
  4119ac:	dec00204 	addi	sp,sp,8
  4119b0:	f800283a 	ret

004119b4 <Hw_Uart_Q_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Uart_Q_Init( void )
{
  4119b4:	defffe04 	addi	sp,sp,-8
  4119b8:	df000115 	stw	fp,4(sp)
  4119bc:	df000104 	addi	fp,sp,4
	u8 i;

	for( i=0; i<HW_UART_Q_CH_MAX; i++ )
  4119c0:	e03fff05 	stb	zero,-4(fp)
  4119c4:	00001406 	br	411a18 <Hw_Uart_Q_Init+0x64>
	{
		Hw_Uart_Q_Start[i] = Hw_Uart_Q_End[i] = 0;
  4119c8:	e13fff03 	ldbu	r4,-4(fp)
  4119cc:	e0bfff03 	ldbu	r2,-4(fp)
  4119d0:	00c01074 	movhi	r3,65
  4119d4:	18dfdf84 	addi	r3,r3,32638
  4119d8:	108b883a 	add	r5,r2,r2
  4119dc:	1947883a 	add	r3,r3,r5
  4119e0:	1800000d 	sth	zero,0(r3)
  4119e4:	00c01074 	movhi	r3,65
  4119e8:	18dfdf84 	addi	r3,r3,32638
  4119ec:	1085883a 	add	r2,r2,r2
  4119f0:	1885883a 	add	r2,r3,r2
  4119f4:	10c0000b 	ldhu	r3,0(r2)
  4119f8:	00801074 	movhi	r2,65
  4119fc:	109fe304 	addi	r2,r2,32652
  411a00:	2109883a 	add	r4,r4,r4
  411a04:	1105883a 	add	r2,r2,r4
  411a08:	10c0000d 	sth	r3,0(r2)
---------------------------------------------------------------------------*/
void Hw_Uart_Q_Init( void )
{
	u8 i;

	for( i=0; i<HW_UART_Q_CH_MAX; i++ )
  411a0c:	e0bfff03 	ldbu	r2,-4(fp)
  411a10:	10800044 	addi	r2,r2,1
  411a14:	e0bfff05 	stb	r2,-4(fp)
  411a18:	e0bfff03 	ldbu	r2,-4(fp)
  411a1c:	108001f0 	cmpltui	r2,r2,7
  411a20:	103fe91e 	bne	r2,zero,4119c8 <_gp+0xffff21cc>
	{
		Hw_Uart_Q_Start[i] = Hw_Uart_Q_End[i] = 0;
	}
}
  411a24:	e037883a 	mov	sp,fp
  411a28:	df000017 	ldw	fp,0(sp)
  411a2c:	dec00104 	addi	sp,sp,4
  411a30:	f800283a 	ret

00411a34 <HW_UART_Q_SIZE>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 HW_UART_Q_SIZE( u8 Ch )
{
  411a34:	defffe04 	addi	sp,sp,-8
  411a38:	df000115 	stw	fp,4(sp)
  411a3c:	df000104 	addi	fp,sp,4
  411a40:	2005883a 	mov	r2,r4
  411a44:	e0bfff05 	stb	r2,-4(fp)
	return (Hw_Uart_Q_Start[Ch] - Hw_Uart_Q_End[Ch] + HW_UART_Q_BUFFER_MAX) % HW_UART_Q_BUFFER_MAX;
  411a48:	e0ffff03 	ldbu	r3,-4(fp)
  411a4c:	00801074 	movhi	r2,65
  411a50:	109fe304 	addi	r2,r2,32652
  411a54:	18c7883a 	add	r3,r3,r3
  411a58:	10c5883a 	add	r2,r2,r3
  411a5c:	1080000b 	ldhu	r2,0(r2)
  411a60:	113fffcc 	andi	r4,r2,65535
  411a64:	2120001c 	xori	r4,r4,32768
  411a68:	21200004 	addi	r4,r4,-32768
  411a6c:	e0ffff03 	ldbu	r3,-4(fp)
  411a70:	00801074 	movhi	r2,65
  411a74:	109fdf84 	addi	r2,r2,32638
  411a78:	18c7883a 	add	r3,r3,r3
  411a7c:	10c5883a 	add	r2,r2,r3
  411a80:	1080000b 	ldhu	r2,0(r2)
  411a84:	10bfffcc 	andi	r2,r2,65535
  411a88:	10a0001c 	xori	r2,r2,32768
  411a8c:	10a00004 	addi	r2,r2,-32768
  411a90:	2085c83a 	sub	r2,r4,r2
  411a94:	10c00804 	addi	r3,r2,32
  411a98:	00a00034 	movhi	r2,32768
  411a9c:	108007c4 	addi	r2,r2,31
  411aa0:	1884703a 	and	r2,r3,r2
  411aa4:	1000040e 	bge	r2,zero,411ab8 <HW_UART_Q_SIZE+0x84>
  411aa8:	10bfffc4 	addi	r2,r2,-1
  411aac:	00fff804 	movi	r3,-32
  411ab0:	10c4b03a 	or	r2,r2,r3
  411ab4:	10800044 	addi	r2,r2,1
}
  411ab8:	e037883a 	mov	sp,fp
  411abc:	df000017 	ldw	fp,0(sp)
  411ac0:	dec00104 	addi	sp,sp,4
  411ac4:	f800283a 	ret

00411ac8 <HW_UART_Q_VAILD>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 HW_UART_Q_VAILD( u8 Ch )
{
  411ac8:	defffd04 	addi	sp,sp,-12
  411acc:	dfc00215 	stw	ra,8(sp)
  411ad0:	df000115 	stw	fp,4(sp)
  411ad4:	df000104 	addi	fp,sp,4
  411ad8:	2005883a 	mov	r2,r4
  411adc:	e0bfff05 	stb	r2,-4(fp)
	return HW_UART_Q_SIZE(Ch);
  411ae0:	e0bfff03 	ldbu	r2,-4(fp)
  411ae4:	1009883a 	mov	r4,r2
  411ae8:	0411a340 	call	411a34 <HW_UART_Q_SIZE>
}
  411aec:	e037883a 	mov	sp,fp
  411af0:	dfc00117 	ldw	ra,4(sp)
  411af4:	df000017 	ldw	fp,0(sp)
  411af8:	dec00204 	addi	sp,sp,8
  411afc:	f800283a 	ret

00411b00 <Hw_Uart_Q_PushReady>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 Hw_Uart_Q_PushReady( u8 Ch )
{
  411b00:	defffe04 	addi	sp,sp,-8
  411b04:	df000115 	stw	fp,4(sp)
  411b08:	df000104 	addi	fp,sp,4
  411b0c:	2005883a 	mov	r2,r4
  411b10:	e0bfff05 	stb	r2,-4(fp)
	if( Hw_Uart_Q_Size[Ch] < HW_UART_Q_BUFFER_MAX )	return TRUE;
  411b14:	e0ffff03 	ldbu	r3,-4(fp)
  411b18:	00801074 	movhi	r2,65
  411b1c:	109fdc04 	addi	r2,r2,32624
  411b20:	18c7883a 	add	r3,r3,r3
  411b24:	10c5883a 	add	r2,r2,r3
  411b28:	1080000b 	ldhu	r2,0(r2)
  411b2c:	10bfffcc 	andi	r2,r2,65535
  411b30:	10a0001c 	xori	r2,r2,32768
  411b34:	10a00004 	addi	r2,r2,-32768
  411b38:	10800808 	cmpgei	r2,r2,32
  411b3c:	1000021e 	bne	r2,zero,411b48 <Hw_Uart_Q_PushReady+0x48>
  411b40:	00800044 	movi	r2,1
  411b44:	00000106 	br	411b4c <Hw_Uart_Q_PushReady+0x4c>
	else                                  			return FALSE;
  411b48:	0005883a 	mov	r2,zero
}
  411b4c:	e037883a 	mov	sp,fp
  411b50:	df000017 	ldw	fp,0(sp)
  411b54:	dec00104 	addi	sp,sp,4
  411b58:	f800283a 	ret

00411b5c <Hw_Uart_Q_Push>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u8 Hw_Uart_Q_Push( u8 Ch, u8  *PushData )
{
  411b5c:	defff904 	addi	sp,sp,-28
  411b60:	dfc00615 	stw	ra,24(sp)
  411b64:	df000515 	stw	fp,20(sp)
  411b68:	dc800415 	stw	r18,16(sp)
  411b6c:	dc400315 	stw	r17,12(sp)
  411b70:	dc000215 	stw	r16,8(sp)
  411b74:	df000504 	addi	fp,sp,20
  411b78:	2005883a 	mov	r2,r4
  411b7c:	e17ffc15 	stw	r5,-16(fp)
  411b80:	e0bffb05 	stb	r2,-20(fp)

	if (HW_UART_Q_SIZE(Ch) == (HW_UART_Q_BUFFER_MAX-1)) return FALSE;
  411b84:	e0bffb03 	ldbu	r2,-20(fp)
  411b88:	1009883a 	mov	r4,r2
  411b8c:	0411a340 	call	411a34 <HW_UART_Q_SIZE>
  411b90:	108007d8 	cmpnei	r2,r2,31
  411b94:	1000021e 	bne	r2,zero,411ba0 <Hw_Uart_Q_Push+0x44>
  411b98:	0005883a 	mov	r2,zero
  411b9c:	00003506 	br	411c74 <Hw_Uart_Q_Push+0x118>

	Hw_Uart_Q_Buffer[Ch][Hw_Uart_Q_Start[Ch]++]  = *PushData;
  411ba0:	e17ffb03 	ldbu	r5,-20(fp)
  411ba4:	e0bffb03 	ldbu	r2,-20(fp)
  411ba8:	00c01074 	movhi	r3,65
  411bac:	18dfe304 	addi	r3,r3,32652
  411bb0:	1089883a 	add	r4,r2,r2
  411bb4:	1907883a 	add	r3,r3,r4
  411bb8:	1900000b 	ldhu	r4,0(r3)
  411bbc:	2007883a 	mov	r3,r4
  411bc0:	18c00044 	addi	r3,r3,1
  411bc4:	180d883a 	mov	r6,r3
  411bc8:	00c01074 	movhi	r3,65
  411bcc:	18dfe304 	addi	r3,r3,32652
  411bd0:	1085883a 	add	r2,r2,r2
  411bd4:	1885883a 	add	r2,r3,r2
  411bd8:	1180000d 	sth	r6,0(r2)
  411bdc:	24bfffcc 	andi	r18,r4,65535
  411be0:	94a0001c 	xori	r18,r18,32768
  411be4:	94a00004 	addi	r18,r18,-32768
  411be8:	e0bffc17 	ldw	r2,-16(fp)
  411bec:	14400003 	ldbu	r17,0(r2)
  411bf0:	04001074 	movhi	r16,65
  411bf4:	841fa204 	addi	r16,r16,32392
  411bf8:	2809883a 	mov	r4,r5
  411bfc:	01400844 	movi	r5,33
  411c00:	04123e00 	call	4123e0 <__mulsi3>
  411c04:	1485883a 	add	r2,r2,r18
  411c08:	8085883a 	add	r2,r16,r2
  411c0c:	14400005 	stb	r17,0(r2)
	Hw_Uart_Q_Start[Ch] 						%= HW_UART_Q_BUFFER_MAX;
  411c10:	e0fffb03 	ldbu	r3,-20(fp)
  411c14:	e13ffb03 	ldbu	r4,-20(fp)
  411c18:	00801074 	movhi	r2,65
  411c1c:	109fe304 	addi	r2,r2,32652
  411c20:	2109883a 	add	r4,r4,r4
  411c24:	1105883a 	add	r2,r2,r4
  411c28:	1080000b 	ldhu	r2,0(r2)
  411c2c:	113fffcc 	andi	r4,r2,65535
  411c30:	2120001c 	xori	r4,r4,32768
  411c34:	21200004 	addi	r4,r4,-32768
  411c38:	00a00034 	movhi	r2,32768
  411c3c:	108007c4 	addi	r2,r2,31
  411c40:	2084703a 	and	r2,r4,r2
  411c44:	1000040e 	bge	r2,zero,411c58 <Hw_Uart_Q_Push+0xfc>
  411c48:	10bfffc4 	addi	r2,r2,-1
  411c4c:	013ff804 	movi	r4,-32
  411c50:	1104b03a 	or	r2,r2,r4
  411c54:	10800044 	addi	r2,r2,1
  411c58:	1009883a 	mov	r4,r2
  411c5c:	00801074 	movhi	r2,65
  411c60:	109fe304 	addi	r2,r2,32652
  411c64:	18c7883a 	add	r3,r3,r3
  411c68:	10c5883a 	add	r2,r2,r3
  411c6c:	1100000d 	sth	r4,0(r2)

	return TRUE;
  411c70:	00800044 	movi	r2,1
}
  411c74:	e6fffd04 	addi	sp,fp,-12
  411c78:	dfc00417 	ldw	ra,16(sp)
  411c7c:	df000317 	ldw	fp,12(sp)
  411c80:	dc800217 	ldw	r18,8(sp)
  411c84:	dc400117 	ldw	r17,4(sp)
  411c88:	dc000017 	ldw	r16,0(sp)
  411c8c:	dec00504 	addi	sp,sp,20
  411c90:	f800283a 	ret

00411c94 <Hw_Uart_Q_Pop>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u8 Hw_Uart_Q_Pop( u8 Ch, u8 *pData )
{
  411c94:	defffa04 	addi	sp,sp,-24
  411c98:	dfc00515 	stw	ra,20(sp)
  411c9c:	df000415 	stw	fp,16(sp)
  411ca0:	dc400315 	stw	r17,12(sp)
  411ca4:	dc000215 	stw	r16,8(sp)
  411ca8:	df000404 	addi	fp,sp,16
  411cac:	2005883a 	mov	r2,r4
  411cb0:	e17ffd15 	stw	r5,-12(fp)
  411cb4:	e0bffc05 	stb	r2,-16(fp)
	if (HW_UART_Q_SIZE(Ch) == 0) return FALSE;
  411cb8:	e0bffc03 	ldbu	r2,-16(fp)
  411cbc:	1009883a 	mov	r4,r2
  411cc0:	0411a340 	call	411a34 <HW_UART_Q_SIZE>
  411cc4:	1000021e 	bne	r2,zero,411cd0 <Hw_Uart_Q_Pop+0x3c>
  411cc8:	0005883a 	mov	r2,zero
  411ccc:	00003506 	br	411da4 <Hw_Uart_Q_Pop+0x110>

	*pData = Hw_Uart_Q_Buffer[Ch][Hw_Uart_Q_End[Ch]++];
  411cd0:	e17ffc03 	ldbu	r5,-16(fp)
  411cd4:	e0bffc03 	ldbu	r2,-16(fp)
  411cd8:	00c01074 	movhi	r3,65
  411cdc:	18dfdf84 	addi	r3,r3,32638
  411ce0:	1089883a 	add	r4,r2,r2
  411ce4:	1907883a 	add	r3,r3,r4
  411ce8:	1900000b 	ldhu	r4,0(r3)
  411cec:	2007883a 	mov	r3,r4
  411cf0:	18c00044 	addi	r3,r3,1
  411cf4:	180d883a 	mov	r6,r3
  411cf8:	00c01074 	movhi	r3,65
  411cfc:	18dfdf84 	addi	r3,r3,32638
  411d00:	1085883a 	add	r2,r2,r2
  411d04:	1885883a 	add	r2,r3,r2
  411d08:	1180000d 	sth	r6,0(r2)
  411d0c:	247fffcc 	andi	r17,r4,65535
  411d10:	8c60001c 	xori	r17,r17,32768
  411d14:	8c600004 	addi	r17,r17,-32768
  411d18:	04001074 	movhi	r16,65
  411d1c:	841fa204 	addi	r16,r16,32392
  411d20:	2809883a 	mov	r4,r5
  411d24:	01400844 	movi	r5,33
  411d28:	04123e00 	call	4123e0 <__mulsi3>
  411d2c:	1445883a 	add	r2,r2,r17
  411d30:	8085883a 	add	r2,r16,r2
  411d34:	10c00003 	ldbu	r3,0(r2)
  411d38:	e0bffd17 	ldw	r2,-12(fp)
  411d3c:	10c00005 	stb	r3,0(r2)

	Hw_Uart_Q_End[Ch] %= HW_UART_Q_BUFFER_MAX;
  411d40:	e0fffc03 	ldbu	r3,-16(fp)
  411d44:	e13ffc03 	ldbu	r4,-16(fp)
  411d48:	00801074 	movhi	r2,65
  411d4c:	109fdf84 	addi	r2,r2,32638
  411d50:	2109883a 	add	r4,r4,r4
  411d54:	1105883a 	add	r2,r2,r4
  411d58:	1080000b 	ldhu	r2,0(r2)
  411d5c:	113fffcc 	andi	r4,r2,65535
  411d60:	2120001c 	xori	r4,r4,32768
  411d64:	21200004 	addi	r4,r4,-32768
  411d68:	00a00034 	movhi	r2,32768
  411d6c:	108007c4 	addi	r2,r2,31
  411d70:	2084703a 	and	r2,r4,r2
  411d74:	1000040e 	bge	r2,zero,411d88 <Hw_Uart_Q_Pop+0xf4>
  411d78:	10bfffc4 	addi	r2,r2,-1
  411d7c:	013ff804 	movi	r4,-32
  411d80:	1104b03a 	or	r2,r2,r4
  411d84:	10800044 	addi	r2,r2,1
  411d88:	1009883a 	mov	r4,r2
  411d8c:	00801074 	movhi	r2,65
  411d90:	109fdf84 	addi	r2,r2,32638
  411d94:	18c7883a 	add	r3,r3,r3
  411d98:	10c5883a 	add	r2,r2,r3
  411d9c:	1100000d 	sth	r4,0(r2)

    return TRUE;
  411da0:	00800044 	movi	r2,1
}
  411da4:	e6fffe04 	addi	sp,fp,-8
  411da8:	dfc00317 	ldw	ra,12(sp)
  411dac:	df000217 	ldw	fp,8(sp)
  411db0:	dc400117 	ldw	r17,4(sp)
  411db4:	dc000017 	ldw	r16,0(sp)
  411db8:	dec00404 	addi	sp,sp,16
  411dbc:	f800283a 	ret

00411dc0 <Hw_Led_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_Init( void )
{
  411dc0:	defffe04 	addi	sp,sp,-8
  411dc4:	dfc00115 	stw	ra,4(sp)
  411dc8:	df000015 	stw	fp,0(sp)
  411dcc:	d839883a 	mov	fp,sp

	//-- 방향 출력으로 설정
	//


	Hw_Led_Off(0);
  411dd0:	0009883a 	mov	r4,zero
  411dd4:	0411e540 	call	411e54 <Hw_Led_Off>
	Hw_Led_Off(1);	
  411dd8:	01000044 	movi	r4,1
  411ddc:	0411e540 	call	411e54 <Hw_Led_Off>
}
  411de0:	e037883a 	mov	sp,fp
  411de4:	dfc00117 	ldw	ra,4(sp)
  411de8:	df000017 	ldw	fp,0(sp)
  411dec:	dec00204 	addi	sp,sp,8
  411df0:	f800283a 	ret

00411df4 <Hw_Led_On>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_On( u8 Ch )
{	
  411df4:	defffd04 	addi	sp,sp,-12
  411df8:	df000215 	stw	fp,8(sp)
  411dfc:	df000204 	addi	fp,sp,8
  411e00:	2005883a 	mov	r2,r4
  411e04:	e0bfff05 	stb	r2,-4(fp)
	u32 Data;


	Data = IORD_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE);
  411e08:	008010b4 	movhi	r2,66
  411e0c:	10864804 	addi	r2,r2,6432
  411e10:	10800037 	ldwio	r2,0(r2)
  411e14:	e0bffe15 	stw	r2,-8(fp)
	SET_BIT(Data, Ch);
  411e18:	e0bfff03 	ldbu	r2,-4(fp)
  411e1c:	00c00044 	movi	r3,1
  411e20:	1884983a 	sll	r2,r3,r2
  411e24:	1007883a 	mov	r3,r2
  411e28:	e0bffe17 	ldw	r2,-8(fp)
  411e2c:	10c4b03a 	or	r2,r2,r3
  411e30:	e0bffe15 	stw	r2,-8(fp)
	IOWR_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE, Data);
  411e34:	e0fffe17 	ldw	r3,-8(fp)
  411e38:	008010b4 	movhi	r2,66
  411e3c:	10864804 	addi	r2,r2,6432
  411e40:	10c00035 	stwio	r3,0(r2)
}
  411e44:	e037883a 	mov	sp,fp
  411e48:	df000017 	ldw	fp,0(sp)
  411e4c:	dec00104 	addi	sp,sp,4
  411e50:	f800283a 	ret

00411e54 <Hw_Led_Off>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_Off( u8 Ch )
{
  411e54:	defffd04 	addi	sp,sp,-12
  411e58:	df000215 	stw	fp,8(sp)
  411e5c:	df000204 	addi	fp,sp,8
  411e60:	2005883a 	mov	r2,r4
  411e64:	e0bfff05 	stb	r2,-4(fp)
	u32 Data;

	Data = IORD_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE);
  411e68:	008010b4 	movhi	r2,66
  411e6c:	10864804 	addi	r2,r2,6432
  411e70:	10800037 	ldwio	r2,0(r2)
  411e74:	e0bffe15 	stw	r2,-8(fp)
	CLR_BIT(Data, Ch);
  411e78:	e0bfff03 	ldbu	r2,-4(fp)
  411e7c:	00c00044 	movi	r3,1
  411e80:	1884983a 	sll	r2,r3,r2
  411e84:	0084303a 	nor	r2,zero,r2
  411e88:	1007883a 	mov	r3,r2
  411e8c:	e0bffe17 	ldw	r2,-8(fp)
  411e90:	10c4703a 	and	r2,r2,r3
  411e94:	e0bffe15 	stw	r2,-8(fp)
	IOWR_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE, Data);
  411e98:	e0fffe17 	ldw	r3,-8(fp)
  411e9c:	008010b4 	movhi	r2,66
  411ea0:	10864804 	addi	r2,r2,6432
  411ea4:	10c00035 	stwio	r3,0(r2)
}
  411ea8:	e037883a 	mov	sp,fp
  411eac:	df000017 	ldw	fp,0(sp)
  411eb0:	dec00104 	addi	sp,sp,4
  411eb4:	f800283a 	ret

00411eb8 <Hw_Led_Toggle>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_Toggle( u8 Ch )
{
  411eb8:	defffd04 	addi	sp,sp,-12
  411ebc:	df000215 	stw	fp,8(sp)
  411ec0:	df000204 	addi	fp,sp,8
  411ec4:	2005883a 	mov	r2,r4
  411ec8:	e0bfff05 	stb	r2,-4(fp)
	u32 Data;


	Data = IORD_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE);
  411ecc:	008010b4 	movhi	r2,66
  411ed0:	10864804 	addi	r2,r2,6432
  411ed4:	10800037 	ldwio	r2,0(r2)
  411ed8:	e0bffe15 	stw	r2,-8(fp)
	TGL_BIT(Data, Ch);
  411edc:	e0bfff03 	ldbu	r2,-4(fp)
  411ee0:	00c00044 	movi	r3,1
  411ee4:	1884983a 	sll	r2,r3,r2
  411ee8:	1007883a 	mov	r3,r2
  411eec:	e0bffe17 	ldw	r2,-8(fp)
  411ef0:	10c4f03a 	xor	r2,r2,r3
  411ef4:	e0bffe15 	stw	r2,-8(fp)
	IOWR_ALTERA_AVALON_PIO_DATA(LED_ADDR_BASE, Data);
  411ef8:	e0fffe17 	ldw	r3,-8(fp)
  411efc:	008010b4 	movhi	r2,66
  411f00:	10864804 	addi	r2,r2,6432
  411f04:	10c00035 	stwio	r3,0(r2)
}
  411f08:	e037883a 	mov	sp,fp
  411f0c:	df000017 	ldw	fp,0(sp)
  411f10:	dec00104 	addi	sp,sp,4
  411f14:	f800283a 	ret

00411f18 <Hw_Led_Wait>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Led_Wait( u32 delay )
{
  411f18:	defffd04 	addi	sp,sp,-12
  411f1c:	df000215 	stw	fp,8(sp)
  411f20:	df000204 	addi	fp,sp,8
  411f24:	e13fff15 	stw	r4,-4(fp)
    volatile u32 i;
    for ( i = 0 ; i < delay ; i++ ){ };
  411f28:	e03ffe15 	stw	zero,-8(fp)
  411f2c:	00000306 	br	411f3c <Hw_Led_Wait+0x24>
  411f30:	e0bffe17 	ldw	r2,-8(fp)
  411f34:	10800044 	addi	r2,r2,1
  411f38:	e0bffe15 	stw	r2,-8(fp)
  411f3c:	e0fffe17 	ldw	r3,-8(fp)
  411f40:	e0bfff17 	ldw	r2,-4(fp)
  411f44:	18bffa36 	bltu	r3,r2,411f30 <_gp+0xffff2734>
}
  411f48:	e037883a 	mov	sp,fp
  411f4c:	df000017 	ldw	fp,0(sp)
  411f50:	dec00104 	addi	sp,sp,4
  411f54:	f800283a 	ret

00411f58 <Hw_Init>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Init( void )
{
  411f58:	defffe04 	addi	sp,sp,-8
  411f5c:	dfc00115 	stw	ra,4(sp)
  411f60:	df000015 	stw	fp,0(sp)
  411f64:	d839883a 	mov	fp,sp
	Hw_ISR_Init();
  411f68:	0410bd00 	call	410bd0 <Hw_ISR_Init>
	Hw_Led_Init();
  411f6c:	0411dc00 	call	411dc0 <Hw_Led_Init>
	Hw_Uart_Init();
  411f70:	04114bc0 	call	4114bc <Hw_Uart_Init>
	Hw_Pwm_Init();
  411f74:	0410bf00 	call	410bf0 <Hw_Pwm_Init>
	Hw_DcMotor_Init();
  411f78:	04108140 	call	410814 <Hw_DcMotor_Init>

	Enable_ISR();
}
  411f7c:	e037883a 	mov	sp,fp
  411f80:	dfc00117 	ldw	ra,4(sp)
  411f84:	df000017 	ldw	fp,0(sp)
  411f88:	dec00204 	addi	sp,sp,8
  411f8c:	f800283a 	ret

00411f90 <Hw_Wait>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Wait( u32 delay )
{
  411f90:	defffd04 	addi	sp,sp,-12
  411f94:	df000215 	stw	fp,8(sp)
  411f98:	df000204 	addi	fp,sp,8
  411f9c:	e13fff15 	stw	r4,-4(fp)
    volatile u32 i;
    for ( i = 0 ; i < delay ; i++ ){ };
  411fa0:	e03ffe15 	stw	zero,-8(fp)
  411fa4:	00000306 	br	411fb4 <Hw_Wait+0x24>
  411fa8:	e0bffe17 	ldw	r2,-8(fp)
  411fac:	10800044 	addi	r2,r2,1
  411fb0:	e0bffe15 	stw	r2,-8(fp)
  411fb4:	e0fffe17 	ldw	r3,-8(fp)
  411fb8:	e0bfff17 	ldw	r2,-4(fp)
  411fbc:	18bffa36 	bltu	r3,r2,411fa8 <_gp+0xffff27ac>
}
  411fc0:	e037883a 	mov	sp,fp
  411fc4:	df000017 	ldw	fp,0(sp)
  411fc8:	dec00104 	addi	sp,sp,4
  411fcc:	f800283a 	ret

00411fd0 <Hw_Wait_Usec>:
     WORK    : 
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Hw_Wait_Usec( u32 usec )
{
  411fd0:	defffd04 	addi	sp,sp,-12
  411fd4:	dfc00215 	stw	ra,8(sp)
  411fd8:	df000115 	stw	fp,4(sp)
  411fdc:	df000104 	addi	fp,sp,4
  411fe0:	e13fff15 	stw	r4,-4(fp)
    Hw_Wait( usec * 83 );
  411fe4:	e13fff17 	ldw	r4,-4(fp)
  411fe8:	014014c4 	movi	r5,83
  411fec:	04123e00 	call	4123e0 <__mulsi3>
  411ff0:	1009883a 	mov	r4,r2
  411ff4:	0411f900 	call	411f90 <Hw_Wait>
}
  411ff8:	e037883a 	mov	sp,fp
  411ffc:	dfc00117 	ldw	ra,4(sp)
  412000:	df000017 	ldw	fp,0(sp)
  412004:	dec00204 	addi	sp,sp,8
  412008:	f800283a 	ret

0041200c <millis>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 millis( void )
{
  41200c:	defffe04 	addi	sp,sp,-8
  412010:	dfc00115 	stw	ra,4(sp)
  412014:	df000015 	stw	fp,0(sp)
  412018:	d839883a 	mov	fp,sp
	return alt_timestamp()/1000;
  41201c:	0414fc00 	call	414fc0 <alt_timestamp>
  412020:	1009883a 	mov	r4,r2
  412024:	0140fa04 	movi	r5,1000
  412028:	04123d00 	call	4123d0 <__udivsi3>
}
  41202c:	e037883a 	mov	sp,fp
  412030:	dfc00117 	ldw	ra,4(sp)
  412034:	df000017 	ldw	fp,0(sp)
  412038:	dec00204 	addi	sp,sp,8
  41203c:	f800283a 	ret

00412040 <micros>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
u32 micros( void )
{
  412040:	defffe04 	addi	sp,sp,-8
  412044:	dfc00115 	stw	ra,4(sp)
  412048:	df000015 	stw	fp,0(sp)
  41204c:	d839883a 	mov	fp,sp
	return alt_timestamp();
  412050:	0414fc00 	call	414fc0 <alt_timestamp>
}
  412054:	e037883a 	mov	sp,fp
  412058:	dfc00117 	ldw	ra,4(sp)
  41205c:	df000017 	ldw	fp,0(sp)
  412060:	dec00204 	addi	sp,sp,8
  412064:	f800283a 	ret

00412068 <delay>:




void delay(volatile unsigned int timeCount)
{
  412068:	defffe04 	addi	sp,sp,-8
  41206c:	df000115 	stw	fp,4(sp)
  412070:	df000104 	addi	fp,sp,4
  412074:	e13fff15 	stw	r4,-4(fp)
    while(timeCount --);
  412078:	0001883a 	nop
  41207c:	e0bfff17 	ldw	r2,-4(fp)
  412080:	10ffffc4 	addi	r3,r2,-1
  412084:	e0ffff15 	stw	r3,-4(fp)
  412088:	103ffc1e 	bne	r2,zero,41207c <_gp+0xffff2880>
}
  41208c:	e037883a 	mov	sp,fp
  412090:	df000017 	ldw	fp,0(sp)
  412094:	dec00104 	addi	sp,sp,4
  412098:	f800283a 	ret

0041209c <delay_second>:

void delay_second(void)
{
  41209c:	defffe04 	addi	sp,sp,-8
  4120a0:	dfc00115 	stw	ra,4(sp)
  4120a4:	df000015 	stw	fp,0(sp)
  4120a8:	d839883a 	mov	fp,sp
    delay(806596);
  4120ac:	01000334 	movhi	r4,12
  4120b0:	2113b104 	addi	r4,r4,20164
  4120b4:	04120680 	call	412068 <delay>
}
  4120b8:	e037883a 	mov	sp,fp
  4120bc:	dfc00117 	ldw	ra,4(sp)
  4120c0:	df000017 	ldw	fp,0(sp)
  4120c4:	dec00204 	addi	sp,sp,8
  4120c8:	f800283a 	ret

004120cc <Uart1_ISR>:




void Uart1_ISR(char Ch)
{
  4120cc:	defffd04 	addi	sp,sp,-12
  4120d0:	dfc00215 	stw	ra,8(sp)
  4120d4:	df000115 	stw	fp,4(sp)
  4120d8:	df000104 	addi	fp,sp,4
  4120dc:	2005883a 	mov	r2,r4
  4120e0:	e0bfff05 	stb	r2,-4(fp)
	//Lb_printf("Received : %c\n", Ch);
	Hw_Led_Toggle(7);
  4120e4:	010001c4 	movi	r4,7
  4120e8:	0411eb80 	call	411eb8 <Hw_Led_Toggle>
}
  4120ec:	e037883a 	mov	sp,fp
  4120f0:	dfc00117 	ldw	ra,4(sp)
  4120f4:	df000017 	ldw	fp,0(sp)
  4120f8:	dec00204 	addi	sp,sp,8
  4120fc:	f800283a 	ret

00412100 <main>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
int main(void)
{
  412100:	defff104 	addi	sp,sp,-60
  412104:	dfc00e15 	stw	ra,56(sp)
  412108:	df000d15 	stw	fp,52(sp)
  41210c:	df000d04 	addi	fp,sp,52
	s16 M_Speed_L;
	s16 M_Speed_R;
	f32 M_Handle;


	Main_Init();
  412110:	04122880 	call	412288 <Main_Init>


	//Lb_printf( "Start\n" );

	i = 0;
  412114:	e03ff315 	stw	zero,-52(fp)

	while (1)
	{
		if( (millis()-tTimer[0]) >= 500 )
  412118:	041200c0 	call	41200c <millis>
  41211c:	1007883a 	mov	r3,r2
  412120:	e0bff817 	ldw	r2,-32(fp)
  412124:	1885c83a 	sub	r2,r3,r2
  412128:	10807d30 	cmpltui	r2,r2,500
  41212c:	1000041e 	bne	r2,zero,412140 <main+0x40>
		{
			tTimer[0] = millis();
  412130:	041200c0 	call	41200c <millis>
  412134:	e0bff815 	stw	r2,-32(fp)
			Hw_Led_Toggle(0);
  412138:	0009883a 	mov	r4,zero
  41213c:	0411eb80 	call	411eb8 <Hw_Led_Toggle>
		}

		if( (millis()-tTimer[1]) >= 500 )
  412140:	041200c0 	call	41200c <millis>
  412144:	1007883a 	mov	r3,r2
  412148:	e0bff917 	ldw	r2,-28(fp)
  41214c:	1885c83a 	sub	r2,r3,r2
  412150:	10807d30 	cmpltui	r2,r2,500
  412154:	1000021e 	bne	r2,zero,412160 <main+0x60>
		{
			tTimer[1] = millis();
  412158:	041200c0 	call	41200c <millis>
  41215c:	e0bff915 	stw	r2,-28(fp)
		}


		if( MSP_GetReceived() == TRUE )
  412160:	041032c0 	call	41032c <MSP_GetReceived>
  412164:	10803fcc 	andi	r2,r2,255
  412168:	10800058 	cmpnei	r2,r2,1
  41216c:	10003a1e 	bne	r2,zero,412258 <main+0x158>
		{
			tTimer[2] = millis();
  412170:	041200c0 	call	41200c <millis>
  412174:	e0bffa15 	stw	r2,-24(fp)
					MSP_Get_CmdRcPtr()->Roll,
					MSP_Get_CmdRcPtr()->Pitch,
					MSP_Get_CmdRcPtr()->Yaw,
					MSP_Get_CmdRcPtr()->Throthle);
			*/
			M_Speed  = MSP_Get_CmdRcPtr()->Pitch*100/500;
  412178:	04106100 	call	410610 <MSP_Get_CmdRcPtr>
  41217c:	1080008b 	ldhu	r2,2(r2)
  412180:	10bfffcc 	andi	r2,r2,65535
  412184:	10a0001c 	xori	r2,r2,32768
  412188:	10a00004 	addi	r2,r2,-32768
  41218c:	1009883a 	mov	r4,r2
  412190:	01401904 	movi	r5,100
  412194:	04123e00 	call	4123e0 <__mulsi3>
  412198:	1009883a 	mov	r4,r2
  41219c:	01407d04 	movi	r5,500
  4121a0:	04123200 	call	412320 <__divsi3>
  4121a4:	e0bff40d 	sth	r2,-48(fp)
			M_Handle = MSP_Get_CmdRcPtr()->Roll;
  4121a8:	04106100 	call	410610 <MSP_Get_CmdRcPtr>
  4121ac:	1080000b 	ldhu	r2,0(r2)
  4121b0:	10bfffcc 	andi	r2,r2,65535
  4121b4:	10a0001c 	xori	r2,r2,32768
  4121b8:	10a00004 	addi	r2,r2,-32768
  4121bc:	1009883a 	mov	r4,r2
  4121c0:	04132ac0 	call	4132ac <__floatsisf>
  4121c4:	1007883a 	mov	r3,r2
  4121c8:	e0fff515 	stw	r3,-44(fp)
			M_Handle = M_Handle/5;
  4121cc:	e13ff517 	ldw	r4,-44(fp)
  4121d0:	01502834 	movhi	r5,16544
  4121d4:	04128e80 	call	4128e8 <__divsf3>
  4121d8:	1007883a 	mov	r3,r2
  4121dc:	e0fff515 	stw	r3,-44(fp)

			M_Speed_L = M_Speed - M_Handle;
  4121e0:	e0bff40f 	ldh	r2,-48(fp)
  4121e4:	1009883a 	mov	r4,r2
  4121e8:	04132ac0 	call	4132ac <__floatsisf>
  4121ec:	1007883a 	mov	r3,r2
  4121f0:	1809883a 	mov	r4,r3
  4121f4:	e17ff517 	ldw	r5,-44(fp)
  4121f8:	0412d380 	call	412d38 <__subsf3>
  4121fc:	1007883a 	mov	r3,r2
  412200:	1805883a 	mov	r2,r3
  412204:	1009883a 	mov	r4,r2
  412208:	04132340 	call	413234 <__fixsfsi>
  41220c:	e0bff60d 	sth	r2,-40(fp)
			M_Speed_R = M_Speed + M_Handle;
  412210:	e0bff40f 	ldh	r2,-48(fp)
  412214:	1009883a 	mov	r4,r2
  412218:	04132ac0 	call	4132ac <__floatsisf>
  41221c:	1007883a 	mov	r3,r2
  412220:	1809883a 	mov	r4,r3
  412224:	e17ff517 	ldw	r5,-44(fp)
  412228:	04124080 	call	412408 <__addsf3>
  41222c:	1007883a 	mov	r3,r2
  412230:	1805883a 	mov	r2,r3
  412234:	1009883a 	mov	r4,r2
  412238:	04132340 	call	413234 <__fixsfsi>
  41223c:	e0bff68d 	sth	r2,-38(fp)


			Hw_DcMotor_Handle( M_Speed_L, M_Speed_R );
  412240:	e0fff60f 	ldh	r3,-40(fp)
  412244:	e0bff68f 	ldh	r2,-38(fp)
  412248:	1809883a 	mov	r4,r3
  41224c:	100b883a 	mov	r5,r2
  412250:	0410a540 	call	410a54 <Hw_DcMotor_Handle>
  412254:	00000b06 	br	412284 <main+0x184>
		}
		else
		{
			if( (millis()-tTimer[2]) >= 1000 )
  412258:	041200c0 	call	41200c <millis>
  41225c:	1007883a 	mov	r3,r2
  412260:	e0bffa17 	ldw	r2,-24(fp)
  412264:	1885c83a 	sub	r2,r3,r2
  412268:	1080fa30 	cmpltui	r2,r2,1000
  41226c:	1000051e 	bne	r2,zero,412284 <main+0x184>
			{
				Hw_DcMotor_Handle( 0, 0 );
  412270:	0009883a 	mov	r4,zero
  412274:	000b883a 	mov	r5,zero
  412278:	0410a540 	call	410a54 <Hw_DcMotor_Handle>
				tTimer[2] = millis();
  41227c:	041200c0 	call	41200c <millis>
  412280:	e0bffa15 	stw	r2,-24(fp)
			}
		}
	}
  412284:	003fa406 	br	412118 <_gp+0xffff291c>

00412288 <Main_Init>:
     WORK    :
     ARG     : void
     RET     : void
---------------------------------------------------------------------------*/
void Main_Init( void )
{
  412288:	defffe04 	addi	sp,sp,-8
  41228c:	dfc00115 	stw	ra,4(sp)
  412290:	df000015 	stw	fp,0(sp)
  412294:	d839883a 	mov	fp,sp
	Hw_Init();
  412298:	0411f580 	call	411f58 <Hw_Init>
	Ap_Init();
  41229c:	04102680 	call	410268 <Ap_Init>
}
  4122a0:	e037883a 	mov	sp,fp
  4122a4:	dfc00117 	ldw	ra,4(sp)
  4122a8:	df000017 	ldw	fp,0(sp)
  4122ac:	dec00204 	addi	sp,sp,8
  4122b0:	f800283a 	ret

004122b4 <udivmodsi4>:
  4122b4:	2900182e 	bgeu	r5,r4,412318 <udivmodsi4+0x64>
  4122b8:	28001716 	blt	r5,zero,412318 <udivmodsi4+0x64>
  4122bc:	00800804 	movi	r2,32
  4122c0:	00c00044 	movi	r3,1
  4122c4:	00000206 	br	4122d0 <udivmodsi4+0x1c>
  4122c8:	10001126 	beq	r2,zero,412310 <udivmodsi4+0x5c>
  4122cc:	28000516 	blt	r5,zero,4122e4 <udivmodsi4+0x30>
  4122d0:	294b883a 	add	r5,r5,r5
  4122d4:	10bfffc4 	addi	r2,r2,-1
  4122d8:	18c7883a 	add	r3,r3,r3
  4122dc:	293ffa36 	bltu	r5,r4,4122c8 <_gp+0xffff2acc>
  4122e0:	18000b26 	beq	r3,zero,412310 <udivmodsi4+0x5c>
  4122e4:	0005883a 	mov	r2,zero
  4122e8:	21400236 	bltu	r4,r5,4122f4 <udivmodsi4+0x40>
  4122ec:	2149c83a 	sub	r4,r4,r5
  4122f0:	10c4b03a 	or	r2,r2,r3
  4122f4:	1806d07a 	srli	r3,r3,1
  4122f8:	280ad07a 	srli	r5,r5,1
  4122fc:	183ffa1e 	bne	r3,zero,4122e8 <_gp+0xffff2aec>
  412300:	3000011e 	bne	r6,zero,412308 <udivmodsi4+0x54>
  412304:	f800283a 	ret
  412308:	2005883a 	mov	r2,r4
  41230c:	f800283a 	ret
  412310:	0005883a 	mov	r2,zero
  412314:	003ffa06 	br	412300 <_gp+0xffff2b04>
  412318:	00c00044 	movi	r3,1
  41231c:	003ff106 	br	4122e4 <_gp+0xffff2ae8>

00412320 <__divsi3>:
  412320:	defffe04 	addi	sp,sp,-8
  412324:	dfc00115 	stw	ra,4(sp)
  412328:	dc000015 	stw	r16,0(sp)
  41232c:	20000b16 	blt	r4,zero,41235c <__divsi3+0x3c>
  412330:	0021883a 	mov	r16,zero
  412334:	28000c16 	blt	r5,zero,412368 <__divsi3+0x48>
  412338:	000d883a 	mov	r6,zero
  41233c:	04122b40 	call	4122b4 <udivmodsi4>
  412340:	0407c83a 	sub	r3,zero,r16
  412344:	1884f03a 	xor	r2,r3,r2
  412348:	1405883a 	add	r2,r2,r16
  41234c:	dfc00117 	ldw	ra,4(sp)
  412350:	dc000017 	ldw	r16,0(sp)
  412354:	dec00204 	addi	sp,sp,8
  412358:	f800283a 	ret
  41235c:	0109c83a 	sub	r4,zero,r4
  412360:	04000044 	movi	r16,1
  412364:	283ff40e 	bge	r5,zero,412338 <_gp+0xffff2b3c>
  412368:	014bc83a 	sub	r5,zero,r5
  41236c:	8400005c 	xori	r16,r16,1
  412370:	003ff106 	br	412338 <_gp+0xffff2b3c>

00412374 <__modsi3>:
  412374:	defffd04 	addi	sp,sp,-12
  412378:	dfc00215 	stw	ra,8(sp)
  41237c:	dc400115 	stw	r17,4(sp)
  412380:	dc000015 	stw	r16,0(sp)
  412384:	20000c16 	blt	r4,zero,4123b8 <__modsi3+0x44>
  412388:	0023883a 	mov	r17,zero
  41238c:	0021883a 	mov	r16,zero
  412390:	28000d16 	blt	r5,zero,4123c8 <__modsi3+0x54>
  412394:	01800044 	movi	r6,1
  412398:	04122b40 	call	4122b4 <udivmodsi4>
  41239c:	1404f03a 	xor	r2,r2,r16
  4123a0:	8885883a 	add	r2,r17,r2
  4123a4:	dfc00217 	ldw	ra,8(sp)
  4123a8:	dc400117 	ldw	r17,4(sp)
  4123ac:	dc000017 	ldw	r16,0(sp)
  4123b0:	dec00304 	addi	sp,sp,12
  4123b4:	f800283a 	ret
  4123b8:	0109c83a 	sub	r4,zero,r4
  4123bc:	04400044 	movi	r17,1
  4123c0:	043fffc4 	movi	r16,-1
  4123c4:	283ff30e 	bge	r5,zero,412394 <_gp+0xffff2b98>
  4123c8:	014bc83a 	sub	r5,zero,r5
  4123cc:	003ff106 	br	412394 <_gp+0xffff2b98>

004123d0 <__udivsi3>:
  4123d0:	000d883a 	mov	r6,zero
  4123d4:	04122b41 	jmpi	4122b4 <udivmodsi4>

004123d8 <__umodsi3>:
  4123d8:	01800044 	movi	r6,1
  4123dc:	04122b41 	jmpi	4122b4 <udivmodsi4>

004123e0 <__mulsi3>:
  4123e0:	0005883a 	mov	r2,zero
  4123e4:	20000726 	beq	r4,zero,412404 <__mulsi3+0x24>
  4123e8:	20c0004c 	andi	r3,r4,1
  4123ec:	2008d07a 	srli	r4,r4,1
  4123f0:	18000126 	beq	r3,zero,4123f8 <__mulsi3+0x18>
  4123f4:	1145883a 	add	r2,r2,r5
  4123f8:	294b883a 	add	r5,r5,r5
  4123fc:	203ffa1e 	bne	r4,zero,4123e8 <_gp+0xffff2bec>
  412400:	f800283a 	ret
  412404:	f800283a 	ret

00412408 <__addsf3>:
  412408:	defffc04 	addi	sp,sp,-16
  41240c:	2004d7fa 	srli	r2,r4,31
  412410:	280ed5fa 	srli	r7,r5,23
  412414:	dc000015 	stw	r16,0(sp)
  412418:	01802034 	movhi	r6,128
  41241c:	2020d5fa 	srli	r16,r4,23
  412420:	31bfffc4 	addi	r6,r6,-1
  412424:	2810d7fa 	srli	r8,r5,31
  412428:	3108703a 	and	r4,r6,r4
  41242c:	dc800215 	stw	r18,8(sp)
  412430:	314c703a 	and	r6,r6,r5
  412434:	84003fcc 	andi	r16,r16,255
  412438:	200690fa 	slli	r3,r4,3
  41243c:	dfc00315 	stw	ra,12(sp)
  412440:	39003fcc 	andi	r4,r7,255
  412444:	dc400115 	stw	r17,4(sp)
  412448:	14803fcc 	andi	r18,r2,255
  41244c:	300c90fa 	slli	r6,r6,3
  412450:	810bc83a 	sub	r5,r16,r4
  412454:	92004826 	beq	r18,r8,412578 <__addsf3+0x170>
  412458:	01406c0e 	bge	zero,r5,41260c <__addsf3+0x204>
  41245c:	20001e1e 	bne	r4,zero,4124d8 <__addsf3+0xd0>
  412460:	3000611e 	bne	r6,zero,4125e8 <__addsf3+0x1e0>
  412464:	188001cc 	andi	r2,r3,7
  412468:	10000426 	beq	r2,zero,41247c <__addsf3+0x74>
  41246c:	190003cc 	andi	r4,r3,15
  412470:	00800104 	movi	r2,4
  412474:	20800126 	beq	r4,r2,41247c <__addsf3+0x74>
  412478:	18c00104 	addi	r3,r3,4
  41247c:	1901002c 	andhi	r4,r3,1024
  412480:	9005883a 	mov	r2,r18
  412484:	20003426 	beq	r4,zero,412558 <__addsf3+0x150>
  412488:	81400044 	addi	r5,r16,1
  41248c:	01003fc4 	movi	r4,255
  412490:	29006926 	beq	r5,r4,412638 <__addsf3+0x230>
  412494:	180691ba 	slli	r3,r3,6
  412498:	1808d27a 	srli	r4,r3,9
  41249c:	29403fcc 	andi	r5,r5,255
  4124a0:	280a95fa 	slli	r5,r5,23
  4124a4:	10803fcc 	andi	r2,r2,255
  4124a8:	00c02034 	movhi	r3,128
  4124ac:	100497fa 	slli	r2,r2,31
  4124b0:	18ffffc4 	addi	r3,r3,-1
  4124b4:	20c6703a 	and	r3,r4,r3
  4124b8:	1946b03a 	or	r3,r3,r5
  4124bc:	1884b03a 	or	r2,r3,r2
  4124c0:	dfc00317 	ldw	ra,12(sp)
  4124c4:	dc800217 	ldw	r18,8(sp)
  4124c8:	dc400117 	ldw	r17,4(sp)
  4124cc:	dc000017 	ldw	r16,0(sp)
  4124d0:	dec00404 	addi	sp,sp,16
  4124d4:	f800283a 	ret
  4124d8:	00803fc4 	movi	r2,255
  4124dc:	80bfe126 	beq	r16,r2,412464 <_gp+0xffff2c68>
  4124e0:	31810034 	orhi	r6,r6,1024
  4124e4:	008006c4 	movi	r2,27
  4124e8:	11405b0e 	bge	r2,r5,412658 <__addsf3+0x250>
  4124ec:	01400044 	movi	r5,1
  4124f0:	1947c83a 	sub	r3,r3,r5
  4124f4:	1881002c 	andhi	r2,r3,1024
  4124f8:	10001426 	beq	r2,zero,41254c <__addsf3+0x144>
  4124fc:	04410034 	movhi	r17,1024
  412500:	8c7fffc4 	addi	r17,r17,-1
  412504:	1c62703a 	and	r17,r3,r17
  412508:	8809883a 	mov	r4,r17
  41250c:	04133e00 	call	4133e0 <__clzsi2>
  412510:	10bffec4 	addi	r2,r2,-5
  412514:	88a2983a 	sll	r17,r17,r2
  412518:	14004a16 	blt	r2,r16,412644 <__addsf3+0x23c>
  41251c:	140bc83a 	sub	r5,r2,r16
  412520:	00c007c4 	movi	r3,31
  412524:	1947c83a 	sub	r3,r3,r5
  412528:	88c6983a 	sll	r3,r17,r3
  41252c:	29400044 	addi	r5,r5,1
  412530:	8962d83a 	srl	r17,r17,r5
  412534:	1806c03a 	cmpne	r3,r3,zero
  412538:	0021883a 	mov	r16,zero
  41253c:	1c46b03a 	or	r3,r3,r17
  412540:	003fc806 	br	412464 <_gp+0xffff2c68>
  412544:	1000e526 	beq	r2,zero,4128dc <__addsf3+0x4d4>
  412548:	1007883a 	mov	r3,r2
  41254c:	188001cc 	andi	r2,r3,7
  412550:	103fc61e 	bne	r2,zero,41246c <_gp+0xffff2c70>
  412554:	9005883a 	mov	r2,r18
  412558:	01003fc4 	movi	r4,255
  41255c:	1806d0fa 	srli	r3,r3,3
  412560:	81001a26 	beq	r16,r4,4125cc <__addsf3+0x1c4>
  412564:	01002034 	movhi	r4,128
  412568:	213fffc4 	addi	r4,r4,-1
  41256c:	800b883a 	mov	r5,r16
  412570:	1908703a 	and	r4,r3,r4
  412574:	003fc906 	br	41249c <_gp+0xffff2ca0>
  412578:	01403e0e 	bge	zero,r5,412674 <__addsf3+0x26c>
  41257c:	20001e26 	beq	r4,zero,4125f8 <__addsf3+0x1f0>
  412580:	01003fc4 	movi	r4,255
  412584:	813fb726 	beq	r16,r4,412464 <_gp+0xffff2c68>
  412588:	31810034 	orhi	r6,r6,1024
  41258c:	010006c4 	movi	r4,27
  412590:	2140570e 	bge	r4,r5,4126f0 <__addsf3+0x2e8>
  412594:	01400044 	movi	r5,1
  412598:	1947883a 	add	r3,r3,r5
  41259c:	1901002c 	andhi	r4,r3,1024
  4125a0:	203fea26 	beq	r4,zero,41254c <_gp+0xffff2d50>
  4125a4:	84000044 	addi	r16,r16,1
  4125a8:	01003fc4 	movi	r4,255
  4125ac:	81007526 	beq	r16,r4,412784 <__addsf3+0x37c>
  4125b0:	00bf0034 	movhi	r2,64512
  4125b4:	10bfffc4 	addi	r2,r2,-1
  4125b8:	1900004c 	andi	r4,r3,1
  4125bc:	1886703a 	and	r3,r3,r2
  4125c0:	1806d07a 	srli	r3,r3,1
  4125c4:	1906b03a 	or	r3,r3,r4
  4125c8:	003fa606 	br	412464 <_gp+0xffff2c68>
  4125cc:	18001a26 	beq	r3,zero,412638 <__addsf3+0x230>
  4125d0:	19001034 	orhi	r4,r3,64
  4125d4:	00c02034 	movhi	r3,128
  4125d8:	18ffffc4 	addi	r3,r3,-1
  4125dc:	017fffc4 	movi	r5,-1
  4125e0:	20c8703a 	and	r4,r4,r3
  4125e4:	003fad06 	br	41249c <_gp+0xffff2ca0>
  4125e8:	297fffc4 	addi	r5,r5,-1
  4125ec:	28002c1e 	bne	r5,zero,4126a0 <__addsf3+0x298>
  4125f0:	1987c83a 	sub	r3,r3,r6
  4125f4:	003fbf06 	br	4124f4 <_gp+0xffff2cf8>
  4125f8:	303f9a26 	beq	r6,zero,412464 <_gp+0xffff2c68>
  4125fc:	297fffc4 	addi	r5,r5,-1
  412600:	28004b1e 	bne	r5,zero,412730 <__addsf3+0x328>
  412604:	1987883a 	add	r3,r3,r6
  412608:	003fe406 	br	41259c <_gp+0xffff2da0>
  41260c:	2800271e 	bne	r5,zero,4126ac <__addsf3+0x2a4>
  412610:	80800044 	addi	r2,r16,1
  412614:	10803fcc 	andi	r2,r2,255
  412618:	01000044 	movi	r4,1
  41261c:	2080520e 	bge	r4,r2,412768 <__addsf3+0x360>
  412620:	19a3c83a 	sub	r17,r3,r6
  412624:	8881002c 	andhi	r2,r17,1024
  412628:	10002c26 	beq	r2,zero,4126dc <__addsf3+0x2d4>
  41262c:	30e3c83a 	sub	r17,r6,r3
  412630:	4025883a 	mov	r18,r8
  412634:	003fb406 	br	412508 <_gp+0xffff2d0c>
  412638:	017fffc4 	movi	r5,-1
  41263c:	0009883a 	mov	r4,zero
  412640:	003f9606 	br	41249c <_gp+0xffff2ca0>
  412644:	00ff0034 	movhi	r3,64512
  412648:	18ffffc4 	addi	r3,r3,-1
  41264c:	80a1c83a 	sub	r16,r16,r2
  412650:	88c6703a 	and	r3,r17,r3
  412654:	003f8306 	br	412464 <_gp+0xffff2c68>
  412658:	00800804 	movi	r2,32
  41265c:	1145c83a 	sub	r2,r2,r5
  412660:	3084983a 	sll	r2,r6,r2
  412664:	314cd83a 	srl	r6,r6,r5
  412668:	100ac03a 	cmpne	r5,r2,zero
  41266c:	298ab03a 	or	r5,r5,r6
  412670:	003f9f06 	br	4124f0 <_gp+0xffff2cf4>
  412674:	2800451e 	bne	r5,zero,41278c <__addsf3+0x384>
  412678:	81000044 	addi	r4,r16,1
  41267c:	21c03fcc 	andi	r7,r4,255
  412680:	01400044 	movi	r5,1
  412684:	29c02d0e 	bge	r5,r7,41273c <__addsf3+0x334>
  412688:	01403fc4 	movi	r5,255
  41268c:	21403c26 	beq	r4,r5,412780 <__addsf3+0x378>
  412690:	30c7883a 	add	r3,r6,r3
  412694:	1806d07a 	srli	r3,r3,1
  412698:	2021883a 	mov	r16,r4
  41269c:	003f7106 	br	412464 <_gp+0xffff2c68>
  4126a0:	00803fc4 	movi	r2,255
  4126a4:	80bf8f1e 	bne	r16,r2,4124e4 <_gp+0xffff2ce8>
  4126a8:	003f6e06 	br	412464 <_gp+0xffff2c68>
  4126ac:	80001726 	beq	r16,zero,41270c <__addsf3+0x304>
  4126b0:	00803fc4 	movi	r2,255
  4126b4:	20801a26 	beq	r4,r2,412720 <__addsf3+0x318>
  4126b8:	014bc83a 	sub	r5,zero,r5
  4126bc:	18c10034 	orhi	r3,r3,1024
  4126c0:	008006c4 	movi	r2,27
  4126c4:	1140430e 	bge	r2,r5,4127d4 <__addsf3+0x3cc>
  4126c8:	00c00044 	movi	r3,1
  4126cc:	30c7c83a 	sub	r3,r6,r3
  4126d0:	2021883a 	mov	r16,r4
  4126d4:	4025883a 	mov	r18,r8
  4126d8:	003f8606 	br	4124f4 <_gp+0xffff2cf8>
  4126dc:	883f8a1e 	bne	r17,zero,412508 <_gp+0xffff2d0c>
  4126e0:	0007883a 	mov	r3,zero
  4126e4:	0005883a 	mov	r2,zero
  4126e8:	0021883a 	mov	r16,zero
  4126ec:	003f9a06 	br	412558 <_gp+0xffff2d5c>
  4126f0:	01000804 	movi	r4,32
  4126f4:	2149c83a 	sub	r4,r4,r5
  4126f8:	3108983a 	sll	r4,r6,r4
  4126fc:	314cd83a 	srl	r6,r6,r5
  412700:	200ac03a 	cmpne	r5,r4,zero
  412704:	298ab03a 	or	r5,r5,r6
  412708:	003fa306 	br	412598 <_gp+0xffff2d9c>
  41270c:	18000426 	beq	r3,zero,412720 <__addsf3+0x318>
  412710:	014a303a 	nor	r5,zero,r5
  412714:	283fed26 	beq	r5,zero,4126cc <_gp+0xffff2ed0>
  412718:	00803fc4 	movi	r2,255
  41271c:	20bfe81e 	bne	r4,r2,4126c0 <_gp+0xffff2ec4>
  412720:	3007883a 	mov	r3,r6
  412724:	2021883a 	mov	r16,r4
  412728:	4025883a 	mov	r18,r8
  41272c:	003f4d06 	br	412464 <_gp+0xffff2c68>
  412730:	01003fc4 	movi	r4,255
  412734:	813f951e 	bne	r16,r4,41258c <_gp+0xffff2d90>
  412738:	003f4a06 	br	412464 <_gp+0xffff2c68>
  41273c:	8000471e 	bne	r16,zero,41285c <__addsf3+0x454>
  412740:	18006126 	beq	r3,zero,4128c8 <__addsf3+0x4c0>
  412744:	303f4726 	beq	r6,zero,412464 <_gp+0xffff2c68>
  412748:	1987883a 	add	r3,r3,r6
  41274c:	1881002c 	andhi	r2,r3,1024
  412750:	103f7e26 	beq	r2,zero,41254c <_gp+0xffff2d50>
  412754:	00bf0034 	movhi	r2,64512
  412758:	10bfffc4 	addi	r2,r2,-1
  41275c:	2821883a 	mov	r16,r5
  412760:	1886703a 	and	r3,r3,r2
  412764:	003f3f06 	br	412464 <_gp+0xffff2c68>
  412768:	8000141e 	bne	r16,zero,4127bc <__addsf3+0x3b4>
  41276c:	1800311e 	bne	r3,zero,412834 <__addsf3+0x42c>
  412770:	30004626 	beq	r6,zero,41288c <__addsf3+0x484>
  412774:	3007883a 	mov	r3,r6
  412778:	4025883a 	mov	r18,r8
  41277c:	003f3906 	br	412464 <_gp+0xffff2c68>
  412780:	2021883a 	mov	r16,r4
  412784:	0007883a 	mov	r3,zero
  412788:	003f7306 	br	412558 <_gp+0xffff2d5c>
  41278c:	8000181e 	bne	r16,zero,4127f0 <__addsf3+0x3e8>
  412790:	18002f26 	beq	r3,zero,412850 <__addsf3+0x448>
  412794:	014a303a 	nor	r5,zero,r5
  412798:	28000526 	beq	r5,zero,4127b0 <__addsf3+0x3a8>
  41279c:	01c03fc4 	movi	r7,255
  4127a0:	21c02b26 	beq	r4,r7,412850 <__addsf3+0x448>
  4127a4:	01c006c4 	movi	r7,27
  4127a8:	3940400e 	bge	r7,r5,4128ac <__addsf3+0x4a4>
  4127ac:	00c00044 	movi	r3,1
  4127b0:	1987883a 	add	r3,r3,r6
  4127b4:	2021883a 	mov	r16,r4
  4127b8:	003f7806 	br	41259c <_gp+0xffff2da0>
  4127bc:	1800111e 	bne	r3,zero,412804 <__addsf3+0x3fc>
  4127c0:	30003526 	beq	r6,zero,412898 <__addsf3+0x490>
  4127c4:	3007883a 	mov	r3,r6
  4127c8:	4025883a 	mov	r18,r8
  4127cc:	04003fc4 	movi	r16,255
  4127d0:	003f2406 	br	412464 <_gp+0xffff2c68>
  4127d4:	00800804 	movi	r2,32
  4127d8:	1145c83a 	sub	r2,r2,r5
  4127dc:	1884983a 	sll	r2,r3,r2
  4127e0:	194ad83a 	srl	r5,r3,r5
  4127e4:	1006c03a 	cmpne	r3,r2,zero
  4127e8:	1946b03a 	or	r3,r3,r5
  4127ec:	003fb706 	br	4126cc <_gp+0xffff2ed0>
  4127f0:	01c03fc4 	movi	r7,255
  4127f4:	21c01626 	beq	r4,r7,412850 <__addsf3+0x448>
  4127f8:	014bc83a 	sub	r5,zero,r5
  4127fc:	18c10034 	orhi	r3,r3,1024
  412800:	003fe806 	br	4127a4 <_gp+0xffff2fa8>
  412804:	30001f26 	beq	r6,zero,412884 <__addsf3+0x47c>
  412808:	1806d0fa 	srli	r3,r3,3
  41280c:	1880102c 	andhi	r2,r3,64
  412810:	10000526 	beq	r2,zero,412828 <__addsf3+0x420>
  412814:	300cd0fa 	srli	r6,r6,3
  412818:	3080102c 	andhi	r2,r6,64
  41281c:	1000021e 	bne	r2,zero,412828 <__addsf3+0x420>
  412820:	3007883a 	mov	r3,r6
  412824:	4025883a 	mov	r18,r8
  412828:	180690fa 	slli	r3,r3,3
  41282c:	04003fc4 	movi	r16,255
  412830:	003f0c06 	br	412464 <_gp+0xffff2c68>
  412834:	303f0b26 	beq	r6,zero,412464 <_gp+0xffff2c68>
  412838:	1985c83a 	sub	r2,r3,r6
  41283c:	1101002c 	andhi	r4,r2,1024
  412840:	203f4026 	beq	r4,zero,412544 <_gp+0xffff2d48>
  412844:	30c7c83a 	sub	r3,r6,r3
  412848:	4025883a 	mov	r18,r8
  41284c:	003f0506 	br	412464 <_gp+0xffff2c68>
  412850:	3007883a 	mov	r3,r6
  412854:	2021883a 	mov	r16,r4
  412858:	003f0206 	br	412464 <_gp+0xffff2c68>
  41285c:	18001c26 	beq	r3,zero,4128d0 <__addsf3+0x4c8>
  412860:	30000826 	beq	r6,zero,412884 <__addsf3+0x47c>
  412864:	1806d0fa 	srli	r3,r3,3
  412868:	1880102c 	andhi	r2,r3,64
  41286c:	103fee26 	beq	r2,zero,412828 <_gp+0xffff302c>
  412870:	300cd0fa 	srli	r6,r6,3
  412874:	3080102c 	andhi	r2,r6,64
  412878:	103feb1e 	bne	r2,zero,412828 <_gp+0xffff302c>
  41287c:	3007883a 	mov	r3,r6
  412880:	003fe906 	br	412828 <_gp+0xffff302c>
  412884:	04003fc4 	movi	r16,255
  412888:	003ef606 	br	412464 <_gp+0xffff2c68>
  41288c:	8007883a 	mov	r3,r16
  412890:	0005883a 	mov	r2,zero
  412894:	003f3006 	br	412558 <_gp+0xffff2d5c>
  412898:	00c10034 	movhi	r3,1024
  41289c:	0005883a 	mov	r2,zero
  4128a0:	18fffe04 	addi	r3,r3,-8
  4128a4:	04003fc4 	movi	r16,255
  4128a8:	003f2b06 	br	412558 <_gp+0xffff2d5c>
  4128ac:	01c00804 	movi	r7,32
  4128b0:	394fc83a 	sub	r7,r7,r5
  4128b4:	19ce983a 	sll	r7,r3,r7
  4128b8:	194ad83a 	srl	r5,r3,r5
  4128bc:	3806c03a 	cmpne	r3,r7,zero
  4128c0:	1946b03a 	or	r3,r3,r5
  4128c4:	003fba06 	br	4127b0 <_gp+0xffff2fb4>
  4128c8:	3007883a 	mov	r3,r6
  4128cc:	003ee506 	br	412464 <_gp+0xffff2c68>
  4128d0:	3007883a 	mov	r3,r6
  4128d4:	04003fc4 	movi	r16,255
  4128d8:	003ee206 	br	412464 <_gp+0xffff2c68>
  4128dc:	0007883a 	mov	r3,zero
  4128e0:	0005883a 	mov	r2,zero
  4128e4:	003f1c06 	br	412558 <_gp+0xffff2d5c>

004128e8 <__divsf3>:
  4128e8:	defff504 	addi	sp,sp,-44
  4128ec:	dd000515 	stw	r20,20(sp)
  4128f0:	2028d5fa 	srli	r20,r4,23
  4128f4:	dd400615 	stw	r21,24(sp)
  4128f8:	202ad7fa 	srli	r21,r4,31
  4128fc:	00c02034 	movhi	r3,128
  412900:	dcc00415 	stw	r19,16(sp)
  412904:	dc800315 	stw	r18,12(sp)
  412908:	18ffffc4 	addi	r3,r3,-1
  41290c:	dfc00a15 	stw	ra,40(sp)
  412910:	df000915 	stw	fp,36(sp)
  412914:	ddc00815 	stw	r23,32(sp)
  412918:	dd800715 	stw	r22,28(sp)
  41291c:	dc400215 	stw	r17,8(sp)
  412920:	dc000115 	stw	r16,4(sp)
  412924:	a5003fcc 	andi	r20,r20,255
  412928:	1924703a 	and	r18,r3,r4
  41292c:	acc03fcc 	andi	r19,r21,255
  412930:	a0004d26 	beq	r20,zero,412a68 <__divsf3+0x180>
  412934:	00803fc4 	movi	r2,255
  412938:	a0802e26 	beq	r20,r2,4129f4 <__divsf3+0x10c>
  41293c:	91002034 	orhi	r4,r18,128
  412940:	202490fa 	slli	r18,r4,3
  412944:	a53fe044 	addi	r20,r20,-127
  412948:	0021883a 	mov	r16,zero
  41294c:	002f883a 	mov	r23,zero
  412950:	2804d5fa 	srli	r2,r5,23
  412954:	282cd7fa 	srli	r22,r5,31
  412958:	00c02034 	movhi	r3,128
  41295c:	18ffffc4 	addi	r3,r3,-1
  412960:	10803fcc 	andi	r2,r2,255
  412964:	1962703a 	and	r17,r3,r5
  412968:	b7003fcc 	andi	fp,r22,255
  41296c:	10004526 	beq	r2,zero,412a84 <__divsf3+0x19c>
  412970:	00c03fc4 	movi	r3,255
  412974:	10c04026 	beq	r2,r3,412a78 <__divsf3+0x190>
  412978:	88c02034 	orhi	r3,r17,128
  41297c:	182290fa 	slli	r17,r3,3
  412980:	10bfe044 	addi	r2,r2,-127
  412984:	0009883a 	mov	r4,zero
  412988:	2420b03a 	or	r16,r4,r16
  41298c:	802090ba 	slli	r16,r16,2
  412990:	01c01074 	movhi	r7,65
  412994:	39ca6d04 	addi	r7,r7,10676
  412998:	81e1883a 	add	r16,r16,r7
  41299c:	80c00017 	ldw	r3,0(r16)
  4129a0:	ad8af03a 	xor	r5,r21,r22
  4129a4:	280d883a 	mov	r6,r5
  4129a8:	a085c83a 	sub	r2,r20,r2
  4129ac:	29403fcc 	andi	r5,r5,255
  4129b0:	1800683a 	jmp	r3
  4129b4:	00412bc0 	call	412bc <__alt_mem_epcs_flash_controller_0+0x202bc>
  4129b8:	00412b68 	cmpgeui	at,zero,1197
  4129bc:	00412b8c 	andi	at,zero,1198
  4129c0:	00412b54 	movui	at,1197
  4129c4:	00412b8c 	andi	at,zero,1198
  4129c8:	00412a04 	movi	at,1192
  4129cc:	00412b8c 	andi	at,zero,1198
  4129d0:	00412b54 	movui	at,1197
  4129d4:	00412b68 	cmpgeui	at,zero,1197
  4129d8:	00412b68 	cmpgeui	at,zero,1197
  4129dc:	00412a04 	movi	at,1192
  4129e0:	00412b54 	movui	at,1197
  4129e4:	00412c58 	cmpnei	at,zero,1201
  4129e8:	00412c58 	cmpnei	at,zero,1201
  4129ec:	00412c58 	cmpnei	at,zero,1201
  4129f0:	00412b98 	cmpnei	at,zero,1198
  4129f4:	9000531e 	bne	r18,zero,412b44 <__divsf3+0x25c>
  4129f8:	04000204 	movi	r16,8
  4129fc:	05c00084 	movi	r23,2
  412a00:	003fd306 	br	412950 <_gp+0xffff3154>
  412a04:	00c02034 	movhi	r3,128
  412a08:	000d883a 	mov	r6,zero
  412a0c:	18ffffc4 	addi	r3,r3,-1
  412a10:	013fffc4 	movi	r4,-1
  412a14:	21003fcc 	andi	r4,r4,255
  412a18:	200895fa 	slli	r4,r4,23
  412a1c:	30803fcc 	andi	r2,r6,255
  412a20:	01802034 	movhi	r6,128
  412a24:	31bfffc4 	addi	r6,r6,-1
  412a28:	100497fa 	slli	r2,r2,31
  412a2c:	1986703a 	and	r3,r3,r6
  412a30:	1906b03a 	or	r3,r3,r4
  412a34:	1884b03a 	or	r2,r3,r2
  412a38:	dfc00a17 	ldw	ra,40(sp)
  412a3c:	df000917 	ldw	fp,36(sp)
  412a40:	ddc00817 	ldw	r23,32(sp)
  412a44:	dd800717 	ldw	r22,28(sp)
  412a48:	dd400617 	ldw	r21,24(sp)
  412a4c:	dd000517 	ldw	r20,20(sp)
  412a50:	dcc00417 	ldw	r19,16(sp)
  412a54:	dc800317 	ldw	r18,12(sp)
  412a58:	dc400217 	ldw	r17,8(sp)
  412a5c:	dc000117 	ldw	r16,4(sp)
  412a60:	dec00b04 	addi	sp,sp,44
  412a64:	f800283a 	ret
  412a68:	90002b1e 	bne	r18,zero,412b18 <__divsf3+0x230>
  412a6c:	04000104 	movi	r16,4
  412a70:	05c00044 	movi	r23,1
  412a74:	003fb606 	br	412950 <_gp+0xffff3154>
  412a78:	8800251e 	bne	r17,zero,412b10 <__divsf3+0x228>
  412a7c:	01000084 	movi	r4,2
  412a80:	00000206 	br	412a8c <__divsf3+0x1a4>
  412a84:	88001a1e 	bne	r17,zero,412af0 <__divsf3+0x208>
  412a88:	01000044 	movi	r4,1
  412a8c:	2420b03a 	or	r16,r4,r16
  412a90:	802090ba 	slli	r16,r16,2
  412a94:	00c01074 	movhi	r3,65
  412a98:	18caac04 	addi	r3,r3,10928
  412a9c:	80e1883a 	add	r16,r16,r3
  412aa0:	80c00017 	ldw	r3,0(r16)
  412aa4:	ad8af03a 	xor	r5,r21,r22
  412aa8:	a085c83a 	sub	r2,r20,r2
  412aac:	1800683a 	jmp	r3
  412ab0:	00412b68 	cmpgeui	at,zero,1197
  412ab4:	00412b68 	cmpgeui	at,zero,1197
  412ab8:	00412cb8 	rdprs	at,zero,1202
  412abc:	00412b50 	cmplti	at,zero,1197
  412ac0:	00412cb8 	rdprs	at,zero,1202
  412ac4:	00412a04 	movi	at,1192
  412ac8:	00412cb8 	rdprs	at,zero,1202
  412acc:	00412b50 	cmplti	at,zero,1197
  412ad0:	00412b68 	cmpgeui	at,zero,1197
  412ad4:	00412b68 	cmpgeui	at,zero,1197
  412ad8:	00412a04 	movi	at,1192
  412adc:	00412b50 	cmplti	at,zero,1197
  412ae0:	00412c58 	cmpnei	at,zero,1201
  412ae4:	00412c58 	cmpnei	at,zero,1201
  412ae8:	00412c58 	cmpnei	at,zero,1201
  412aec:	00412c84 	movi	at,1202
  412af0:	8809883a 	mov	r4,r17
  412af4:	04133e00 	call	4133e0 <__clzsi2>
  412af8:	10fffec4 	addi	r3,r2,-5
  412afc:	88e2983a 	sll	r17,r17,r3
  412b00:	00ffe284 	movi	r3,-118
  412b04:	1885c83a 	sub	r2,r3,r2
  412b08:	0009883a 	mov	r4,zero
  412b0c:	003f9e06 	br	412988 <_gp+0xffff318c>
  412b10:	010000c4 	movi	r4,3
  412b14:	003f9c06 	br	412988 <_gp+0xffff318c>
  412b18:	9009883a 	mov	r4,r18
  412b1c:	d9400015 	stw	r5,0(sp)
  412b20:	04133e00 	call	4133e0 <__clzsi2>
  412b24:	10fffec4 	addi	r3,r2,-5
  412b28:	053fe284 	movi	r20,-118
  412b2c:	90e4983a 	sll	r18,r18,r3
  412b30:	a0a9c83a 	sub	r20,r20,r2
  412b34:	0021883a 	mov	r16,zero
  412b38:	002f883a 	mov	r23,zero
  412b3c:	d9400017 	ldw	r5,0(sp)
  412b40:	003f8306 	br	412950 <_gp+0xffff3154>
  412b44:	04000304 	movi	r16,12
  412b48:	05c000c4 	movi	r23,3
  412b4c:	003f8006 	br	412950 <_gp+0xffff3154>
  412b50:	0023883a 	mov	r17,zero
  412b54:	e027883a 	mov	r19,fp
  412b58:	202f883a 	mov	r23,r4
  412b5c:	00c00084 	movi	r3,2
  412b60:	980b883a 	mov	r5,r19
  412b64:	b8c0501e 	bne	r23,r3,412ca8 <__divsf3+0x3c0>
  412b68:	2980004c 	andi	r6,r5,1
  412b6c:	013fffc4 	movi	r4,-1
  412b70:	0007883a 	mov	r3,zero
  412b74:	003fa706 	br	412a14 <_gp+0xffff3218>
  412b78:	013fe084 	movi	r4,-126
  412b7c:	2089c83a 	sub	r4,r4,r2
  412b80:	00c006c4 	movi	r3,27
  412b84:	1900500e 	bge	r3,r4,412cc8 <__divsf3+0x3e0>
  412b88:	9980004c 	andi	r6,r19,1
  412b8c:	0009883a 	mov	r4,zero
  412b90:	0007883a 	mov	r3,zero
  412b94:	003f9f06 	br	412a14 <_gp+0xffff3218>
  412b98:	9080102c 	andhi	r2,r18,64
  412b9c:	10000226 	beq	r2,zero,412ba8 <__divsf3+0x2c0>
  412ba0:	8880102c 	andhi	r2,r17,64
  412ba4:	10003a26 	beq	r2,zero,412c90 <__divsf3+0x3a8>
  412ba8:	00802034 	movhi	r2,128
  412bac:	90c01034 	orhi	r3,r18,64
  412bb0:	10bfffc4 	addi	r2,r2,-1
  412bb4:	a80d883a 	mov	r6,r21
  412bb8:	1886703a 	and	r3,r3,r2
  412bbc:	003f9406 	br	412a10 <_gp+0xffff3214>
  412bc0:	9006917a 	slli	r3,r18,5
  412bc4:	8822917a 	slli	r17,r17,5
  412bc8:	1c402936 	bltu	r3,r17,412c70 <__divsf3+0x388>
  412bcc:	1c47c83a 	sub	r3,r3,r17
  412bd0:	2827883a 	mov	r19,r5
  412bd4:	01800684 	movi	r6,26
  412bd8:	01000044 	movi	r4,1
  412bdc:	180f883a 	mov	r7,r3
  412be0:	2109883a 	add	r4,r4,r4
  412be4:	18c7883a 	add	r3,r3,r3
  412be8:	38000116 	blt	r7,zero,412bf0 <__divsf3+0x308>
  412bec:	1c400236 	bltu	r3,r17,412bf8 <__divsf3+0x310>
  412bf0:	1c47c83a 	sub	r3,r3,r17
  412bf4:	21000054 	ori	r4,r4,1
  412bf8:	31bfffc4 	addi	r6,r6,-1
  412bfc:	303ff71e 	bne	r6,zero,412bdc <_gp+0xffff33e0>
  412c00:	1806c03a 	cmpne	r3,r3,zero
  412c04:	1922b03a 	or	r17,r3,r4
  412c08:	11001fc4 	addi	r4,r2,127
  412c0c:	013fda0e 	bge	zero,r4,412b78 <_gp+0xffff337c>
  412c10:	88c001cc 	andi	r3,r17,7
  412c14:	18000426 	beq	r3,zero,412c28 <__divsf3+0x340>
  412c18:	894003cc 	andi	r5,r17,15
  412c1c:	00c00104 	movi	r3,4
  412c20:	28c00126 	beq	r5,r3,412c28 <__divsf3+0x340>
  412c24:	88e3883a 	add	r17,r17,r3
  412c28:	88c2002c 	andhi	r3,r17,2048
  412c2c:	18000426 	beq	r3,zero,412c40 <__divsf3+0x358>
  412c30:	11002004 	addi	r4,r2,128
  412c34:	00be0034 	movhi	r2,63488
  412c38:	10bfffc4 	addi	r2,r2,-1
  412c3c:	88a2703a 	and	r17,r17,r2
  412c40:	00803f84 	movi	r2,254
  412c44:	1100060e 	bge	r2,r4,412c60 <__divsf3+0x378>
  412c48:	9980004c 	andi	r6,r19,1
  412c4c:	013fffc4 	movi	r4,-1
  412c50:	0007883a 	mov	r3,zero
  412c54:	003f6f06 	br	412a14 <_gp+0xffff3218>
  412c58:	9023883a 	mov	r17,r18
  412c5c:	003fbf06 	br	412b5c <_gp+0xffff3360>
  412c60:	880691ba 	slli	r3,r17,6
  412c64:	9980004c 	andi	r6,r19,1
  412c68:	1806d27a 	srli	r3,r3,9
  412c6c:	003f6906 	br	412a14 <_gp+0xffff3218>
  412c70:	10bfffc4 	addi	r2,r2,-1
  412c74:	2827883a 	mov	r19,r5
  412c78:	018006c4 	movi	r6,27
  412c7c:	0009883a 	mov	r4,zero
  412c80:	003fd606 	br	412bdc <_gp+0xffff33e0>
  412c84:	9080102c 	andhi	r2,r18,64
  412c88:	0023883a 	mov	r17,zero
  412c8c:	103fc626 	beq	r2,zero,412ba8 <_gp+0xffff33ac>
  412c90:	00802034 	movhi	r2,128
  412c94:	88c01034 	orhi	r3,r17,64
  412c98:	10bfffc4 	addi	r2,r2,-1
  412c9c:	b00d883a 	mov	r6,r22
  412ca0:	1886703a 	and	r3,r3,r2
  412ca4:	003f5a06 	br	412a10 <_gp+0xffff3214>
  412ca8:	00c000c4 	movi	r3,3
  412cac:	b8c01c26 	beq	r23,r3,412d20 <__divsf3+0x438>
  412cb0:	00c00044 	movi	r3,1
  412cb4:	b8ffd41e 	bne	r23,r3,412c08 <_gp+0xffff340c>
  412cb8:	2980004c 	andi	r6,r5,1
  412cbc:	0009883a 	mov	r4,zero
  412cc0:	0007883a 	mov	r3,zero
  412cc4:	003f5306 	br	412a14 <_gp+0xffff3218>
  412cc8:	10802784 	addi	r2,r2,158
  412ccc:	8884983a 	sll	r2,r17,r2
  412cd0:	8908d83a 	srl	r4,r17,r4
  412cd4:	1022c03a 	cmpne	r17,r2,zero
  412cd8:	8908b03a 	or	r4,r17,r4
  412cdc:	208001cc 	andi	r2,r4,7
  412ce0:	10000426 	beq	r2,zero,412cf4 <__divsf3+0x40c>
  412ce4:	20c003cc 	andi	r3,r4,15
  412ce8:	00800104 	movi	r2,4
  412cec:	18800126 	beq	r3,r2,412cf4 <__divsf3+0x40c>
  412cf0:	2089883a 	add	r4,r4,r2
  412cf4:	2081002c 	andhi	r2,r4,1024
  412cf8:	10000426 	beq	r2,zero,412d0c <__divsf3+0x424>
  412cfc:	9980004c 	andi	r6,r19,1
  412d00:	01000044 	movi	r4,1
  412d04:	0007883a 	mov	r3,zero
  412d08:	003f4206 	br	412a14 <_gp+0xffff3218>
  412d0c:	200691ba 	slli	r3,r4,6
  412d10:	9980004c 	andi	r6,r19,1
  412d14:	0009883a 	mov	r4,zero
  412d18:	1806d27a 	srli	r3,r3,9
  412d1c:	003f3d06 	br	412a14 <_gp+0xffff3218>
  412d20:	00802034 	movhi	r2,128
  412d24:	88c01034 	orhi	r3,r17,64
  412d28:	10bfffc4 	addi	r2,r2,-1
  412d2c:	9980004c 	andi	r6,r19,1
  412d30:	1886703a 	and	r3,r3,r2
  412d34:	003f3606 	br	412a10 <_gp+0xffff3214>

00412d38 <__subsf3>:
  412d38:	defffc04 	addi	sp,sp,-16
  412d3c:	280ed5fa 	srli	r7,r5,23
  412d40:	02002034 	movhi	r8,128
  412d44:	280d883a 	mov	r6,r5
  412d48:	423fffc4 	addi	r8,r8,-1
  412d4c:	200ad5fa 	srli	r5,r4,23
  412d50:	dc400115 	stw	r17,4(sp)
  412d54:	2022d7fa 	srli	r17,r4,31
  412d58:	4108703a 	and	r4,r8,r4
  412d5c:	dc000015 	stw	r16,0(sp)
  412d60:	4190703a 	and	r8,r8,r6
  412d64:	200690fa 	slli	r3,r4,3
  412d68:	dfc00315 	stw	ra,12(sp)
  412d6c:	dc800215 	stw	r18,8(sp)
  412d70:	39c03fcc 	andi	r7,r7,255
  412d74:	01003fc4 	movi	r4,255
  412d78:	8805883a 	mov	r2,r17
  412d7c:	2c003fcc 	andi	r16,r5,255
  412d80:	8c403fcc 	andi	r17,r17,255
  412d84:	300cd7fa 	srli	r6,r6,31
  412d88:	401090fa 	slli	r8,r8,3
  412d8c:	39006126 	beq	r7,r4,412f14 <__subsf3+0x1dc>
  412d90:	3180005c 	xori	r6,r6,1
  412d94:	89804926 	beq	r17,r6,412ebc <__subsf3+0x184>
  412d98:	81c5c83a 	sub	r2,r16,r7
  412d9c:	0080710e 	bge	zero,r2,412f64 <__subsf3+0x22c>
  412da0:	38001e1e 	bne	r7,zero,412e1c <__subsf3+0xe4>
  412da4:	4000651e 	bne	r8,zero,412f3c <__subsf3+0x204>
  412da8:	188001cc 	andi	r2,r3,7
  412dac:	10000426 	beq	r2,zero,412dc0 <__subsf3+0x88>
  412db0:	190003cc 	andi	r4,r3,15
  412db4:	00800104 	movi	r2,4
  412db8:	20800126 	beq	r4,r2,412dc0 <__subsf3+0x88>
  412dbc:	18c00104 	addi	r3,r3,4
  412dc0:	1901002c 	andhi	r4,r3,1024
  412dc4:	8880004c 	andi	r2,r17,1
  412dc8:	20003426 	beq	r4,zero,412e9c <__subsf3+0x164>
  412dcc:	81400044 	addi	r5,r16,1
  412dd0:	01003fc4 	movi	r4,255
  412dd4:	29006e26 	beq	r5,r4,412f90 <__subsf3+0x258>
  412dd8:	180691ba 	slli	r3,r3,6
  412ddc:	1808d27a 	srli	r4,r3,9
  412de0:	29403fcc 	andi	r5,r5,255
  412de4:	280a95fa 	slli	r5,r5,23
  412de8:	10803fcc 	andi	r2,r2,255
  412dec:	00c02034 	movhi	r3,128
  412df0:	100497fa 	slli	r2,r2,31
  412df4:	18ffffc4 	addi	r3,r3,-1
  412df8:	20c6703a 	and	r3,r4,r3
  412dfc:	1946b03a 	or	r3,r3,r5
  412e00:	1884b03a 	or	r2,r3,r2
  412e04:	dfc00317 	ldw	ra,12(sp)
  412e08:	dc800217 	ldw	r18,8(sp)
  412e0c:	dc400117 	ldw	r17,4(sp)
  412e10:	dc000017 	ldw	r16,0(sp)
  412e14:	dec00404 	addi	sp,sp,16
  412e18:	f800283a 	ret
  412e1c:	01003fc4 	movi	r4,255
  412e20:	813fe126 	beq	r16,r4,412da8 <_gp+0xffff35ac>
  412e24:	42010034 	orhi	r8,r8,1024
  412e28:	010006c4 	movi	r4,27
  412e2c:	2080600e 	bge	r4,r2,412fb0 <__subsf3+0x278>
  412e30:	02000044 	movi	r8,1
  412e34:	1a07c83a 	sub	r3,r3,r8
  412e38:	1881002c 	andhi	r2,r3,1024
  412e3c:	10001426 	beq	r2,zero,412e90 <__subsf3+0x158>
  412e40:	04810034 	movhi	r18,1024
  412e44:	94bfffc4 	addi	r18,r18,-1
  412e48:	1ca4703a 	and	r18,r3,r18
  412e4c:	9009883a 	mov	r4,r18
  412e50:	04133e00 	call	4133e0 <__clzsi2>
  412e54:	10bffec4 	addi	r2,r2,-5
  412e58:	90a4983a 	sll	r18,r18,r2
  412e5c:	14004f16 	blt	r2,r16,412f9c <__subsf3+0x264>
  412e60:	140bc83a 	sub	r5,r2,r16
  412e64:	00c007c4 	movi	r3,31
  412e68:	1947c83a 	sub	r3,r3,r5
  412e6c:	90c6983a 	sll	r3,r18,r3
  412e70:	29400044 	addi	r5,r5,1
  412e74:	9164d83a 	srl	r18,r18,r5
  412e78:	1806c03a 	cmpne	r3,r3,zero
  412e7c:	0021883a 	mov	r16,zero
  412e80:	1c86b03a 	or	r3,r3,r18
  412e84:	003fc806 	br	412da8 <_gp+0xffff35ac>
  412e88:	1000e726 	beq	r2,zero,413228 <__subsf3+0x4f0>
  412e8c:	1007883a 	mov	r3,r2
  412e90:	188001cc 	andi	r2,r3,7
  412e94:	103fc61e 	bne	r2,zero,412db0 <_gp+0xffff35b4>
  412e98:	8880004c 	andi	r2,r17,1
  412e9c:	01003fc4 	movi	r4,255
  412ea0:	1806d0fa 	srli	r3,r3,3
  412ea4:	81001e26 	beq	r16,r4,412f20 <__subsf3+0x1e8>
  412ea8:	01002034 	movhi	r4,128
  412eac:	213fffc4 	addi	r4,r4,-1
  412eb0:	800b883a 	mov	r5,r16
  412eb4:	1908703a 	and	r4,r3,r4
  412eb8:	003fc906 	br	412de0 <_gp+0xffff35e4>
  412ebc:	81c9c83a 	sub	r4,r16,r7
  412ec0:	0100420e 	bge	zero,r4,412fcc <__subsf3+0x294>
  412ec4:	38002226 	beq	r7,zero,412f50 <__subsf3+0x218>
  412ec8:	01403fc4 	movi	r5,255
  412ecc:	817fb626 	beq	r16,r5,412da8 <_gp+0xffff35ac>
  412ed0:	42010034 	orhi	r8,r8,1024
  412ed4:	014006c4 	movi	r5,27
  412ed8:	2900580e 	bge	r5,r4,41303c <__subsf3+0x304>
  412edc:	01000044 	movi	r4,1
  412ee0:	1907883a 	add	r3,r3,r4
  412ee4:	1901002c 	andhi	r4,r3,1024
  412ee8:	203fe926 	beq	r4,zero,412e90 <_gp+0xffff3694>
  412eec:	84000044 	addi	r16,r16,1
  412ef0:	01003fc4 	movi	r4,255
  412ef4:	81007626 	beq	r16,r4,4130d0 <__subsf3+0x398>
  412ef8:	00bf0034 	movhi	r2,64512
  412efc:	10bfffc4 	addi	r2,r2,-1
  412f00:	1900004c 	andi	r4,r3,1
  412f04:	1886703a 	and	r3,r3,r2
  412f08:	1806d07a 	srli	r3,r3,1
  412f0c:	1906b03a 	or	r3,r3,r4
  412f10:	003fa506 	br	412da8 <_gp+0xffff35ac>
  412f14:	403f9e26 	beq	r8,zero,412d90 <_gp+0xffff3594>
  412f18:	31803fcc 	andi	r6,r6,255
  412f1c:	003f9d06 	br	412d94 <_gp+0xffff3598>
  412f20:	18001b26 	beq	r3,zero,412f90 <__subsf3+0x258>
  412f24:	19001034 	orhi	r4,r3,64
  412f28:	00c02034 	movhi	r3,128
  412f2c:	18ffffc4 	addi	r3,r3,-1
  412f30:	017fffc4 	movi	r5,-1
  412f34:	20c8703a 	and	r4,r4,r3
  412f38:	003fa906 	br	412de0 <_gp+0xffff35e4>
  412f3c:	10bfffc4 	addi	r2,r2,-1
  412f40:	103fbc26 	beq	r2,zero,412e34 <_gp+0xffff3638>
  412f44:	01003fc4 	movi	r4,255
  412f48:	813fb71e 	bne	r16,r4,412e28 <_gp+0xffff362c>
  412f4c:	003f9606 	br	412da8 <_gp+0xffff35ac>
  412f50:	403f9526 	beq	r8,zero,412da8 <_gp+0xffff35ac>
  412f54:	213fffc4 	addi	r4,r4,-1
  412f58:	2000481e 	bne	r4,zero,41307c <__subsf3+0x344>
  412f5c:	1a07883a 	add	r3,r3,r8
  412f60:	003fe006 	br	412ee4 <_gp+0xffff36e8>
  412f64:	1000241e 	bne	r2,zero,412ff8 <__subsf3+0x2c0>
  412f68:	80800044 	addi	r2,r16,1
  412f6c:	10803fcc 	andi	r2,r2,255
  412f70:	01000044 	movi	r4,1
  412f74:	20804f0e 	bge	r4,r2,4130b4 <__subsf3+0x37c>
  412f78:	1a25c83a 	sub	r18,r3,r8
  412f7c:	9081002c 	andhi	r2,r18,1024
  412f80:	10002926 	beq	r2,zero,413028 <__subsf3+0x2f0>
  412f84:	40e5c83a 	sub	r18,r8,r3
  412f88:	3023883a 	mov	r17,r6
  412f8c:	003faf06 	br	412e4c <_gp+0xffff3650>
  412f90:	017fffc4 	movi	r5,-1
  412f94:	0009883a 	mov	r4,zero
  412f98:	003f9106 	br	412de0 <_gp+0xffff35e4>
  412f9c:	00ff0034 	movhi	r3,64512
  412fa0:	18ffffc4 	addi	r3,r3,-1
  412fa4:	80a1c83a 	sub	r16,r16,r2
  412fa8:	90c6703a 	and	r3,r18,r3
  412fac:	003f7e06 	br	412da8 <_gp+0xffff35ac>
  412fb0:	01000804 	movi	r4,32
  412fb4:	2089c83a 	sub	r4,r4,r2
  412fb8:	4108983a 	sll	r4,r8,r4
  412fbc:	4090d83a 	srl	r8,r8,r2
  412fc0:	2004c03a 	cmpne	r2,r4,zero
  412fc4:	1210b03a 	or	r8,r2,r8
  412fc8:	003f9a06 	br	412e34 <_gp+0xffff3638>
  412fcc:	2000421e 	bne	r4,zero,4130d8 <__subsf3+0x3a0>
  412fd0:	81000044 	addi	r4,r16,1
  412fd4:	21803fcc 	andi	r6,r4,255
  412fd8:	01400044 	movi	r5,1
  412fdc:	29802a0e 	bge	r5,r6,413088 <__subsf3+0x350>
  412fe0:	01403fc4 	movi	r5,255
  412fe4:	21403926 	beq	r4,r5,4130cc <__subsf3+0x394>
  412fe8:	40c7883a 	add	r3,r8,r3
  412fec:	1806d07a 	srli	r3,r3,1
  412ff0:	2021883a 	mov	r16,r4
  412ff4:	003f6c06 	br	412da8 <_gp+0xffff35ac>
  412ff8:	80001726 	beq	r16,zero,413058 <__subsf3+0x320>
  412ffc:	01003fc4 	movi	r4,255
  413000:	39001a26 	beq	r7,r4,41306c <__subsf3+0x334>
  413004:	0085c83a 	sub	r2,zero,r2
  413008:	18c10034 	orhi	r3,r3,1024
  41300c:	010006c4 	movi	r4,27
  413010:	2080430e 	bge	r4,r2,413120 <__subsf3+0x3e8>
  413014:	00c00044 	movi	r3,1
  413018:	40c7c83a 	sub	r3,r8,r3
  41301c:	3821883a 	mov	r16,r7
  413020:	3023883a 	mov	r17,r6
  413024:	003f8406 	br	412e38 <_gp+0xffff363c>
  413028:	903f881e 	bne	r18,zero,412e4c <_gp+0xffff3650>
  41302c:	0007883a 	mov	r3,zero
  413030:	0005883a 	mov	r2,zero
  413034:	0021883a 	mov	r16,zero
  413038:	003f9806 	br	412e9c <_gp+0xffff36a0>
  41303c:	01400804 	movi	r5,32
  413040:	290bc83a 	sub	r5,r5,r4
  413044:	414a983a 	sll	r5,r8,r5
  413048:	4110d83a 	srl	r8,r8,r4
  41304c:	2808c03a 	cmpne	r4,r5,zero
  413050:	2208b03a 	or	r4,r4,r8
  413054:	003fa206 	br	412ee0 <_gp+0xffff36e4>
  413058:	18000426 	beq	r3,zero,41306c <__subsf3+0x334>
  41305c:	0084303a 	nor	r2,zero,r2
  413060:	103fed26 	beq	r2,zero,413018 <_gp+0xffff381c>
  413064:	01003fc4 	movi	r4,255
  413068:	393fe81e 	bne	r7,r4,41300c <_gp+0xffff3810>
  41306c:	4007883a 	mov	r3,r8
  413070:	3821883a 	mov	r16,r7
  413074:	3023883a 	mov	r17,r6
  413078:	003f4b06 	br	412da8 <_gp+0xffff35ac>
  41307c:	01403fc4 	movi	r5,255
  413080:	817f941e 	bne	r16,r5,412ed4 <_gp+0xffff36d8>
  413084:	003f4806 	br	412da8 <_gp+0xffff35ac>
  413088:	8000471e 	bne	r16,zero,4131a8 <__subsf3+0x470>
  41308c:	18006126 	beq	r3,zero,413214 <__subsf3+0x4dc>
  413090:	403f4526 	beq	r8,zero,412da8 <_gp+0xffff35ac>
  413094:	1a07883a 	add	r3,r3,r8
  413098:	1881002c 	andhi	r2,r3,1024
  41309c:	103f7c26 	beq	r2,zero,412e90 <_gp+0xffff3694>
  4130a0:	00bf0034 	movhi	r2,64512
  4130a4:	10bfffc4 	addi	r2,r2,-1
  4130a8:	2821883a 	mov	r16,r5
  4130ac:	1886703a 	and	r3,r3,r2
  4130b0:	003f3d06 	br	412da8 <_gp+0xffff35ac>
  4130b4:	8000141e 	bne	r16,zero,413108 <__subsf3+0x3d0>
  4130b8:	1800311e 	bne	r3,zero,413180 <__subsf3+0x448>
  4130bc:	40004626 	beq	r8,zero,4131d8 <__subsf3+0x4a0>
  4130c0:	4007883a 	mov	r3,r8
  4130c4:	3023883a 	mov	r17,r6
  4130c8:	003f3706 	br	412da8 <_gp+0xffff35ac>
  4130cc:	2021883a 	mov	r16,r4
  4130d0:	0007883a 	mov	r3,zero
  4130d4:	003f7106 	br	412e9c <_gp+0xffff36a0>
  4130d8:	8000181e 	bne	r16,zero,41313c <__subsf3+0x404>
  4130dc:	18002f26 	beq	r3,zero,41319c <__subsf3+0x464>
  4130e0:	0108303a 	nor	r4,zero,r4
  4130e4:	20000526 	beq	r4,zero,4130fc <__subsf3+0x3c4>
  4130e8:	01403fc4 	movi	r5,255
  4130ec:	39402b26 	beq	r7,r5,41319c <__subsf3+0x464>
  4130f0:	014006c4 	movi	r5,27
  4130f4:	2900400e 	bge	r5,r4,4131f8 <__subsf3+0x4c0>
  4130f8:	00c00044 	movi	r3,1
  4130fc:	1a07883a 	add	r3,r3,r8
  413100:	3821883a 	mov	r16,r7
  413104:	003f7706 	br	412ee4 <_gp+0xffff36e8>
  413108:	1800111e 	bne	r3,zero,413150 <__subsf3+0x418>
  41310c:	40003526 	beq	r8,zero,4131e4 <__subsf3+0x4ac>
  413110:	4007883a 	mov	r3,r8
  413114:	3023883a 	mov	r17,r6
  413118:	04003fc4 	movi	r16,255
  41311c:	003f2206 	br	412da8 <_gp+0xffff35ac>
  413120:	01000804 	movi	r4,32
  413124:	2089c83a 	sub	r4,r4,r2
  413128:	1908983a 	sll	r4,r3,r4
  41312c:	1884d83a 	srl	r2,r3,r2
  413130:	2006c03a 	cmpne	r3,r4,zero
  413134:	1886b03a 	or	r3,r3,r2
  413138:	003fb706 	br	413018 <_gp+0xffff381c>
  41313c:	01403fc4 	movi	r5,255
  413140:	39401626 	beq	r7,r5,41319c <__subsf3+0x464>
  413144:	0109c83a 	sub	r4,zero,r4
  413148:	18c10034 	orhi	r3,r3,1024
  41314c:	003fe806 	br	4130f0 <_gp+0xffff38f4>
  413150:	40001f26 	beq	r8,zero,4131d0 <__subsf3+0x498>
  413154:	1806d0fa 	srli	r3,r3,3
  413158:	1880102c 	andhi	r2,r3,64
  41315c:	10000526 	beq	r2,zero,413174 <__subsf3+0x43c>
  413160:	4010d0fa 	srli	r8,r8,3
  413164:	4080102c 	andhi	r2,r8,64
  413168:	1000021e 	bne	r2,zero,413174 <__subsf3+0x43c>
  41316c:	4007883a 	mov	r3,r8
  413170:	3023883a 	mov	r17,r6
  413174:	180690fa 	slli	r3,r3,3
  413178:	04003fc4 	movi	r16,255
  41317c:	003f0a06 	br	412da8 <_gp+0xffff35ac>
  413180:	403f0926 	beq	r8,zero,412da8 <_gp+0xffff35ac>
  413184:	1a05c83a 	sub	r2,r3,r8
  413188:	1101002c 	andhi	r4,r2,1024
  41318c:	203f3e26 	beq	r4,zero,412e88 <_gp+0xffff368c>
  413190:	40c7c83a 	sub	r3,r8,r3
  413194:	3023883a 	mov	r17,r6
  413198:	003f0306 	br	412da8 <_gp+0xffff35ac>
  41319c:	4007883a 	mov	r3,r8
  4131a0:	3821883a 	mov	r16,r7
  4131a4:	003f0006 	br	412da8 <_gp+0xffff35ac>
  4131a8:	18001c26 	beq	r3,zero,41321c <__subsf3+0x4e4>
  4131ac:	40000826 	beq	r8,zero,4131d0 <__subsf3+0x498>
  4131b0:	1806d0fa 	srli	r3,r3,3
  4131b4:	1880102c 	andhi	r2,r3,64
  4131b8:	103fee26 	beq	r2,zero,413174 <_gp+0xffff3978>
  4131bc:	4010d0fa 	srli	r8,r8,3
  4131c0:	4080102c 	andhi	r2,r8,64
  4131c4:	103feb1e 	bne	r2,zero,413174 <_gp+0xffff3978>
  4131c8:	4007883a 	mov	r3,r8
  4131cc:	003fe906 	br	413174 <_gp+0xffff3978>
  4131d0:	04003fc4 	movi	r16,255
  4131d4:	003ef406 	br	412da8 <_gp+0xffff35ac>
  4131d8:	8007883a 	mov	r3,r16
  4131dc:	0005883a 	mov	r2,zero
  4131e0:	003f2e06 	br	412e9c <_gp+0xffff36a0>
  4131e4:	00c10034 	movhi	r3,1024
  4131e8:	0005883a 	mov	r2,zero
  4131ec:	18fffe04 	addi	r3,r3,-8
  4131f0:	04003fc4 	movi	r16,255
  4131f4:	003f2906 	br	412e9c <_gp+0xffff36a0>
  4131f8:	01400804 	movi	r5,32
  4131fc:	290bc83a 	sub	r5,r5,r4
  413200:	194a983a 	sll	r5,r3,r5
  413204:	1908d83a 	srl	r4,r3,r4
  413208:	2806c03a 	cmpne	r3,r5,zero
  41320c:	1906b03a 	or	r3,r3,r4
  413210:	003fba06 	br	4130fc <_gp+0xffff3900>
  413214:	4007883a 	mov	r3,r8
  413218:	003ee306 	br	412da8 <_gp+0xffff35ac>
  41321c:	4007883a 	mov	r3,r8
  413220:	04003fc4 	movi	r16,255
  413224:	003ee006 	br	412da8 <_gp+0xffff35ac>
  413228:	0007883a 	mov	r3,zero
  41322c:	0005883a 	mov	r2,zero
  413230:	003f1a06 	br	412e9c <_gp+0xffff36a0>

00413234 <__fixsfsi>:
  413234:	2006d5fa 	srli	r3,r4,23
  413238:	00802034 	movhi	r2,128
  41323c:	10bfffc4 	addi	r2,r2,-1
  413240:	18c03fcc 	andi	r3,r3,255
  413244:	01401f84 	movi	r5,126
  413248:	1104703a 	and	r2,r2,r4
  41324c:	2008d7fa 	srli	r4,r4,31
  413250:	28c0110e 	bge	r5,r3,413298 <__fixsfsi+0x64>
  413254:	01402744 	movi	r5,157
  413258:	28c00b16 	blt	r5,r3,413288 <__fixsfsi+0x54>
  41325c:	01402544 	movi	r5,149
  413260:	10802034 	orhi	r2,r2,128
  413264:	28c00e16 	blt	r5,r3,4132a0 <__fixsfsi+0x6c>
  413268:	01402584 	movi	r5,150
  41326c:	28c7c83a 	sub	r3,r5,r3
  413270:	10c6d83a 	srl	r3,r2,r3
  413274:	21003fcc 	andi	r4,r4,255
  413278:	0105c83a 	sub	r2,zero,r4
  41327c:	1886f03a 	xor	r3,r3,r2
  413280:	1905883a 	add	r2,r3,r4
  413284:	f800283a 	ret
  413288:	00a00034 	movhi	r2,32768
  41328c:	10bfffc4 	addi	r2,r2,-1
  413290:	2085883a 	add	r2,r4,r2
  413294:	f800283a 	ret
  413298:	0005883a 	mov	r2,zero
  41329c:	f800283a 	ret
  4132a0:	18ffda84 	addi	r3,r3,-150
  4132a4:	10c6983a 	sll	r3,r2,r3
  4132a8:	003ff206 	br	413274 <_gp+0xffff3a78>

004132ac <__floatsisf>:
  4132ac:	defffd04 	addi	sp,sp,-12
  4132b0:	dc000015 	stw	r16,0(sp)
  4132b4:	dfc00215 	stw	ra,8(sp)
  4132b8:	dc400115 	stw	r17,4(sp)
  4132bc:	2021883a 	mov	r16,r4
  4132c0:	20003a26 	beq	r4,zero,4133ac <__floatsisf+0x100>
  4132c4:	2022d7fa 	srli	r17,r4,31
  4132c8:	88000126 	beq	r17,zero,4132d0 <__floatsisf+0x24>
  4132cc:	0121c83a 	sub	r16,zero,r4
  4132d0:	8009883a 	mov	r4,r16
  4132d4:	04133e00 	call	4133e0 <__clzsi2>
  4132d8:	00c02784 	movi	r3,158
  4132dc:	1887c83a 	sub	r3,r3,r2
  4132e0:	01802584 	movi	r6,150
  4132e4:	800b883a 	mov	r5,r16
  4132e8:	30c01616 	blt	r6,r3,413344 <__floatsisf+0x98>
  4132ec:	01000204 	movi	r4,8
  4132f0:	2080020e 	bge	r4,r2,4132fc <__floatsisf+0x50>
  4132f4:	10bffe04 	addi	r2,r2,-8
  4132f8:	80a0983a 	sll	r16,r16,r2
  4132fc:	00802034 	movhi	r2,128
  413300:	10bfffc4 	addi	r2,r2,-1
  413304:	8809883a 	mov	r4,r17
  413308:	80a0703a 	and	r16,r16,r2
  41330c:	18803fcc 	andi	r2,r3,255
  413310:	100695fa 	slli	r3,r2,23
  413314:	20803fcc 	andi	r2,r4,255
  413318:	100897fa 	slli	r4,r2,31
  41331c:	00802034 	movhi	r2,128
  413320:	10bfffc4 	addi	r2,r2,-1
  413324:	8084703a 	and	r2,r16,r2
  413328:	10c4b03a 	or	r2,r2,r3
  41332c:	1104b03a 	or	r2,r2,r4
  413330:	dfc00217 	ldw	ra,8(sp)
  413334:	dc400117 	ldw	r17,4(sp)
  413338:	dc000017 	ldw	r16,0(sp)
  41333c:	dec00304 	addi	sp,sp,12
  413340:	f800283a 	ret
  413344:	01002644 	movi	r4,153
  413348:	20c01c16 	blt	r4,r3,4133bc <__floatsisf+0x110>
  41334c:	01000144 	movi	r4,5
  413350:	2080020e 	bge	r4,r2,41335c <__floatsisf+0xb0>
  413354:	113ffec4 	addi	r4,r2,-5
  413358:	290a983a 	sll	r5,r5,r4
  41335c:	043f0034 	movhi	r16,64512
  413360:	843fffc4 	addi	r16,r16,-1
  413364:	298001cc 	andi	r6,r5,7
  413368:	2c20703a 	and	r16,r5,r16
  41336c:	30000426 	beq	r6,zero,413380 <__floatsisf+0xd4>
  413370:	294003cc 	andi	r5,r5,15
  413374:	01000104 	movi	r4,4
  413378:	29000126 	beq	r5,r4,413380 <__floatsisf+0xd4>
  41337c:	8121883a 	add	r16,r16,r4
  413380:	8101002c 	andhi	r4,r16,1024
  413384:	20000526 	beq	r4,zero,41339c <__floatsisf+0xf0>
  413388:	00c027c4 	movi	r3,159
  41338c:	1887c83a 	sub	r3,r3,r2
  413390:	00bf0034 	movhi	r2,64512
  413394:	10bfffc4 	addi	r2,r2,-1
  413398:	80a0703a 	and	r16,r16,r2
  41339c:	802091ba 	slli	r16,r16,6
  4133a0:	8809883a 	mov	r4,r17
  4133a4:	8020d27a 	srli	r16,r16,9
  4133a8:	003fd806 	br	41330c <_gp+0xffff3b10>
  4133ac:	0009883a 	mov	r4,zero
  4133b0:	0007883a 	mov	r3,zero
  4133b4:	0021883a 	mov	r16,zero
  4133b8:	003fd406 	br	41330c <_gp+0xffff3b10>
  4133bc:	01800144 	movi	r6,5
  4133c0:	110006c4 	addi	r4,r2,27
  4133c4:	8108983a 	sll	r4,r16,r4
  4133c8:	308fc83a 	sub	r7,r6,r2
  4133cc:	81cad83a 	srl	r5,r16,r7
  4133d0:	2008c03a 	cmpne	r4,r4,zero
  4133d4:	214ab03a 	or	r5,r4,r5
  4133d8:	30bfe00e 	bge	r6,r2,41335c <_gp+0xffff3b60>
  4133dc:	003fdd06 	br	413354 <_gp+0xffff3b58>

004133e0 <__clzsi2>:
  4133e0:	00bfffd4 	movui	r2,65535
  4133e4:	11000b36 	bltu	r2,r4,413414 <__clzsi2+0x34>
  4133e8:	00803fc4 	movi	r2,255
  4133ec:	1100122e 	bgeu	r2,r4,413438 <__clzsi2+0x58>
  4133f0:	00c00204 	movi	r3,8
  4133f4:	01400604 	movi	r5,24
  4133f8:	20c8d83a 	srl	r4,r4,r3
  4133fc:	00801074 	movhi	r2,65
  413400:	109c9604 	addi	r2,r2,29272
  413404:	1109883a 	add	r4,r2,r4
  413408:	20800003 	ldbu	r2,0(r4)
  41340c:	2885c83a 	sub	r2,r5,r2
  413410:	f800283a 	ret
  413414:	00804034 	movhi	r2,256
  413418:	10bfffc4 	addi	r2,r2,-1
  41341c:	11000336 	bltu	r2,r4,41342c <__clzsi2+0x4c>
  413420:	00c00404 	movi	r3,16
  413424:	180b883a 	mov	r5,r3
  413428:	003ff306 	br	4133f8 <_gp+0xffff3bfc>
  41342c:	00c00604 	movi	r3,24
  413430:	01400204 	movi	r5,8
  413434:	003ff006 	br	4133f8 <_gp+0xffff3bfc>
  413438:	0007883a 	mov	r3,zero
  41343c:	01400804 	movi	r5,32
  413440:	003fed06 	br	4133f8 <_gp+0xffff3bfc>

00413444 <_vsprintf_r>:
  413444:	defff804 	addi	sp,sp,-32
  413448:	00808204 	movi	r2,520
  41344c:	d880000d 	sth	r2,0(sp)
  413450:	00a00034 	movhi	r2,32768
  413454:	10bfffc4 	addi	r2,r2,-1
  413458:	d8800515 	stw	r2,20(sp)
  41345c:	d8800315 	stw	r2,12(sp)
  413460:	00bfffc4 	movi	r2,-1
  413464:	d880008d 	sth	r2,2(sp)
  413468:	00801074 	movhi	r2,65
  41346c:	d9400415 	stw	r5,16(sp)
  413470:	d9400215 	stw	r5,8(sp)
  413474:	108d3104 	addi	r2,r2,13508
  413478:	d80b883a 	mov	r5,sp
  41347c:	dfc00715 	stw	ra,28(sp)
  413480:	d8800115 	stw	r2,4(sp)
  413484:	d8000615 	stw	zero,24(sp)
  413488:	041362c0 	call	41362c <___svfprintf_internal_r>
  41348c:	d8c00417 	ldw	r3,16(sp)
  413490:	18000005 	stb	zero,0(r3)
  413494:	dfc00717 	ldw	ra,28(sp)
  413498:	dec00804 	addi	sp,sp,32
  41349c:	f800283a 	ret

004134a0 <vsprintf>:
  4134a0:	2007883a 	mov	r3,r4
  4134a4:	01001074 	movhi	r4,65
  4134a8:	211e0004 	addi	r4,r4,30720
  4134ac:	21000017 	ldw	r4,0(r4)
  4134b0:	2805883a 	mov	r2,r5
  4134b4:	300f883a 	mov	r7,r6
  4134b8:	180b883a 	mov	r5,r3
  4134bc:	100d883a 	mov	r6,r2
  4134c0:	04134441 	jmpi	413444 <_vsprintf_r>

004134c4 <__sfvwrite_small_str>:
  4134c4:	2880000b 	ldhu	r2,0(r5)
  4134c8:	defffd04 	addi	sp,sp,-12
  4134cc:	dc000015 	stw	r16,0(sp)
  4134d0:	dfc00215 	stw	ra,8(sp)
  4134d4:	dc400115 	stw	r17,4(sp)
  4134d8:	10c0020c 	andi	r3,r2,8
  4134dc:	2821883a 	mov	r16,r5
  4134e0:	18001926 	beq	r3,zero,413548 <__sfvwrite_small_str+0x84>
  4134e4:	28c0008f 	ldh	r3,2(r5)
  4134e8:	1800150e 	bge	r3,zero,413540 <__sfvwrite_small_str+0x7c>
  4134ec:	10c0800c 	andi	r3,r2,512
  4134f0:	18001326 	beq	r3,zero,413540 <__sfvwrite_small_str+0x7c>
  4134f4:	2c400517 	ldw	r17,20(r5)
  4134f8:	89c0030e 	bge	r17,r7,413508 <__sfvwrite_small_str+0x44>
  4134fc:	10c0200c 	andi	r3,r2,128
  413500:	18000326 	beq	r3,zero,413510 <__sfvwrite_small_str+0x4c>
  413504:	00000e06 	br	413540 <__sfvwrite_small_str+0x7c>
  413508:	3c40010e 	bge	r7,r17,413510 <__sfvwrite_small_str+0x4c>
  41350c:	3823883a 	mov	r17,r7
  413510:	81000417 	ldw	r4,16(r16)
  413514:	300b883a 	mov	r5,r6
  413518:	880d883a 	mov	r6,r17
  41351c:	04135600 	call	413560 <memmove>
  413520:	80800517 	ldw	r2,20(r16)
  413524:	1445c83a 	sub	r2,r2,r17
  413528:	80800515 	stw	r2,20(r16)
  41352c:	80800417 	ldw	r2,16(r16)
  413530:	1463883a 	add	r17,r2,r17
  413534:	84400415 	stw	r17,16(r16)
  413538:	0005883a 	mov	r2,zero
  41353c:	00000306 	br	41354c <__sfvwrite_small_str+0x88>
  413540:	10801014 	ori	r2,r2,64
  413544:	8080000d 	sth	r2,0(r16)
  413548:	00bfffc4 	movi	r2,-1
  41354c:	dfc00217 	ldw	ra,8(sp)
  413550:	dc400117 	ldw	r17,4(sp)
  413554:	dc000017 	ldw	r16,0(sp)
  413558:	dec00304 	addi	sp,sp,12
  41355c:	f800283a 	ret

00413560 <memmove>:
  413560:	2005883a 	mov	r2,r4
  413564:	29000d2e 	bgeu	r5,r4,41359c <memmove+0x3c>
  413568:	298f883a 	add	r7,r5,r6
  41356c:	21c00b2e 	bgeu	r4,r7,41359c <memmove+0x3c>
  413570:	3007883a 	mov	r3,r6
  413574:	017fffc4 	movi	r5,-1
  413578:	18ffffc4 	addi	r3,r3,-1
  41357c:	19400626 	beq	r3,r5,413598 <memmove+0x38>
  413580:	1989c83a 	sub	r4,r3,r6
  413584:	3909883a 	add	r4,r7,r4
  413588:	22000003 	ldbu	r8,0(r4)
  41358c:	10c9883a 	add	r4,r2,r3
  413590:	22000005 	stb	r8,0(r4)
  413594:	003ff806 	br	413578 <_gp+0xffff3d7c>
  413598:	f800283a 	ret
  41359c:	0007883a 	mov	r3,zero
  4135a0:	19800626 	beq	r3,r6,4135bc <memmove+0x5c>
  4135a4:	28c9883a 	add	r4,r5,r3
  4135a8:	21c00003 	ldbu	r7,0(r4)
  4135ac:	10c9883a 	add	r4,r2,r3
  4135b0:	18c00044 	addi	r3,r3,1
  4135b4:	21c00005 	stb	r7,0(r4)
  4135b8:	003ff906 	br	4135a0 <_gp+0xffff3da4>
  4135bc:	f800283a 	ret

004135c0 <print_repeat>:
  4135c0:	defffb04 	addi	sp,sp,-20
  4135c4:	dc800315 	stw	r18,12(sp)
  4135c8:	dc400215 	stw	r17,8(sp)
  4135cc:	dc000115 	stw	r16,4(sp)
  4135d0:	dfc00415 	stw	ra,16(sp)
  4135d4:	2025883a 	mov	r18,r4
  4135d8:	2823883a 	mov	r17,r5
  4135dc:	d9800005 	stb	r6,0(sp)
  4135e0:	3821883a 	mov	r16,r7
  4135e4:	04000a0e 	bge	zero,r16,413610 <print_repeat+0x50>
  4135e8:	88800117 	ldw	r2,4(r17)
  4135ec:	9009883a 	mov	r4,r18
  4135f0:	880b883a 	mov	r5,r17
  4135f4:	d80d883a 	mov	r6,sp
  4135f8:	01c00044 	movi	r7,1
  4135fc:	103ee83a 	callr	r2
  413600:	843fffc4 	addi	r16,r16,-1
  413604:	103ff726 	beq	r2,zero,4135e4 <_gp+0xffff3de8>
  413608:	00bfffc4 	movi	r2,-1
  41360c:	00000106 	br	413614 <print_repeat+0x54>
  413610:	0005883a 	mov	r2,zero
  413614:	dfc00417 	ldw	ra,16(sp)
  413618:	dc800317 	ldw	r18,12(sp)
  41361c:	dc400217 	ldw	r17,8(sp)
  413620:	dc000117 	ldw	r16,4(sp)
  413624:	dec00504 	addi	sp,sp,20
  413628:	f800283a 	ret

0041362c <___svfprintf_internal_r>:
  41362c:	deffe304 	addi	sp,sp,-116
  413630:	d8c00804 	addi	r3,sp,32
  413634:	df001b15 	stw	fp,108(sp)
  413638:	ddc01a15 	stw	r23,104(sp)
  41363c:	dd801915 	stw	r22,100(sp)
  413640:	dd401815 	stw	r21,96(sp)
  413644:	dd001715 	stw	r20,92(sp)
  413648:	dcc01615 	stw	r19,88(sp)
  41364c:	dc801515 	stw	r18,84(sp)
  413650:	dc401415 	stw	r17,80(sp)
  413654:	dc001315 	stw	r16,76(sp)
  413658:	dfc01c15 	stw	ra,112(sp)
  41365c:	2029883a 	mov	r20,r4
  413660:	2823883a 	mov	r17,r5
  413664:	3839883a 	mov	fp,r7
  413668:	d9800f15 	stw	r6,60(sp)
  41366c:	0021883a 	mov	r16,zero
  413670:	d8000e15 	stw	zero,56(sp)
  413674:	002f883a 	mov	r23,zero
  413678:	002b883a 	mov	r21,zero
  41367c:	0027883a 	mov	r19,zero
  413680:	0025883a 	mov	r18,zero
  413684:	d8000c15 	stw	zero,48(sp)
  413688:	d8000b15 	stw	zero,44(sp)
  41368c:	002d883a 	mov	r22,zero
  413690:	d8c00915 	stw	r3,36(sp)
  413694:	d8c00f17 	ldw	r3,60(sp)
  413698:	19000003 	ldbu	r4,0(r3)
  41369c:	20803fcc 	andi	r2,r4,255
  4136a0:	1080201c 	xori	r2,r2,128
  4136a4:	10bfe004 	addi	r2,r2,-128
  4136a8:	10012e26 	beq	r2,zero,413b64 <___svfprintf_internal_r+0x538>
  4136ac:	01400044 	movi	r5,1
  4136b0:	b1401426 	beq	r22,r5,413704 <___svfprintf_internal_r+0xd8>
  4136b4:	2d800216 	blt	r5,r22,4136c0 <___svfprintf_internal_r+0x94>
  4136b8:	b0000626 	beq	r22,zero,4136d4 <___svfprintf_internal_r+0xa8>
  4136bc:	00012506 	br	413b54 <___svfprintf_internal_r+0x528>
  4136c0:	01400084 	movi	r5,2
  4136c4:	b1401d26 	beq	r22,r5,41373c <___svfprintf_internal_r+0x110>
  4136c8:	014000c4 	movi	r5,3
  4136cc:	b1402b26 	beq	r22,r5,41377c <___svfprintf_internal_r+0x150>
  4136d0:	00012006 	br	413b54 <___svfprintf_internal_r+0x528>
  4136d4:	01400944 	movi	r5,37
  4136d8:	11410d26 	beq	r2,r5,413b10 <___svfprintf_internal_r+0x4e4>
  4136dc:	88800117 	ldw	r2,4(r17)
  4136e0:	d9000005 	stb	r4,0(sp)
  4136e4:	880b883a 	mov	r5,r17
  4136e8:	a009883a 	mov	r4,r20
  4136ec:	d80d883a 	mov	r6,sp
  4136f0:	01c00044 	movi	r7,1
  4136f4:	103ee83a 	callr	r2
  4136f8:	1000e81e 	bne	r2,zero,413a9c <___svfprintf_internal_r+0x470>
  4136fc:	84000044 	addi	r16,r16,1
  413700:	00011406 	br	413b54 <___svfprintf_internal_r+0x528>
  413704:	01400c04 	movi	r5,48
  413708:	11410a26 	beq	r2,r5,413b34 <___svfprintf_internal_r+0x508>
  41370c:	01400944 	movi	r5,37
  413710:	11400a1e 	bne	r2,r5,41373c <___svfprintf_internal_r+0x110>
  413714:	d8800005 	stb	r2,0(sp)
  413718:	88800117 	ldw	r2,4(r17)
  41371c:	a009883a 	mov	r4,r20
  413720:	880b883a 	mov	r5,r17
  413724:	d80d883a 	mov	r6,sp
  413728:	b00f883a 	mov	r7,r22
  41372c:	103ee83a 	callr	r2
  413730:	1000da1e 	bne	r2,zero,413a9c <___svfprintf_internal_r+0x470>
  413734:	84000044 	addi	r16,r16,1
  413738:	00010506 	br	413b50 <___svfprintf_internal_r+0x524>
  41373c:	25bff404 	addi	r22,r4,-48
  413740:	b5803fcc 	andi	r22,r22,255
  413744:	00c00244 	movi	r3,9
  413748:	1d800936 	bltu	r3,r22,413770 <___svfprintf_internal_r+0x144>
  41374c:	00bfffc4 	movi	r2,-1
  413750:	90800426 	beq	r18,r2,413764 <___svfprintf_internal_r+0x138>
  413754:	9009883a 	mov	r4,r18
  413758:	01400284 	movi	r5,10
  41375c:	04123e00 	call	4123e0 <__mulsi3>
  413760:	00000106 	br	413768 <___svfprintf_internal_r+0x13c>
  413764:	0005883a 	mov	r2,zero
  413768:	15a5883a 	add	r18,r2,r22
  41376c:	0000f206 	br	413b38 <___svfprintf_internal_r+0x50c>
  413770:	01400b84 	movi	r5,46
  413774:	1140f426 	beq	r2,r5,413b48 <___svfprintf_internal_r+0x51c>
  413778:	05800084 	movi	r22,2
  41377c:	213ff404 	addi	r4,r4,-48
  413780:	20c03fcc 	andi	r3,r4,255
  413784:	01000244 	movi	r4,9
  413788:	20c00b36 	bltu	r4,r3,4137b8 <___svfprintf_internal_r+0x18c>
  41378c:	00bfffc4 	movi	r2,-1
  413790:	98800626 	beq	r19,r2,4137ac <___svfprintf_internal_r+0x180>
  413794:	9809883a 	mov	r4,r19
  413798:	01400284 	movi	r5,10
  41379c:	d8c01115 	stw	r3,68(sp)
  4137a0:	04123e00 	call	4123e0 <__mulsi3>
  4137a4:	d8c01117 	ldw	r3,68(sp)
  4137a8:	00000106 	br	4137b0 <___svfprintf_internal_r+0x184>
  4137ac:	0005883a 	mov	r2,zero
  4137b0:	10e7883a 	add	r19,r2,r3
  4137b4:	0000e706 	br	413b54 <___svfprintf_internal_r+0x528>
  4137b8:	01401b04 	movi	r5,108
  4137bc:	1140e026 	beq	r2,r5,413b40 <___svfprintf_internal_r+0x514>
  4137c0:	013fffc4 	movi	r4,-1
  4137c4:	99000226 	beq	r19,r4,4137d0 <___svfprintf_internal_r+0x1a4>
  4137c8:	d8000b15 	stw	zero,44(sp)
  4137cc:	00000106 	br	4137d4 <___svfprintf_internal_r+0x1a8>
  4137d0:	04c00044 	movi	r19,1
  4137d4:	01001a44 	movi	r4,105
  4137d8:	11001626 	beq	r2,r4,413834 <___svfprintf_internal_r+0x208>
  4137dc:	20800916 	blt	r4,r2,413804 <___svfprintf_internal_r+0x1d8>
  4137e0:	010018c4 	movi	r4,99
  4137e4:	11009626 	beq	r2,r4,413a40 <___svfprintf_internal_r+0x414>
  4137e8:	01001904 	movi	r4,100
  4137ec:	11001126 	beq	r2,r4,413834 <___svfprintf_internal_r+0x208>
  4137f0:	01001604 	movi	r4,88
  4137f4:	1100d61e 	bne	r2,r4,413b50 <___svfprintf_internal_r+0x524>
  4137f8:	00c00044 	movi	r3,1
  4137fc:	d8c00e15 	stw	r3,56(sp)
  413800:	00001406 	br	413854 <___svfprintf_internal_r+0x228>
  413804:	01001cc4 	movi	r4,115
  413808:	1100a626 	beq	r2,r4,413aa4 <___svfprintf_internal_r+0x478>
  41380c:	20800416 	blt	r4,r2,413820 <___svfprintf_internal_r+0x1f4>
  413810:	01001bc4 	movi	r4,111
  413814:	1100ce1e 	bne	r2,r4,413b50 <___svfprintf_internal_r+0x524>
  413818:	05400204 	movi	r21,8
  41381c:	00000e06 	br	413858 <___svfprintf_internal_r+0x22c>
  413820:	01001d44 	movi	r4,117
  413824:	11000c26 	beq	r2,r4,413858 <___svfprintf_internal_r+0x22c>
  413828:	01001e04 	movi	r4,120
  41382c:	11000926 	beq	r2,r4,413854 <___svfprintf_internal_r+0x228>
  413830:	0000c706 	br	413b50 <___svfprintf_internal_r+0x524>
  413834:	e0800104 	addi	r2,fp,4
  413838:	b8000726 	beq	r23,zero,413858 <___svfprintf_internal_r+0x22c>
  41383c:	d8800d15 	stw	r2,52(sp)
  413840:	e7000017 	ldw	fp,0(fp)
  413844:	e000080e 	bge	fp,zero,413868 <___svfprintf_internal_r+0x23c>
  413848:	0739c83a 	sub	fp,zero,fp
  41384c:	02000044 	movi	r8,1
  413850:	00000606 	br	41386c <___svfprintf_internal_r+0x240>
  413854:	05400404 	movi	r21,16
  413858:	e0c00104 	addi	r3,fp,4
  41385c:	d8c00d15 	stw	r3,52(sp)
  413860:	e7000017 	ldw	fp,0(fp)
  413864:	002f883a 	mov	r23,zero
  413868:	0011883a 	mov	r8,zero
  41386c:	002d883a 	mov	r22,zero
  413870:	dd87883a 	add	r3,sp,r22
  413874:	e0001a26 	beq	fp,zero,4138e0 <___svfprintf_internal_r+0x2b4>
  413878:	e009883a 	mov	r4,fp
  41387c:	a80b883a 	mov	r5,r21
  413880:	d8c01115 	stw	r3,68(sp)
  413884:	da001215 	stw	r8,72(sp)
  413888:	04123d00 	call	4123d0 <__udivsi3>
  41388c:	a809883a 	mov	r4,r21
  413890:	100b883a 	mov	r5,r2
  413894:	d8801015 	stw	r2,64(sp)
  413898:	04123e00 	call	4123e0 <__mulsi3>
  41389c:	e085c83a 	sub	r2,fp,r2
  4138a0:	01000244 	movi	r4,9
  4138a4:	d8c01117 	ldw	r3,68(sp)
  4138a8:	d9801017 	ldw	r6,64(sp)
  4138ac:	da001217 	ldw	r8,72(sp)
  4138b0:	20800216 	blt	r4,r2,4138bc <___svfprintf_internal_r+0x290>
  4138b4:	17000c04 	addi	fp,r2,48
  4138b8:	00000506 	br	4138d0 <___svfprintf_internal_r+0x2a4>
  4138bc:	d9400e17 	ldw	r5,56(sp)
  4138c0:	28000226 	beq	r5,zero,4138cc <___svfprintf_internal_r+0x2a0>
  4138c4:	17000dc4 	addi	fp,r2,55
  4138c8:	00000106 	br	4138d0 <___svfprintf_internal_r+0x2a4>
  4138cc:	170015c4 	addi	fp,r2,87
  4138d0:	1f000005 	stb	fp,0(r3)
  4138d4:	b5800044 	addi	r22,r22,1
  4138d8:	3039883a 	mov	fp,r6
  4138dc:	003fe406 	br	413870 <_gp+0xffff4074>
  4138e0:	1ec5c83a 	sub	r2,r3,sp
  4138e4:	d8800a15 	stw	r2,40(sp)
  4138e8:	9885c83a 	sub	r2,r19,r2
  4138ec:	1839883a 	mov	fp,r3
  4138f0:	00800e0e 	bge	zero,r2,41392c <___svfprintf_internal_r+0x300>
  4138f4:	182d883a 	mov	r22,r3
  4138f8:	1885883a 	add	r2,r3,r2
  4138fc:	01000c04 	movi	r4,48
  413900:	d9400917 	ldw	r5,36(sp)
  413904:	b007883a 	mov	r3,r22
  413908:	b140052e 	bgeu	r22,r5,413920 <___svfprintf_internal_r+0x2f4>
  41390c:	b5800044 	addi	r22,r22,1
  413910:	19000005 	stb	r4,0(r3)
  413914:	b039883a 	mov	fp,r22
  413918:	b0bff91e 	bne	r22,r2,413900 <_gp+0xffff4104>
  41391c:	00000106 	br	413924 <___svfprintf_internal_r+0x2f8>
  413920:	b039883a 	mov	fp,r22
  413924:	b6edc83a 	sub	r22,r22,sp
  413928:	dd800a15 	stw	r22,40(sp)
  41392c:	d8800a17 	ldw	r2,40(sp)
  413930:	1207883a 	add	r3,r2,r8
  413934:	90edc83a 	sub	r22,r18,r3
  413938:	d8c00b17 	ldw	r3,44(sp)
  41393c:	18001726 	beq	r3,zero,41399c <___svfprintf_internal_r+0x370>
  413940:	40000a26 	beq	r8,zero,41396c <___svfprintf_internal_r+0x340>
  413944:	00800b44 	movi	r2,45
  413948:	d8800805 	stb	r2,32(sp)
  41394c:	88800117 	ldw	r2,4(r17)
  413950:	a009883a 	mov	r4,r20
  413954:	880b883a 	mov	r5,r17
  413958:	d9800804 	addi	r6,sp,32
  41395c:	01c00044 	movi	r7,1
  413960:	103ee83a 	callr	r2
  413964:	10004d1e 	bne	r2,zero,413a9c <___svfprintf_internal_r+0x470>
  413968:	84000044 	addi	r16,r16,1
  41396c:	0580070e 	bge	zero,r22,41398c <___svfprintf_internal_r+0x360>
  413970:	a009883a 	mov	r4,r20
  413974:	880b883a 	mov	r5,r17
  413978:	01800c04 	movi	r6,48
  41397c:	b00f883a 	mov	r7,r22
  413980:	04135c00 	call	4135c0 <print_repeat>
  413984:	1000451e 	bne	r2,zero,413a9c <___svfprintf_internal_r+0x470>
  413988:	85a1883a 	add	r16,r16,r22
  41398c:	d9000a17 	ldw	r4,40(sp)
  413990:	e007883a 	mov	r3,fp
  413994:	272dc83a 	sub	r22,r4,fp
  413998:	00002206 	br	413a24 <___svfprintf_internal_r+0x3f8>
  41399c:	0580090e 	bge	zero,r22,4139c4 <___svfprintf_internal_r+0x398>
  4139a0:	a009883a 	mov	r4,r20
  4139a4:	880b883a 	mov	r5,r17
  4139a8:	01800804 	movi	r6,32
  4139ac:	b00f883a 	mov	r7,r22
  4139b0:	da001215 	stw	r8,72(sp)
  4139b4:	04135c00 	call	4135c0 <print_repeat>
  4139b8:	da001217 	ldw	r8,72(sp)
  4139bc:	1000371e 	bne	r2,zero,413a9c <___svfprintf_internal_r+0x470>
  4139c0:	85a1883a 	add	r16,r16,r22
  4139c4:	403ff126 	beq	r8,zero,41398c <_gp+0xffff4190>
  4139c8:	00800b44 	movi	r2,45
  4139cc:	d8800805 	stb	r2,32(sp)
  4139d0:	88800117 	ldw	r2,4(r17)
  4139d4:	a009883a 	mov	r4,r20
  4139d8:	880b883a 	mov	r5,r17
  4139dc:	d9800804 	addi	r6,sp,32
  4139e0:	01c00044 	movi	r7,1
  4139e4:	103ee83a 	callr	r2
  4139e8:	10002c1e 	bne	r2,zero,413a9c <___svfprintf_internal_r+0x470>
  4139ec:	84000044 	addi	r16,r16,1
  4139f0:	003fe606 	br	41398c <_gp+0xffff4190>
  4139f4:	18ffffc4 	addi	r3,r3,-1
  4139f8:	18800003 	ldbu	r2,0(r3)
  4139fc:	a009883a 	mov	r4,r20
  413a00:	d8c01115 	stw	r3,68(sp)
  413a04:	d8800805 	stb	r2,32(sp)
  413a08:	88800117 	ldw	r2,4(r17)
  413a0c:	880b883a 	mov	r5,r17
  413a10:	d9800804 	addi	r6,sp,32
  413a14:	01c00044 	movi	r7,1
  413a18:	103ee83a 	callr	r2
  413a1c:	d8c01117 	ldw	r3,68(sp)
  413a20:	10001e1e 	bne	r2,zero,413a9c <___svfprintf_internal_r+0x470>
  413a24:	80c5c83a 	sub	r2,r16,r3
  413a28:	1d89883a 	add	r4,r3,r22
  413a2c:	e085883a 	add	r2,fp,r2
  413a30:	013ff016 	blt	zero,r4,4139f4 <_gp+0xffff41f8>
  413a34:	1021883a 	mov	r16,r2
  413a38:	df000d17 	ldw	fp,52(sp)
  413a3c:	00004406 	br	413b50 <___svfprintf_internal_r+0x524>
  413a40:	01000044 	movi	r4,1
  413a44:	2480080e 	bge	r4,r18,413a68 <___svfprintf_internal_r+0x43c>
  413a48:	95bfffc4 	addi	r22,r18,-1
  413a4c:	a009883a 	mov	r4,r20
  413a50:	880b883a 	mov	r5,r17
  413a54:	01800804 	movi	r6,32
  413a58:	b00f883a 	mov	r7,r22
  413a5c:	04135c00 	call	4135c0 <print_repeat>
  413a60:	10000e1e 	bne	r2,zero,413a9c <___svfprintf_internal_r+0x470>
  413a64:	85a1883a 	add	r16,r16,r22
  413a68:	e0800017 	ldw	r2,0(fp)
  413a6c:	a009883a 	mov	r4,r20
  413a70:	880b883a 	mov	r5,r17
  413a74:	d8800005 	stb	r2,0(sp)
  413a78:	88800117 	ldw	r2,4(r17)
  413a7c:	d80d883a 	mov	r6,sp
  413a80:	01c00044 	movi	r7,1
  413a84:	e5800104 	addi	r22,fp,4
  413a88:	103ee83a 	callr	r2
  413a8c:	1000031e 	bne	r2,zero,413a9c <___svfprintf_internal_r+0x470>
  413a90:	84000044 	addi	r16,r16,1
  413a94:	b039883a 	mov	fp,r22
  413a98:	00002d06 	br	413b50 <___svfprintf_internal_r+0x524>
  413a9c:	00bfffc4 	movi	r2,-1
  413aa0:	00003106 	br	413b68 <___svfprintf_internal_r+0x53c>
  413aa4:	e5800017 	ldw	r22,0(fp)
  413aa8:	e0c00104 	addi	r3,fp,4
  413aac:	d8c00a15 	stw	r3,40(sp)
  413ab0:	b009883a 	mov	r4,r22
  413ab4:	0413bbc0 	call	413bbc <strlen>
  413ab8:	9091c83a 	sub	r8,r18,r2
  413abc:	1039883a 	mov	fp,r2
  413ac0:	0200090e 	bge	zero,r8,413ae8 <___svfprintf_internal_r+0x4bc>
  413ac4:	400f883a 	mov	r7,r8
  413ac8:	a009883a 	mov	r4,r20
  413acc:	880b883a 	mov	r5,r17
  413ad0:	01800804 	movi	r6,32
  413ad4:	da001215 	stw	r8,72(sp)
  413ad8:	04135c00 	call	4135c0 <print_repeat>
  413adc:	da001217 	ldw	r8,72(sp)
  413ae0:	103fee1e 	bne	r2,zero,413a9c <_gp+0xffff42a0>
  413ae4:	8221883a 	add	r16,r16,r8
  413ae8:	88800117 	ldw	r2,4(r17)
  413aec:	a009883a 	mov	r4,r20
  413af0:	880b883a 	mov	r5,r17
  413af4:	b00d883a 	mov	r6,r22
  413af8:	e00f883a 	mov	r7,fp
  413afc:	103ee83a 	callr	r2
  413b00:	103fe61e 	bne	r2,zero,413a9c <_gp+0xffff42a0>
  413b04:	8721883a 	add	r16,r16,fp
  413b08:	df000a17 	ldw	fp,40(sp)
  413b0c:	00001006 	br	413b50 <___svfprintf_internal_r+0x524>
  413b10:	05c00044 	movi	r23,1
  413b14:	04ffffc4 	movi	r19,-1
  413b18:	d8000e15 	stw	zero,56(sp)
  413b1c:	05400284 	movi	r21,10
  413b20:	9825883a 	mov	r18,r19
  413b24:	d8000c15 	stw	zero,48(sp)
  413b28:	d8000b15 	stw	zero,44(sp)
  413b2c:	b82d883a 	mov	r22,r23
  413b30:	00000806 	br	413b54 <___svfprintf_internal_r+0x528>
  413b34:	dd800b15 	stw	r22,44(sp)
  413b38:	05800084 	movi	r22,2
  413b3c:	00000506 	br	413b54 <___svfprintf_internal_r+0x528>
  413b40:	00c00044 	movi	r3,1
  413b44:	d8c00c15 	stw	r3,48(sp)
  413b48:	058000c4 	movi	r22,3
  413b4c:	00000106 	br	413b54 <___svfprintf_internal_r+0x528>
  413b50:	002d883a 	mov	r22,zero
  413b54:	d8c00f17 	ldw	r3,60(sp)
  413b58:	18c00044 	addi	r3,r3,1
  413b5c:	d8c00f15 	stw	r3,60(sp)
  413b60:	003ecc06 	br	413694 <_gp+0xffff3e98>
  413b64:	8005883a 	mov	r2,r16
  413b68:	dfc01c17 	ldw	ra,112(sp)
  413b6c:	df001b17 	ldw	fp,108(sp)
  413b70:	ddc01a17 	ldw	r23,104(sp)
  413b74:	dd801917 	ldw	r22,100(sp)
  413b78:	dd401817 	ldw	r21,96(sp)
  413b7c:	dd001717 	ldw	r20,92(sp)
  413b80:	dcc01617 	ldw	r19,88(sp)
  413b84:	dc801517 	ldw	r18,84(sp)
  413b88:	dc401417 	ldw	r17,80(sp)
  413b8c:	dc001317 	ldw	r16,76(sp)
  413b90:	dec01d04 	addi	sp,sp,116
  413b94:	f800283a 	ret

00413b98 <__vfprintf_internal_unused>:
  413b98:	2007883a 	mov	r3,r4
  413b9c:	01001074 	movhi	r4,65
  413ba0:	211e0004 	addi	r4,r4,30720
  413ba4:	21000017 	ldw	r4,0(r4)
  413ba8:	2805883a 	mov	r2,r5
  413bac:	300f883a 	mov	r7,r6
  413bb0:	180b883a 	mov	r5,r3
  413bb4:	100d883a 	mov	r6,r2
  413bb8:	041362c1 	jmpi	41362c <___svfprintf_internal_r>

00413bbc <strlen>:
  413bbc:	2005883a 	mov	r2,r4
  413bc0:	10c00007 	ldb	r3,0(r2)
  413bc4:	18000226 	beq	r3,zero,413bd0 <strlen+0x14>
  413bc8:	10800044 	addi	r2,r2,1
  413bcc:	003ffc06 	br	413bc0 <_gp+0xffff43c4>
  413bd0:	1105c83a 	sub	r2,r2,r4
  413bd4:	f800283a 	ret

00413bd8 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  413bd8:	defff904 	addi	sp,sp,-28
  413bdc:	dfc00615 	stw	ra,24(sp)
  413be0:	df000515 	stw	fp,20(sp)
  413be4:	df000504 	addi	fp,sp,20
  413be8:	e13ffc15 	stw	r4,-16(fp)
  413bec:	e17ffd15 	stw	r5,-12(fp)
  413bf0:	e1bffe15 	stw	r6,-8(fp)
  413bf4:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  413bf8:	e0800217 	ldw	r2,8(fp)
  413bfc:	d8800015 	stw	r2,0(sp)
  413c00:	e13ffc17 	ldw	r4,-16(fp)
  413c04:	e17ffd17 	ldw	r5,-12(fp)
  413c08:	e1bffe17 	ldw	r6,-8(fp)
  413c0c:	e1ffff17 	ldw	r7,-4(fp)
  413c10:	0413db80 	call	413db8 <alt_iic_isr_register>
}  
  413c14:	e037883a 	mov	sp,fp
  413c18:	dfc00117 	ldw	ra,4(sp)
  413c1c:	df000017 	ldw	fp,0(sp)
  413c20:	dec00204 	addi	sp,sp,8
  413c24:	f800283a 	ret

00413c28 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  413c28:	defff904 	addi	sp,sp,-28
  413c2c:	df000615 	stw	fp,24(sp)
  413c30:	df000604 	addi	fp,sp,24
  413c34:	e13ffe15 	stw	r4,-8(fp)
  413c38:	e17fff15 	stw	r5,-4(fp)
  413c3c:	e0bfff17 	ldw	r2,-4(fp)
  413c40:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  413c44:	0005303a 	rdctl	r2,status
  413c48:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  413c4c:	e0fffb17 	ldw	r3,-20(fp)
  413c50:	00bfff84 	movi	r2,-2
  413c54:	1884703a 	and	r2,r3,r2
  413c58:	1001703a 	wrctl	status,r2
  
  return context;
  413c5c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  413c60:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  413c64:	e0bffa17 	ldw	r2,-24(fp)
  413c68:	00c00044 	movi	r3,1
  413c6c:	1884983a 	sll	r2,r3,r2
  413c70:	1007883a 	mov	r3,r2
  413c74:	00801074 	movhi	r2,65
  413c78:	109f3304 	addi	r2,r2,31948
  413c7c:	10800017 	ldw	r2,0(r2)
  413c80:	1886b03a 	or	r3,r3,r2
  413c84:	00801074 	movhi	r2,65
  413c88:	109f3304 	addi	r2,r2,31948
  413c8c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  413c90:	00801074 	movhi	r2,65
  413c94:	109f3304 	addi	r2,r2,31948
  413c98:	10800017 	ldw	r2,0(r2)
  413c9c:	100170fa 	wrctl	ienable,r2
  413ca0:	e0bffc17 	ldw	r2,-16(fp)
  413ca4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  413ca8:	e0bffd17 	ldw	r2,-12(fp)
  413cac:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  413cb0:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
  413cb4:	0001883a 	nop
}
  413cb8:	e037883a 	mov	sp,fp
  413cbc:	df000017 	ldw	fp,0(sp)
  413cc0:	dec00104 	addi	sp,sp,4
  413cc4:	f800283a 	ret

00413cc8 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  413cc8:	defff904 	addi	sp,sp,-28
  413ccc:	df000615 	stw	fp,24(sp)
  413cd0:	df000604 	addi	fp,sp,24
  413cd4:	e13ffe15 	stw	r4,-8(fp)
  413cd8:	e17fff15 	stw	r5,-4(fp)
  413cdc:	e0bfff17 	ldw	r2,-4(fp)
  413ce0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  413ce4:	0005303a 	rdctl	r2,status
  413ce8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  413cec:	e0fffb17 	ldw	r3,-20(fp)
  413cf0:	00bfff84 	movi	r2,-2
  413cf4:	1884703a 	and	r2,r3,r2
  413cf8:	1001703a 	wrctl	status,r2
  
  return context;
  413cfc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  413d00:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  413d04:	e0bffa17 	ldw	r2,-24(fp)
  413d08:	00c00044 	movi	r3,1
  413d0c:	1884983a 	sll	r2,r3,r2
  413d10:	0084303a 	nor	r2,zero,r2
  413d14:	1007883a 	mov	r3,r2
  413d18:	00801074 	movhi	r2,65
  413d1c:	109f3304 	addi	r2,r2,31948
  413d20:	10800017 	ldw	r2,0(r2)
  413d24:	1886703a 	and	r3,r3,r2
  413d28:	00801074 	movhi	r2,65
  413d2c:	109f3304 	addi	r2,r2,31948
  413d30:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  413d34:	00801074 	movhi	r2,65
  413d38:	109f3304 	addi	r2,r2,31948
  413d3c:	10800017 	ldw	r2,0(r2)
  413d40:	100170fa 	wrctl	ienable,r2
  413d44:	e0bffc17 	ldw	r2,-16(fp)
  413d48:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  413d4c:	e0bffd17 	ldw	r2,-12(fp)
  413d50:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  413d54:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
  413d58:	0001883a 	nop
}
  413d5c:	e037883a 	mov	sp,fp
  413d60:	df000017 	ldw	fp,0(sp)
  413d64:	dec00104 	addi	sp,sp,4
  413d68:	f800283a 	ret

00413d6c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  413d6c:	defffc04 	addi	sp,sp,-16
  413d70:	df000315 	stw	fp,12(sp)
  413d74:	df000304 	addi	fp,sp,12
  413d78:	e13ffe15 	stw	r4,-8(fp)
  413d7c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  413d80:	000530fa 	rdctl	r2,ienable
  413d84:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  413d88:	e0bfff17 	ldw	r2,-4(fp)
  413d8c:	00c00044 	movi	r3,1
  413d90:	1884983a 	sll	r2,r3,r2
  413d94:	1007883a 	mov	r3,r2
  413d98:	e0bffd17 	ldw	r2,-12(fp)
  413d9c:	1884703a 	and	r2,r3,r2
  413da0:	1004c03a 	cmpne	r2,r2,zero
  413da4:	10803fcc 	andi	r2,r2,255
}
  413da8:	e037883a 	mov	sp,fp
  413dac:	df000017 	ldw	fp,0(sp)
  413db0:	dec00104 	addi	sp,sp,4
  413db4:	f800283a 	ret

00413db8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  413db8:	defff504 	addi	sp,sp,-44
  413dbc:	dfc00a15 	stw	ra,40(sp)
  413dc0:	df000915 	stw	fp,36(sp)
  413dc4:	df000904 	addi	fp,sp,36
  413dc8:	e13ffc15 	stw	r4,-16(fp)
  413dcc:	e17ffd15 	stw	r5,-12(fp)
  413dd0:	e1bffe15 	stw	r6,-8(fp)
  413dd4:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  413dd8:	00bffa84 	movi	r2,-22
  413ddc:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  413de0:	e0bffd17 	ldw	r2,-12(fp)
  413de4:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  413de8:	e0bff817 	ldw	r2,-32(fp)
  413dec:	10800808 	cmpgei	r2,r2,32
  413df0:	1000271e 	bne	r2,zero,413e90 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  413df4:	0005303a 	rdctl	r2,status
  413df8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  413dfc:	e0fffa17 	ldw	r3,-24(fp)
  413e00:	00bfff84 	movi	r2,-2
  413e04:	1884703a 	and	r2,r3,r2
  413e08:	1001703a 	wrctl	status,r2
  
  return context;
  413e0c:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  413e10:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  413e14:	00801074 	movhi	r2,65
  413e18:	109fe704 	addi	r2,r2,32668
  413e1c:	e0fff817 	ldw	r3,-32(fp)
  413e20:	180690fa 	slli	r3,r3,3
  413e24:	10c5883a 	add	r2,r2,r3
  413e28:	e0fffe17 	ldw	r3,-8(fp)
  413e2c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  413e30:	00801074 	movhi	r2,65
  413e34:	109fe704 	addi	r2,r2,32668
  413e38:	e0fff817 	ldw	r3,-32(fp)
  413e3c:	180690fa 	slli	r3,r3,3
  413e40:	18c00104 	addi	r3,r3,4
  413e44:	10c5883a 	add	r2,r2,r3
  413e48:	e0ffff17 	ldw	r3,-4(fp)
  413e4c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  413e50:	e0bffe17 	ldw	r2,-8(fp)
  413e54:	10000526 	beq	r2,zero,413e6c <alt_iic_isr_register+0xb4>
  413e58:	e0bff817 	ldw	r2,-32(fp)
  413e5c:	e13ffc17 	ldw	r4,-16(fp)
  413e60:	100b883a 	mov	r5,r2
  413e64:	0413c280 	call	413c28 <alt_ic_irq_enable>
  413e68:	00000406 	br	413e7c <alt_iic_isr_register+0xc4>
  413e6c:	e0bff817 	ldw	r2,-32(fp)
  413e70:	e13ffc17 	ldw	r4,-16(fp)
  413e74:	100b883a 	mov	r5,r2
  413e78:	0413cc80 	call	413cc8 <alt_ic_irq_disable>
  413e7c:	e0bff715 	stw	r2,-36(fp)
  413e80:	e0bff917 	ldw	r2,-28(fp)
  413e84:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  413e88:	e0bffb17 	ldw	r2,-20(fp)
  413e8c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  413e90:	e0bff717 	ldw	r2,-36(fp)
}
  413e94:	e037883a 	mov	sp,fp
  413e98:	dfc00117 	ldw	ra,4(sp)
  413e9c:	df000017 	ldw	fp,0(sp)
  413ea0:	dec00204 	addi	sp,sp,8
  413ea4:	f800283a 	ret

00413ea8 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  413ea8:	defffc04 	addi	sp,sp,-16
  413eac:	df000315 	stw	fp,12(sp)
  413eb0:	df000304 	addi	fp,sp,12
  413eb4:	e13ffd15 	stw	r4,-12(fp)
  413eb8:	e17ffe15 	stw	r5,-8(fp)
  413ebc:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  413ec0:	e0fffe17 	ldw	r3,-8(fp)
  413ec4:	e0bffd17 	ldw	r2,-12(fp)
  413ec8:	18800c26 	beq	r3,r2,413efc <alt_load_section+0x54>
  {
    while( to != end )
  413ecc:	00000806 	br	413ef0 <alt_load_section+0x48>
    {
      *to++ = *from++;
  413ed0:	e0bffe17 	ldw	r2,-8(fp)
  413ed4:	10c00104 	addi	r3,r2,4
  413ed8:	e0fffe15 	stw	r3,-8(fp)
  413edc:	e0fffd17 	ldw	r3,-12(fp)
  413ee0:	19000104 	addi	r4,r3,4
  413ee4:	e13ffd15 	stw	r4,-12(fp)
  413ee8:	18c00017 	ldw	r3,0(r3)
  413eec:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  413ef0:	e0fffe17 	ldw	r3,-8(fp)
  413ef4:	e0bfff17 	ldw	r2,-4(fp)
  413ef8:	18bff51e 	bne	r3,r2,413ed0 <_gp+0xffff46d4>
    {
      *to++ = *from++;
    }
  }
}
  413efc:	e037883a 	mov	sp,fp
  413f00:	df000017 	ldw	fp,0(sp)
  413f04:	dec00104 	addi	sp,sp,4
  413f08:	f800283a 	ret

00413f0c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  413f0c:	defffe04 	addi	sp,sp,-8
  413f10:	dfc00115 	stw	ra,4(sp)
  413f14:	df000015 	stw	fp,0(sp)
  413f18:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  413f1c:	01001074 	movhi	r4,65
  413f20:	211e0c04 	addi	r4,r4,30768
  413f24:	01401074 	movhi	r5,65
  413f28:	295cee04 	addi	r5,r5,29624
  413f2c:	01801074 	movhi	r6,65
  413f30:	319e0c04 	addi	r6,r6,30768
  413f34:	0413ea80 	call	413ea8 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  413f38:	01001074 	movhi	r4,65
  413f3c:	21000804 	addi	r4,r4,32
  413f40:	01401074 	movhi	r5,65
  413f44:	29400804 	addi	r5,r5,32
  413f48:	01801074 	movhi	r6,65
  413f4c:	31808b04 	addi	r6,r6,556
  413f50:	0413ea80 	call	413ea8 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  413f54:	01001074 	movhi	r4,65
  413f58:	211c9604 	addi	r4,r4,29272
  413f5c:	01401074 	movhi	r5,65
  413f60:	295c9604 	addi	r5,r5,29272
  413f64:	01801074 	movhi	r6,65
  413f68:	319cee04 	addi	r6,r6,29624
  413f6c:	0413ea80 	call	413ea8 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  413f70:	04160bc0 	call	4160bc <alt_dcache_flush_all>
  alt_icache_flush_all();
  413f74:	04163680 	call	416368 <alt_icache_flush_all>
}
  413f78:	e037883a 	mov	sp,fp
  413f7c:	dfc00117 	ldw	ra,4(sp)
  413f80:	df000017 	ldw	fp,0(sp)
  413f84:	dec00204 	addi	sp,sp,8
  413f88:	f800283a 	ret

00413f8c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  413f8c:	defffd04 	addi	sp,sp,-12
  413f90:	dfc00215 	stw	ra,8(sp)
  413f94:	df000115 	stw	fp,4(sp)
  413f98:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  413f9c:	0009883a 	mov	r4,zero
  413fa0:	041403c0 	call	41403c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  413fa4:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  413fa8:	04140700 	call	414070 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  413fac:	01001074 	movhi	r4,65
  413fb0:	211cd604 	addi	r4,r4,29528
  413fb4:	01401074 	movhi	r5,65
  413fb8:	295cd604 	addi	r5,r5,29528
  413fbc:	01801074 	movhi	r6,65
  413fc0:	319cd604 	addi	r6,r6,29528
  413fc4:	04165000 	call	416500 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  413fc8:	04161f80 	call	4161f8 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  413fcc:	01001074 	movhi	r4,65
  413fd0:	21189504 	addi	r4,r4,25172
  413fd4:	0416ed40 	call	416ed4 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  413fd8:	d1213517 	ldw	r4,-31532(gp)
  413fdc:	d0e13617 	ldw	r3,-31528(gp)
  413fe0:	d0a13717 	ldw	r2,-31524(gp)
  413fe4:	180b883a 	mov	r5,r3
  413fe8:	100d883a 	mov	r6,r2
  413fec:	04121000 	call	412100 <main>
  413ff0:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  413ff4:	01000044 	movi	r4,1
  413ff8:	0415fe40 	call	415fe4 <close>
  exit (result);
  413ffc:	e13fff17 	ldw	r4,-4(fp)
  414000:	0416ee80 	call	416ee8 <exit>

00414004 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  414004:	defffd04 	addi	sp,sp,-12
  414008:	dfc00215 	stw	ra,8(sp)
  41400c:	df000115 	stw	fp,4(sp)
  414010:	df000104 	addi	fp,sp,4
  414014:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  414018:	e13fff17 	ldw	r4,-4(fp)
  41401c:	01401074 	movhi	r5,65
  414020:	295e0404 	addi	r5,r5,30736
  414024:	04161540 	call	416154 <alt_dev_llist_insert>
}
  414028:	e037883a 	mov	sp,fp
  41402c:	dfc00117 	ldw	ra,4(sp)
  414030:	df000017 	ldw	fp,0(sp)
  414034:	dec00204 	addi	sp,sp,8
  414038:	f800283a 	ret

0041403c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  41403c:	defffd04 	addi	sp,sp,-12
  414040:	dfc00215 	stw	ra,8(sp)
  414044:	df000115 	stw	fp,4(sp)
  414048:	df000104 	addi	fp,sp,4
  41404c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
  414050:	0416a380 	call	416a38 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  414054:	00800044 	movi	r2,1
  414058:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  41405c:	e037883a 	mov	sp,fp
  414060:	dfc00117 	ldw	ra,4(sp)
  414064:	df000017 	ldw	fp,0(sp)
  414068:	dec00204 	addi	sp,sp,8
  41406c:	f800283a 	ret

00414070 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  414070:	defffe04 	addi	sp,sp,-8
  414074:	dfc00115 	stw	ra,4(sp)
  414078:	df000015 	stw	fp,0(sp)
  41407c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_MS, timer_ms);
  414080:	010010b4 	movhi	r4,66
  414084:	21062804 	addi	r4,r4,6304
  414088:	000b883a 	mov	r5,zero
  41408c:	018000c4 	movi	r6,3
  414090:	01c0fa04 	movi	r7,1000
  414094:	0414eb00 	call	414eb0 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_US, timer_us);
  414098:	00801074 	movhi	r2,65
  41409c:	109f3704 	addi	r2,r2,31964
  4140a0:	00c010b4 	movhi	r3,66
  4140a4:	18c63004 	addi	r3,r3,6336
  4140a8:	10c00015 	stw	r3,0(r2)
  4140ac:	00801074 	movhi	r2,65
  4140b0:	109f3804 	addi	r2,r2,31968
  4140b4:	00c003f4 	movhi	r3,15
  4140b8:	18d09004 	addi	r3,r3,16960
  4140bc:	10c00015 	stw	r3,0(r2)
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS_FLASH_CONTROLLER_0, epcs_flash_controller_0);
  4140c0:	01001074 	movhi	r4,65
  4140c4:	211d2604 	addi	r4,r4,29848
  4140c8:	04141440 	call	414144 <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
  4140cc:	01001074 	movhi	r4,65
  4140d0:	211d5904 	addi	r4,r4,30052
  4140d4:	04140040 	call	414004 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
  4140d8:	01001074 	movhi	r4,65
  4140dc:	211d6e04 	addi	r4,r4,30136
  4140e0:	000b883a 	mov	r5,zero
  4140e4:	01800044 	movi	r6,1
  4140e8:	04151880 	call	415188 <altera_avalon_uart_init>
  4140ec:	01001074 	movhi	r4,65
  4140f0:	211d6404 	addi	r4,r4,30096
  4140f4:	04140040 	call	414004 <alt_dev_reg>
}
  4140f8:	e037883a 	mov	sp,fp
  4140fc:	dfc00117 	ldw	ra,4(sp)
  414100:	df000017 	ldw	fp,0(sp)
  414104:	dec00204 	addi	sp,sp,8
  414108:	f800283a 	ret

0041410c <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
  41410c:	defffd04 	addi	sp,sp,-12
  414110:	dfc00215 	stw	ra,8(sp)
  414114:	df000115 	stw	fp,4(sp)
  414118:	df000104 	addi	fp,sp,4
  41411c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
  414120:	e13fff17 	ldw	r4,-4(fp)
  414124:	01401074 	movhi	r5,65
  414128:	295e0804 	addi	r5,r5,30752
  41412c:	04161540 	call	416154 <alt_dev_llist_insert>
}
  414130:	e037883a 	mov	sp,fp
  414134:	dfc00117 	ldw	ra,4(sp)
  414138:	df000017 	ldw	fp,0(sp)
  41413c:	dec00204 	addi	sp,sp,8
  414140:	f800283a 	ret

00414144 <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
  414144:	defffc04 	addi	sp,sp,-16
  414148:	dfc00315 	stw	ra,12(sp)
  41414c:	df000215 	stw	fp,8(sp)
  414150:	df000204 	addi	fp,sp,8
  414154:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
  414158:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
  41415c:	e13fff17 	ldw	r4,-4(fp)
  414160:	04141980 	call	414198 <alt_epcs_flash_query>
  414164:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
  414168:	e0bffe17 	ldw	r2,-8(fp)
  41416c:	1000041e 	bne	r2,zero,414180 <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
  414170:	e0bfff17 	ldw	r2,-4(fp)
  414174:	1009883a 	mov	r4,r2
  414178:	041410c0 	call	41410c <alt_flash_device_register>
  41417c:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
  414180:	e0bffe17 	ldw	r2,-8(fp)
}
  414184:	e037883a 	mov	sp,fp
  414188:	dfc00117 	ldw	ra,4(sp)
  41418c:	df000017 	ldw	fp,0(sp)
  414190:	dec00204 	addi	sp,sp,8
  414194:	f800283a 	ret

00414198 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
  414198:	defffc04 	addi	sp,sp,-16
  41419c:	dfc00315 	stw	ra,12(sp)
  4141a0:	df000215 	stw	fp,8(sp)
  4141a4:	df000204 	addi	fp,sp,8
  4141a8:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
  4141ac:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  4141b0:	e0bfff17 	ldw	r2,-4(fp)
  4141b4:	10003215 	stw	zero,200(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
    epcs_read_electronic_signature(flash->register_base);
  4141b8:	e0bfff17 	ldw	r2,-4(fp)
  4141bc:	10802e17 	ldw	r2,184(r2)
  4141c0:	1009883a 	mov	r4,r2
  4141c4:	0415df40 	call	415df4 <epcs_read_electronic_signature>
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  
  /* Send the RES command sequence */
  flash->silicon_id =
  4141c8:	10c03fcc 	andi	r3,r2,255
  4141cc:	e0bfff17 	ldw	r2,-4(fp)
  4141d0:	10c03015 	stw	r3,192(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
  4141d4:	e0bfff17 	ldw	r2,-4(fp)
  4141d8:	10803017 	ldw	r2,192(r2)
  4141dc:	10800598 	cmpnei	r2,r2,22
  4141e0:	10000a1e 	bne	r2,zero,41420c <alt_epcs_flash_query+0x74>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
  4141e4:	e0bfff17 	ldw	r2,-4(fp)
  4141e8:	00c02034 	movhi	r3,128
  4141ec:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 128;
  4141f0:	e0bfff17 	ldw	r2,-4(fp)
  4141f4:	00c02004 	movi	r3,128
  4141f8:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  4141fc:	e0bfff17 	ldw	r2,-4(fp)
  414200:	00c00074 	movhi	r3,1
  414204:	10c01015 	stw	r3,64(r2)
  414208:	0000ce06 	br	414544 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
  41420c:	e0bfff17 	ldw	r2,-4(fp)
  414210:	10803017 	ldw	r2,192(r2)
  414214:	10800518 	cmpnei	r2,r2,20
  414218:	10000a1e 	bne	r2,zero,414244 <alt_epcs_flash_query+0xac>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
  41421c:	e0bfff17 	ldw	r2,-4(fp)
  414220:	00c00834 	movhi	r3,32
  414224:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 32;
  414228:	e0bfff17 	ldw	r2,-4(fp)
  41422c:	00c00804 	movi	r3,32
  414230:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  414234:	e0bfff17 	ldw	r2,-4(fp)
  414238:	00c00074 	movhi	r3,1
  41423c:	10c01015 	stw	r3,64(r2)
  414240:	0000c006 	br	414544 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
  414244:	e0bfff17 	ldw	r2,-4(fp)
  414248:	10803017 	ldw	r2,192(r2)
  41424c:	108004d8 	cmpnei	r2,r2,19
  414250:	10000a1e 	bne	r2,zero,41427c <alt_epcs_flash_query+0xe4>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
  414254:	e0bfff17 	ldw	r2,-4(fp)
  414258:	00c00434 	movhi	r3,16
  41425c:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 16;
  414260:	e0bfff17 	ldw	r2,-4(fp)
  414264:	00c00404 	movi	r3,16
  414268:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  41426c:	e0bfff17 	ldw	r2,-4(fp)
  414270:	00c00074 	movhi	r3,1
  414274:	10c01015 	stw	r3,64(r2)
  414278:	0000b206 	br	414544 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
  41427c:	e0bfff17 	ldw	r2,-4(fp)
  414280:	10803017 	ldw	r2,192(r2)
  414284:	10800498 	cmpnei	r2,r2,18
  414288:	10000a1e 	bne	r2,zero,4142b4 <alt_epcs_flash_query+0x11c>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
  41428c:	e0bfff17 	ldw	r2,-4(fp)
  414290:	00c00234 	movhi	r3,8
  414294:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 8;
  414298:	e0bfff17 	ldw	r2,-4(fp)
  41429c:	00c00204 	movi	r3,8
  4142a0:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
  4142a4:	e0bfff17 	ldw	r2,-4(fp)
  4142a8:	00c00074 	movhi	r3,1
  4142ac:	10c01015 	stw	r3,64(r2)
  4142b0:	0000a406 	br	414544 <alt_epcs_flash_query+0x3ac>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
  4142b4:	e0bfff17 	ldw	r2,-4(fp)
  4142b8:	10803017 	ldw	r2,192(r2)
  4142bc:	10800418 	cmpnei	r2,r2,16
  4142c0:	10000a1e 	bne	r2,zero,4142ec <alt_epcs_flash_query+0x154>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
  4142c4:	e0bfff17 	ldw	r2,-4(fp)
  4142c8:	00c000b4 	movhi	r3,2
  4142cc:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 4;
  4142d0:	e0bfff17 	ldw	r2,-4(fp)
  4142d4:	00c00104 	movi	r3,4
  4142d8:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 32768;
  4142dc:	e0bfff17 	ldw	r2,-4(fp)
  4142e0:	00e00014 	movui	r3,32768
  4142e4:	10c01015 	stw	r3,64(r2)
  4142e8:	00009606 	br	414544 <alt_epcs_flash_query+0x3ac>
  {
    /* 
     * Read electronic signature doesn't work for newer devices; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
  4142ec:	e0bfff17 	ldw	r2,-4(fp)
  4142f0:	10802e17 	ldw	r2,184(r2)
  4142f4:	1009883a 	mov	r4,r2
  4142f8:	0415e5c0 	call	415e5c <epcs_read_device_id>
  4142fc:	1007883a 	mov	r3,r2
  414300:	e0bfff17 	ldw	r2,-4(fp)
  414304:	10c03015 	stw	r3,192(r2)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA15) /* EPCQ16 */
  414308:	e0bfff17 	ldw	r2,-4(fp)
  41430c:	10c03017 	ldw	r3,192(r2)
  414310:	00804034 	movhi	r2,256
  414314:	10bfffc4 	addi	r2,r2,-1
  414318:	1886703a 	and	r3,r3,r2
  41431c:	00800874 	movhi	r2,33
  414320:	10ae8544 	addi	r2,r2,-17899
  414324:	18800a1e 	bne	r3,r2,414350 <alt_epcs_flash_query+0x1b8>
    {
      flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
  414328:	e0bfff17 	ldw	r2,-4(fp)
  41432c:	00c00834 	movhi	r3,32
  414330:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 32; /* number of sectors */
  414334:	e0bfff17 	ldw	r2,-4(fp)
  414338:	00c00804 	movi	r3,32
  41433c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  414340:	e0bfff17 	ldw	r2,-4(fp)
  414344:	00c00074 	movhi	r3,1
  414348:	10c01015 	stw	r3,64(r2)
  41434c:	00007d06 	br	414544 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA16) /* EPCQ32 */
  414350:	e0bfff17 	ldw	r2,-4(fp)
  414354:	10c03017 	ldw	r3,192(r2)
  414358:	00804034 	movhi	r2,256
  41435c:	10bfffc4 	addi	r2,r2,-1
  414360:	1886703a 	and	r3,r3,r2
  414364:	00800874 	movhi	r2,33
  414368:	10ae8584 	addi	r2,r2,-17898
  41436c:	18800a1e 	bne	r3,r2,414398 <alt_epcs_flash_query+0x200>
    {
      flash->dev.region_info[0].region_size = 32 * 1024 * 1024 / 8;
  414370:	e0bfff17 	ldw	r2,-4(fp)
  414374:	00c01034 	movhi	r3,64
  414378:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64; /* number of sectors */
  41437c:	e0bfff17 	ldw	r2,-4(fp)
  414380:	00c01004 	movi	r3,64
  414384:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  414388:	e0bfff17 	ldw	r2,-4(fp)
  41438c:	00c00074 	movhi	r3,1
  414390:	10c01015 	stw	r3,64(r2)
  414394:	00006b06 	br	414544 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA17) /* EPCQ64 */
  414398:	e0bfff17 	ldw	r2,-4(fp)
  41439c:	10c03017 	ldw	r3,192(r2)
  4143a0:	00804034 	movhi	r2,256
  4143a4:	10bfffc4 	addi	r2,r2,-1
  4143a8:	1886703a 	and	r3,r3,r2
  4143ac:	00800874 	movhi	r2,33
  4143b0:	10ae85c4 	addi	r2,r2,-17897
  4143b4:	18800a1e 	bne	r3,r2,4143e0 <alt_epcs_flash_query+0x248>
    {
      flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
  4143b8:	e0bfff17 	ldw	r2,-4(fp)
  4143bc:	00c02034 	movhi	r3,128
  4143c0:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 128; /* number of sectors */
  4143c4:	e0bfff17 	ldw	r2,-4(fp)
  4143c8:	00c02004 	movi	r3,128
  4143cc:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  4143d0:	e0bfff17 	ldw	r2,-4(fp)
  4143d4:	00c00074 	movhi	r3,1
  4143d8:	10c01015 	stw	r3,64(r2)
  4143dc:	00005906 	br	414544 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
  4143e0:	e0bfff17 	ldw	r2,-4(fp)
  4143e4:	10c03017 	ldw	r3,192(r2)
  4143e8:	00804034 	movhi	r2,256
  4143ec:	10bfffc4 	addi	r2,r2,-1
  4143f0:	1886703a 	and	r3,r3,r2
  4143f4:	00800874 	movhi	r2,33
  4143f8:	10ae8604 	addi	r2,r2,-17896
  4143fc:	18800a1e 	bne	r3,r2,414428 <alt_epcs_flash_query+0x290>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
  414400:	e0bfff17 	ldw	r2,-4(fp)
  414404:	00c04034 	movhi	r3,256
  414408:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
  41440c:	e0bfff17 	ldw	r2,-4(fp)
  414410:	00c04004 	movi	r3,256
  414414:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  414418:	e0bfff17 	ldw	r2,-4(fp)
  41441c:	00c00074 	movhi	r3,1
  414420:	10c01015 	stw	r3,64(r2)
  414424:	00004706 	br	414544 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
  414428:	e0bfff17 	ldw	r2,-4(fp)
  41442c:	10803017 	ldw	r2,192(r2)
  414430:	10803fcc 	andi	r2,r2,255
  414434:	10800618 	cmpnei	r2,r2,24
  414438:	10000a1e 	bne	r2,zero,414464 <alt_epcs_flash_query+0x2cc>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
  41443c:	e0bfff17 	ldw	r2,-4(fp)
  414440:	00c04034 	movhi	r3,256
  414444:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64;
  414448:	e0bfff17 	ldw	r2,-4(fp)
  41444c:	00c01004 	movi	r3,64
  414450:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 262144;
  414454:	e0bfff17 	ldw	r2,-4(fp)
  414458:	00c00134 	movhi	r3,4
  41445c:	10c01015 	stw	r3,64(r2)
  414460:	00003806 	br	414544 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
  414464:	e0bfff17 	ldw	r2,-4(fp)
  414468:	10803017 	ldw	r2,192(r2)
  41446c:	10803fcc 	andi	r2,r2,255
  414470:	10800658 	cmpnei	r2,r2,25
  414474:	10000d1e 	bne	r2,zero,4144ac <alt_epcs_flash_query+0x314>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
  414478:	e0bfff17 	ldw	r2,-4(fp)
  41447c:	00c08034 	movhi	r3,512
  414480:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
  414484:	e0bfff17 	ldw	r2,-4(fp)
  414488:	00c08004 	movi	r3,512
  41448c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  414490:	e0bfff17 	ldw	r2,-4(fp)
  414494:	00c00074 	movhi	r3,1
  414498:	10c01015 	stw	r3,64(r2)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
  41449c:	e0bfff17 	ldw	r2,-4(fp)
  4144a0:	00c00044 	movi	r3,1
  4144a4:	10c03215 	stw	r3,200(r2)
  4144a8:	00002606 	br	414544 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x20) /* EPCQ512 */
  4144ac:	e0bfff17 	ldw	r2,-4(fp)
  4144b0:	10803017 	ldw	r2,192(r2)
  4144b4:	10803fcc 	andi	r2,r2,255
  4144b8:	10800818 	cmpnei	r2,r2,32
  4144bc:	10000d1e 	bne	r2,zero,4144f4 <alt_epcs_flash_query+0x35c>
    {
      flash->dev.region_info[0].region_size = 512 * 1024 * 1024 / 8;
  4144c0:	e0bfff17 	ldw	r2,-4(fp)
  4144c4:	00c10034 	movhi	r3,1024
  4144c8:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 1024; /* number of sectors */
  4144cc:	e0bfff17 	ldw	r2,-4(fp)
  4144d0:	00c10004 	movi	r3,1024
  4144d4:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  4144d8:	e0bfff17 	ldw	r2,-4(fp)
  4144dc:	00c00074 	movhi	r3,1
  4144e0:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
  4144e4:	e0bfff17 	ldw	r2,-4(fp)
  4144e8:	00c00044 	movi	r3,1
  4144ec:	10c03215 	stw	r3,200(r2)
  4144f0:	00001406 	br	414544 <alt_epcs_flash_query+0x3ac>
    }
    else if((flash->silicon_id & 0xFF ) == 0x21) /* EPCQ1024 */
  4144f4:	e0bfff17 	ldw	r2,-4(fp)
  4144f8:	10803017 	ldw	r2,192(r2)
  4144fc:	10803fcc 	andi	r2,r2,255
  414500:	10800858 	cmpnei	r2,r2,33
  414504:	10000d1e 	bne	r2,zero,41453c <alt_epcs_flash_query+0x3a4>
    {
      flash->dev.region_info[0].region_size = 1024 * 1024 * 1024 / 8;
  414508:	e0bfff17 	ldw	r2,-4(fp)
  41450c:	00c20034 	movhi	r3,2048
  414510:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 2048; /* number of sectors */
  414514:	e0bfff17 	ldw	r2,-4(fp)
  414518:	00c20004 	movi	r3,2048
  41451c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
  414520:	e0bfff17 	ldw	r2,-4(fp)
  414524:	00c00074 	movhi	r3,1
  414528:	10c01015 	stw	r3,64(r2)

      /* Enable 4-bytes address mode if the device density is greater than 256Mbit. */
      flash->four_bytes_mode = 1;
  41452c:	e0bfff17 	ldw	r2,-4(fp)
  414530:	00c00044 	movi	r3,1
  414534:	10c03215 	stw	r3,200(r2)
  414538:	00000206 	br	414544 <alt_epcs_flash_query+0x3ac>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
  41453c:	00bffb44 	movi	r2,-19
  414540:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
  414544:	e0bfff17 	ldw	r2,-4(fp)
  414548:	10800e17 	ldw	r2,56(r2)
  41454c:	1007883a 	mov	r3,r2
  414550:	e0bfff17 	ldw	r2,-4(fp)
  414554:	10c02f15 	stw	r3,188(r2)
  flash->dev.number_of_regions = 1;
  414558:	e0bfff17 	ldw	r2,-4(fp)
  41455c:	00c00044 	movi	r3,1
  414560:	10c00c15 	stw	r3,48(r2)
  flash->dev.region_info[0].offset = 0;
  414564:	e0bfff17 	ldw	r2,-4(fp)
  414568:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
  41456c:	e0bfff17 	ldw	r2,-4(fp)
  414570:	00c04004 	movi	r3,256
  414574:	10c03115 	stw	r3,196(r2)

  /* Consider clearing all BP bits here. */
  return ret_code;
  414578:	e0bffe17 	ldw	r2,-8(fp)
}
  41457c:	e037883a 	mov	sp,fp
  414580:	dfc00117 	ldw	ra,4(sp)
  414584:	df000017 	ldw	fp,0(sp)
  414588:	dec00204 	addi	sp,sp,8
  41458c:	f800283a 	ret

00414590 <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
  414590:	deffee04 	addi	sp,sp,-72
  414594:	dfc01115 	stw	ra,68(sp)
  414598:	df001015 	stw	fp,64(sp)
  41459c:	df001004 	addi	fp,sp,64
  4145a0:	e13ffc15 	stw	r4,-16(fp)
  4145a4:	e17ffd15 	stw	r5,-12(fp)
  4145a8:	e1bffe15 	stw	r6,-8(fp)
  4145ac:	e1ffff15 	stw	r7,-4(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  4145b0:	00800804 	movi	r2,32
  4145b4:	e0bff115 	stw	r2,-60(fp)
  int current_offset = 0;
  4145b8:	e03ff015 	stw	zero,-64(fp)

  while (n > 0)
  4145bc:	00002606 	br	414658 <alt_epcs_flash_memcmp+0xc8>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
  4145c0:	e0bff117 	ldw	r2,-60(fp)
  4145c4:	e0ffff17 	ldw	r3,-4(fp)
  4145c8:	1880012e 	bgeu	r3,r2,4145d0 <alt_epcs_flash_memcmp+0x40>
  4145cc:	1805883a 	mov	r2,r3
  4145d0:	e0bff215 	stw	r2,-56(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
  4145d4:	e0fffe17 	ldw	r3,-8(fp)
  4145d8:	e0bff017 	ldw	r2,-64(fp)
  4145dc:	1887883a 	add	r3,r3,r2
  4145e0:	e0bff404 	addi	r2,fp,-48
  4145e4:	e13ffc17 	ldw	r4,-16(fp)
  4145e8:	180b883a 	mov	r5,r3
  4145ec:	100d883a 	mov	r6,r2
  4145f0:	e1fff217 	ldw	r7,-56(fp)
  4145f4:	0414b6c0 	call	414b6c <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
  4145f8:	1000020e 	bge	r2,zero,414604 <alt_epcs_flash_memcmp+0x74>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
  4145fc:	00bfffc4 	movi	r2,-1
  414600:	00001806 	br	414664 <alt_epcs_flash_memcmp+0xd4>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
  414604:	e0bff017 	ldw	r2,-64(fp)
  414608:	e0fffd17 	ldw	r3,-12(fp)
  41460c:	1889883a 	add	r4,r3,r2
  414610:	e0bff217 	ldw	r2,-56(fp)
  414614:	e0fff404 	addi	r3,fp,-48
  414618:	180b883a 	mov	r5,r3
  41461c:	100d883a 	mov	r6,r2
  414620:	0416f080 	call	416f08 <memcmp>
  414624:	e0bff315 	stw	r2,-52(fp)
    if (this_chunk_cmp)
  414628:	e0bff317 	ldw	r2,-52(fp)
  41462c:	10000226 	beq	r2,zero,414638 <alt_epcs_flash_memcmp+0xa8>
    {
      return this_chunk_cmp;
  414630:	e0bff317 	ldw	r2,-52(fp)
  414634:	00000b06 	br	414664 <alt_epcs_flash_memcmp+0xd4>
    }

    n -= this_chunk_size;
  414638:	e0bff217 	ldw	r2,-56(fp)
  41463c:	e0ffff17 	ldw	r3,-4(fp)
  414640:	1885c83a 	sub	r2,r3,r2
  414644:	e0bfff15 	stw	r2,-4(fp)
    current_offset += this_chunk_size;
  414648:	e0fff017 	ldw	r3,-64(fp)
  41464c:	e0bff217 	ldw	r2,-56(fp)
  414650:	1885883a 	add	r2,r3,r2
  414654:	e0bff015 	stw	r2,-64(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
  414658:	e0bfff17 	ldw	r2,-4(fp)
  41465c:	103fd81e 	bne	r2,zero,4145c0 <_gp+0xffff4dc4>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
  414660:	0005883a 	mov	r2,zero
}
  414664:	e037883a 	mov	sp,fp
  414668:	dfc00117 	ldw	ra,4(sp)
  41466c:	df000017 	ldw	fp,0(sp)
  414670:	dec00204 	addi	sp,sp,8
  414674:	f800283a 	ret

00414678 <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
  414678:	defff404 	addi	sp,sp,-48
  41467c:	dfc00b15 	stw	ra,44(sp)
  414680:	df000a15 	stw	fp,40(sp)
  414684:	df000a04 	addi	fp,sp,40
  414688:	e13ffc15 	stw	r4,-16(fp)
  41468c:	e17ffd15 	stw	r5,-12(fp)
  414690:	e1bffe15 	stw	r6,-8(fp)
  414694:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
  414698:	e03ff715 	stw	zero,-36(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  41469c:	e03ff815 	stw	zero,-32(fp)
  4146a0:	00008306 	br	4148b0 <alt_epcs_flash_write+0x238>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
  4146a4:	e0fffc17 	ldw	r3,-16(fp)
  4146a8:	e0bff817 	ldw	r2,-32(fp)
  4146ac:	1004913a 	slli	r2,r2,4
  4146b0:	10800d04 	addi	r2,r2,52
  4146b4:	1885883a 	add	r2,r3,r2
  4146b8:	10800017 	ldw	r2,0(r2)
  4146bc:	e0fffd17 	ldw	r3,-12(fp)
  4146c0:	18807816 	blt	r3,r2,4148a4 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
  4146c4:	e0fffc17 	ldw	r3,-16(fp)
  4146c8:	e0bff817 	ldw	r2,-32(fp)
  4146cc:	1004913a 	slli	r2,r2,4
  4146d0:	10800d04 	addi	r2,r2,52
  4146d4:	1885883a 	add	r2,r3,r2
  4146d8:	10c00017 	ldw	r3,0(r2)
      flash_info->region_info[i].region_size)))
  4146dc:	e13ffc17 	ldw	r4,-16(fp)
  4146e0:	e0bff817 	ldw	r2,-32(fp)
  4146e4:	1004913a 	slli	r2,r2,4
  4146e8:	10800e04 	addi	r2,r2,56
  4146ec:	2085883a 	add	r2,r4,r2
  4146f0:	10800017 	ldw	r2,0(r2)
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
      (offset < (flash_info->region_info[i].offset +
  4146f4:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
  4146f8:	e0fffd17 	ldw	r3,-12(fp)
  4146fc:	1880690e 	bge	r3,r2,4148a4 <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
  414700:	e0fffc17 	ldw	r3,-16(fp)
  414704:	e0bff817 	ldw	r2,-32(fp)
  414708:	1004913a 	slli	r2,r2,4
  41470c:	10800d04 	addi	r2,r2,52
  414710:	1885883a 	add	r2,r3,r2
  414714:	10800017 	ldw	r2,0(r2)
  414718:	e0bffa15 	stw	r2,-24(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
  41471c:	e03ff915 	stw	zero,-28(fp)
  414720:	00005806 	br	414884 <alt_epcs_flash_write+0x20c>
      {
        if ((offset >= current_offset ) &&
  414724:	e0fffd17 	ldw	r3,-12(fp)
  414728:	e0bffa17 	ldw	r2,-24(fp)
  41472c:	18804916 	blt	r3,r2,414854 <alt_epcs_flash_write+0x1dc>
            (offset < (current_offset +
            flash_info->region_info[i].block_size)))
  414730:	e0fffc17 	ldw	r3,-16(fp)
  414734:	e0bff817 	ldw	r2,-32(fp)
  414738:	10800104 	addi	r2,r2,4
  41473c:	1004913a 	slli	r2,r2,4
  414740:	1885883a 	add	r2,r3,r2
  414744:	10c00017 	ldw	r3,0(r2)
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
            (offset < (current_offset +
  414748:	e0bffa17 	ldw	r2,-24(fp)
  41474c:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
  414750:	e0fffd17 	ldw	r3,-12(fp)
  414754:	18803f0e 	bge	r3,r2,414854 <alt_epcs_flash_write+0x1dc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
  414758:	e0fffc17 	ldw	r3,-16(fp)
  41475c:	e0bff817 	ldw	r2,-32(fp)
  414760:	10800104 	addi	r2,r2,4
  414764:	1004913a 	slli	r2,r2,4
  414768:	1885883a 	add	r2,r3,r2
  41476c:	10c00017 	ldw	r3,0(r2)
  414770:	e0bffa17 	ldw	r2,-24(fp)
  414774:	1887883a 	add	r3,r3,r2
  414778:	e0bffd17 	ldw	r2,-12(fp)
  41477c:	1885c83a 	sub	r2,r3,r2
  414780:	e0bffb15 	stw	r2,-20(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
  414784:	e0fffb17 	ldw	r3,-20(fp)
  414788:	e0bfff17 	ldw	r2,-4(fp)
  41478c:	1880010e 	bge	r3,r2,414794 <alt_epcs_flash_write+0x11c>
  414790:	1805883a 	mov	r2,r3
  414794:	e0bffb15 	stw	r2,-20(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
  414798:	e0bffb17 	ldw	r2,-20(fp)
  41479c:	e13ffc17 	ldw	r4,-16(fp)
  4147a0:	e17ffe17 	ldw	r5,-8(fp)
  4147a4:	e1bffd17 	ldw	r6,-12(fp)
  4147a8:	100f883a 	mov	r7,r2
  4147ac:	04145900 	call	414590 <alt_epcs_flash_memcmp>
  4147b0:	10001226 	beq	r2,zero,4147fc <alt_epcs_flash_write+0x184>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
  4147b4:	e0bffc17 	ldw	r2,-16(fp)
  4147b8:	10800817 	ldw	r2,32(r2)
  4147bc:	e13ffc17 	ldw	r4,-16(fp)
  4147c0:	e17ffa17 	ldw	r5,-24(fp)
  4147c4:	103ee83a 	callr	r2
  4147c8:	e0bff715 	stw	r2,-36(fp)

            if (!ret_code)
  4147cc:	e0bff717 	ldw	r2,-36(fp)
  4147d0:	10000a1e 	bne	r2,zero,4147fc <alt_epcs_flash_write+0x184>
            {
              ret_code = (*flash_info->write_block)(
  4147d4:	e0bffc17 	ldw	r2,-16(fp)
  4147d8:	10800917 	ldw	r2,36(r2)
  4147dc:	e0fffb17 	ldw	r3,-20(fp)
  4147e0:	d8c00015 	stw	r3,0(sp)
  4147e4:	e13ffc17 	ldw	r4,-16(fp)
  4147e8:	e17ffa17 	ldw	r5,-24(fp)
  4147ec:	e1bffd17 	ldw	r6,-12(fp)
  4147f0:	e1fffe17 	ldw	r7,-8(fp)
  4147f4:	103ee83a 	callr	r2
  4147f8:	e0bff715 	stw	r2,-36(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
  4147fc:	e0ffff17 	ldw	r3,-4(fp)
  414800:	e0bffb17 	ldw	r2,-20(fp)
  414804:	18802e26 	beq	r3,r2,4148c0 <alt_epcs_flash_write+0x248>
  414808:	e0bff717 	ldw	r2,-36(fp)
  41480c:	10002c1e 	bne	r2,zero,4148c0 <alt_epcs_flash_write+0x248>
          {
            goto finished;
          }

          length -= data_to_write;
  414810:	e0ffff17 	ldw	r3,-4(fp)
  414814:	e0bffb17 	ldw	r2,-20(fp)
  414818:	1885c83a 	sub	r2,r3,r2
  41481c:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
  414820:	e0fffc17 	ldw	r3,-16(fp)
  414824:	e0bff817 	ldw	r2,-32(fp)
  414828:	10800104 	addi	r2,r2,4
  41482c:	1004913a 	slli	r2,r2,4
  414830:	1885883a 	add	r2,r3,r2
  414834:	10c00017 	ldw	r3,0(r2)
  414838:	e0bffa17 	ldw	r2,-24(fp)
  41483c:	1885883a 	add	r2,r3,r2
  414840:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
  414844:	e0bffb17 	ldw	r2,-20(fp)
  414848:	e0fffe17 	ldw	r3,-8(fp)
  41484c:	1885883a 	add	r2,r3,r2
  414850:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
  414854:	e0fffc17 	ldw	r3,-16(fp)
  414858:	e0bff817 	ldw	r2,-32(fp)
  41485c:	10800104 	addi	r2,r2,4
  414860:	1004913a 	slli	r2,r2,4
  414864:	1885883a 	add	r2,r3,r2
  414868:	10800017 	ldw	r2,0(r2)
  41486c:	e0fffa17 	ldw	r3,-24(fp)
  414870:	1885883a 	add	r2,r3,r2
  414874:	e0bffa15 	stw	r2,-24(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
  414878:	e0bff917 	ldw	r2,-28(fp)
  41487c:	10800044 	addi	r2,r2,1
  414880:	e0bff915 	stw	r2,-28(fp)
  414884:	e0fffc17 	ldw	r3,-16(fp)
  414888:	e0bff817 	ldw	r2,-32(fp)
  41488c:	1004913a 	slli	r2,r2,4
  414890:	10800f04 	addi	r2,r2,60
  414894:	1885883a 	add	r2,r3,r2
  414898:	10800017 	ldw	r2,0(r2)
  41489c:	e0fff917 	ldw	r3,-28(fp)
  4148a0:	18bfa016 	blt	r3,r2,414724 <_gp+0xffff4f28>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  4148a4:	e0bff817 	ldw	r2,-32(fp)
  4148a8:	10800044 	addi	r2,r2,1
  4148ac:	e0bff815 	stw	r2,-32(fp)
  4148b0:	e0bffc17 	ldw	r2,-16(fp)
  4148b4:	10800c17 	ldw	r2,48(r2)
  4148b8:	e0fff817 	ldw	r3,-32(fp)
  4148bc:	18bf7916 	blt	r3,r2,4146a4 <_gp+0xffff4ea8>
      }
    }
  }

finished:
  return ret_code;
  4148c0:	e0bff717 	ldw	r2,-36(fp)
}
  4148c4:	e037883a 	mov	sp,fp
  4148c8:	dfc00117 	ldw	ra,4(sp)
  4148cc:	df000017 	ldw	fp,0(sp)
  4148d0:	dec00204 	addi	sp,sp,8
  4148d4:	f800283a 	ret

004148d8 <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
  4148d8:	defffa04 	addi	sp,sp,-24
  4148dc:	df000515 	stw	fp,20(sp)
  4148e0:	df000504 	addi	fp,sp,20
  4148e4:	e13ffd15 	stw	r4,-12(fp)
  4148e8:	e17ffe15 	stw	r5,-8(fp)
  4148ec:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
  4148f0:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
  4148f4:	e0bffd17 	ldw	r2,-12(fp)
  4148f8:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
  4148fc:	e0bffc17 	ldw	r2,-16(fp)
  414900:	10c00c17 	ldw	r3,48(r2)
  414904:	e0bfff17 	ldw	r2,-4(fp)
  414908:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
  41490c:	e0bffc17 	ldw	r2,-16(fp)
  414910:	10800c17 	ldw	r2,48(r2)
  414914:	1000031e 	bne	r2,zero,414924 <alt_epcs_flash_get_info+0x4c>
  {
    ret_code = -EIO;
  414918:	00bffec4 	movi	r2,-5
  41491c:	e0bffb15 	stw	r2,-20(fp)
  414920:	00000b06 	br	414950 <alt_epcs_flash_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
  414924:	e0bffc17 	ldw	r2,-16(fp)
  414928:	10800c17 	ldw	r2,48(r2)
  41492c:	10800250 	cmplti	r2,r2,9
  414930:	1000031e 	bne	r2,zero,414940 <alt_epcs_flash_get_info+0x68>
  {
    ret_code = -ENOMEM;
  414934:	00bffd04 	movi	r2,-12
  414938:	e0bffb15 	stw	r2,-20(fp)
  41493c:	00000406 	br	414950 <alt_epcs_flash_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
  414940:	e0bffc17 	ldw	r2,-16(fp)
  414944:	10c00d04 	addi	r3,r2,52
  414948:	e0bffe17 	ldw	r2,-8(fp)
  41494c:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
  414950:	e0bffb17 	ldw	r2,-20(fp)
}
  414954:	e037883a 	mov	sp,fp
  414958:	df000017 	ldw	fp,0(sp)
  41495c:	dec00104 	addi	sp,sp,4
  414960:	f800283a 	ret

00414964 <alt_epcs_test_address>:


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
  414964:	defff904 	addi	sp,sp,-28
  414968:	df000615 	stw	fp,24(sp)
  41496c:	df000604 	addi	fp,sp,24
  414970:	e13ffe15 	stw	r4,-8(fp)
  414974:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
  414978:	e03ffa15 	stw	zero,-24(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  41497c:	e0bffe17 	ldw	r2,-8(fp)
  414980:	e0bffb15 	stw	r2,-20(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  414984:	e0bffb17 	ldw	r2,-20(fp)
  414988:	10800c17 	ldw	r2,48(r2)
  41498c:	10bfffc4 	addi	r2,r2,-1
  414990:	e0bffc15 	stw	r2,-16(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
  414994:	e0fffb17 	ldw	r3,-20(fp)
  414998:	e0bffc17 	ldw	r2,-16(fp)
  41499c:	1004913a 	slli	r2,r2,4
  4149a0:	10800d04 	addi	r2,r2,52
  4149a4:	1885883a 	add	r2,r3,r2
  4149a8:	10800017 	ldw	r2,0(r2)
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
  4149ac:	10ffffc4 	addi	r3,r2,-1
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
  4149b0:	e13ffb17 	ldw	r4,-20(fp)
  4149b4:	e0bffc17 	ldw	r2,-16(fp)
  4149b8:	1004913a 	slli	r2,r2,4
  4149bc:	10800e04 	addi	r2,r2,56
  4149c0:	2085883a 	add	r2,r4,r2
  4149c4:	10800017 	ldw	r2,0(r2)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
  4149c8:	1885883a 	add	r2,r3,r2
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
  4149cc:	e0bffd15 	stw	r2,-12(fp)
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
  4149d0:	e0bfff17 	ldw	r2,-4(fp)
  4149d4:	e0fffd17 	ldw	r3,-12(fp)
  4149d8:	1880022e 	bgeu	r3,r2,4149e4 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
  4149dc:	00bffec4 	movi	r2,-5
  4149e0:	e0bffa15 	stw	r2,-24(fp)
  }
  return ret_code;
  4149e4:	e0bffa17 	ldw	r2,-24(fp)
}
  4149e8:	e037883a 	mov	sp,fp
  4149ec:	df000017 	ldw	fp,0(sp)
  4149f0:	dec00104 	addi	sp,sp,4
  4149f4:	f800283a 	ret

004149f8 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
  4149f8:	defffa04 	addi	sp,sp,-24
  4149fc:	dfc00515 	stw	ra,20(sp)
  414a00:	df000415 	stw	fp,16(sp)
  414a04:	df000404 	addi	fp,sp,16
  414a08:	e13ffe15 	stw	r4,-8(fp)
  414a0c:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
  414a10:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  414a14:	e0bffe17 	ldw	r2,-8(fp)
  414a18:	e0bffd15 	stw	r2,-12(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
  414a1c:	e13ffe17 	ldw	r4,-8(fp)
  414a20:	e17fff17 	ldw	r5,-4(fp)
  414a24:	04149640 	call	414964 <alt_epcs_test_address>
  414a28:	e0bffc15 	stw	r2,-16(fp)

  if (ret_code >= 0)
  414a2c:	e0bffc17 	ldw	r2,-16(fp)
  414a30:	10000816 	blt	r2,zero,414a54 <alt_epcs_flash_erase_block+0x5c>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
  414a34:	e0bffd17 	ldw	r2,-12(fp)
  414a38:	11002e17 	ldw	r4,184(r2)
  414a3c:	e0ffff17 	ldw	r3,-4(fp)
  414a40:	e0bffd17 	ldw	r2,-12(fp)
  414a44:	10803217 	ldw	r2,200(r2)
  414a48:	180b883a 	mov	r5,r3
  414a4c:	100d883a 	mov	r6,r2
  414a50:	0415a340 	call	415a34 <epcs_sector_erase>
  }
  return ret_code;
  414a54:	e0bffc17 	ldw	r2,-16(fp)
}
  414a58:	e037883a 	mov	sp,fp
  414a5c:	dfc00117 	ldw	ra,4(sp)
  414a60:	df000017 	ldw	fp,0(sp)
  414a64:	dec00204 	addi	sp,sp,8
  414a68:	f800283a 	ret

00414a6c <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
  414a6c:	defff404 	addi	sp,sp,-48
  414a70:	dfc00b15 	stw	ra,44(sp)
  414a74:	df000a15 	stw	fp,40(sp)
  414a78:	df000a04 	addi	fp,sp,40
  414a7c:	e13ffc15 	stw	r4,-16(fp)
  414a80:	e17ffd15 	stw	r5,-12(fp)
  414a84:	e1bffe15 	stw	r6,-8(fp)
  414a88:	e1ffff15 	stw	r7,-4(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  414a8c:	e0bffc17 	ldw	r2,-16(fp)
  414a90:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
  414a94:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
  414a98:	e13ffc17 	ldw	r4,-16(fp)
  414a9c:	e17ffe17 	ldw	r5,-8(fp)
  414aa0:	04149640 	call	414964 <alt_epcs_test_address>
  414aa4:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
  414aa8:	e0bff917 	ldw	r2,-28(fp)
  414aac:	10002916 	blt	r2,zero,414b54 <alt_epcs_flash_write_block+0xe8>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
  414ab0:	00002606 	br	414b4c <alt_epcs_flash_write_block+0xe0>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
  414ab4:	e0bff817 	ldw	r2,-32(fp)
  414ab8:	10c03117 	ldw	r3,196(r2)
  414abc:	e0bffe17 	ldw	r2,-8(fp)
  414ac0:	1887883a 	add	r3,r3,r2
  414ac4:	e0bff817 	ldw	r2,-32(fp)
  414ac8:	10803117 	ldw	r2,196(r2)
  414acc:	0085c83a 	sub	r2,zero,r2
  414ad0:	1884703a 	and	r2,r3,r2
  414ad4:	e0bffa15 	stw	r2,-24(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
  414ad8:	e0fffa17 	ldw	r3,-24(fp)
  414adc:	e0bffe17 	ldw	r2,-8(fp)
  414ae0:	1885c83a 	sub	r2,r3,r2
  414ae4:	e0c00217 	ldw	r3,8(fp)
  414ae8:	1880010e 	bge	r3,r2,414af0 <alt_epcs_flash_write_block+0x84>
  414aec:	1805883a 	mov	r2,r3
  414af0:	e0bffb15 	stw	r2,-20(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
  414af4:	e0bff817 	ldw	r2,-32(fp)
  414af8:	11002e17 	ldw	r4,184(r2)
  414afc:	e0bff717 	ldw	r2,-36(fp)
  414b00:	e0ffff17 	ldw	r3,-4(fp)
  414b04:	1887883a 	add	r3,r3,r2
  414b08:	e0bff817 	ldw	r2,-32(fp)
  414b0c:	10803217 	ldw	r2,200(r2)
  414b10:	d8800015 	stw	r2,0(sp)
  414b14:	e17ffe17 	ldw	r5,-8(fp)
  414b18:	180d883a 	mov	r6,r3
  414b1c:	e1fffb17 	ldw	r7,-20(fp)
  414b20:	0415cd80 	call	415cd8 <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
  414b24:	e0c00217 	ldw	r3,8(fp)
  414b28:	e0bffb17 	ldw	r2,-20(fp)
  414b2c:	1885c83a 	sub	r2,r3,r2
  414b30:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
  414b34:	e0fff717 	ldw	r3,-36(fp)
  414b38:	e0bffb17 	ldw	r2,-20(fp)
  414b3c:	1885883a 	add	r2,r3,r2
  414b40:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
  414b44:	e0bffa17 	ldw	r2,-24(fp)
  414b48:	e0bffe15 	stw	r2,-8(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
  414b4c:	e0800217 	ldw	r2,8(fp)
  414b50:	103fd81e 	bne	r2,zero,414ab4 <_gp+0xffff52b8>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
  414b54:	e0bff917 	ldw	r2,-28(fp)
}
  414b58:	e037883a 	mov	sp,fp
  414b5c:	dfc00117 	ldw	ra,4(sp)
  414b60:	df000017 	ldw	fp,0(sp)
  414b64:	dec00204 	addi	sp,sp,8
  414b68:	f800283a 	ret

00414b6c <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
  414b6c:	defff704 	addi	sp,sp,-36
  414b70:	dfc00815 	stw	ra,32(sp)
  414b74:	df000715 	stw	fp,28(sp)
  414b78:	df000704 	addi	fp,sp,28
  414b7c:	e13ffc15 	stw	r4,-16(fp)
  414b80:	e17ffd15 	stw	r5,-12(fp)
  414b84:	e1bffe15 	stw	r6,-8(fp)
  414b88:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
  414b8c:	e03ffa15 	stw	zero,-24(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
  414b90:	e0bffc17 	ldw	r2,-16(fp)
  414b94:	e0bffb15 	stw	r2,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
  414b98:	e13ffc17 	ldw	r4,-16(fp)
  414b9c:	e17ffd17 	ldw	r5,-12(fp)
  414ba0:	04149640 	call	414964 <alt_epcs_test_address>
  414ba4:	e0bffa15 	stw	r2,-24(fp)

  if (ret_code >= 0)
  414ba8:	e0bffa17 	ldw	r2,-24(fp)
  414bac:	10000f16 	blt	r2,zero,414bec <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
  414bb0:	e0bffb17 	ldw	r2,-20(fp)
  414bb4:	10c02e17 	ldw	r3,184(r2)
  414bb8:	e0bffb17 	ldw	r2,-20(fp)
  414bbc:	10803217 	ldw	r2,200(r2)
  414bc0:	d8800015 	stw	r2,0(sp)
  414bc4:	1809883a 	mov	r4,r3
  414bc8:	e17ffd17 	ldw	r5,-12(fp)
  414bcc:	e1bffe17 	ldw	r6,-8(fp)
  414bd0:	e1ffff17 	ldw	r7,-4(fp)
  414bd4:	0415b2c0 	call	415b2c <epcs_read_buffer>
  414bd8:	e0bffa15 	stw	r2,-24(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
  414bdc:	e0fffa17 	ldw	r3,-24(fp)
  414be0:	e0bfff17 	ldw	r2,-4(fp)
  414be4:	1880011e 	bne	r3,r2,414bec <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
  414be8:	e03ffa15 	stw	zero,-24(fp)
    }
  }
  return ret_code;
  414bec:	e0bffa17 	ldw	r2,-24(fp)
}
  414bf0:	e037883a 	mov	sp,fp
  414bf4:	dfc00117 	ldw	ra,4(sp)
  414bf8:	df000017 	ldw	fp,0(sp)
  414bfc:	dec00204 	addi	sp,sp,8
  414c00:	f800283a 	ret

00414c04 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  414c04:	defffa04 	addi	sp,sp,-24
  414c08:	dfc00515 	stw	ra,20(sp)
  414c0c:	df000415 	stw	fp,16(sp)
  414c10:	df000404 	addi	fp,sp,16
  414c14:	e13ffd15 	stw	r4,-12(fp)
  414c18:	e17ffe15 	stw	r5,-8(fp)
  414c1c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  414c20:	e0bffd17 	ldw	r2,-12(fp)
  414c24:	10800017 	ldw	r2,0(r2)
  414c28:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  414c2c:	e0bffc17 	ldw	r2,-16(fp)
  414c30:	10c00a04 	addi	r3,r2,40
  414c34:	e0bffd17 	ldw	r2,-12(fp)
  414c38:	10800217 	ldw	r2,8(r2)
  414c3c:	1809883a 	mov	r4,r3
  414c40:	e17ffe17 	ldw	r5,-8(fp)
  414c44:	e1bfff17 	ldw	r6,-4(fp)
  414c48:	100f883a 	mov	r7,r2
  414c4c:	0414cc40 	call	414cc4 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  414c50:	e037883a 	mov	sp,fp
  414c54:	dfc00117 	ldw	ra,4(sp)
  414c58:	df000017 	ldw	fp,0(sp)
  414c5c:	dec00204 	addi	sp,sp,8
  414c60:	f800283a 	ret

00414c64 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  414c64:	defffa04 	addi	sp,sp,-24
  414c68:	dfc00515 	stw	ra,20(sp)
  414c6c:	df000415 	stw	fp,16(sp)
  414c70:	df000404 	addi	fp,sp,16
  414c74:	e13ffd15 	stw	r4,-12(fp)
  414c78:	e17ffe15 	stw	r5,-8(fp)
  414c7c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  414c80:	e0bffd17 	ldw	r2,-12(fp)
  414c84:	10800017 	ldw	r2,0(r2)
  414c88:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  414c8c:	e0bffc17 	ldw	r2,-16(fp)
  414c90:	10c00a04 	addi	r3,r2,40
  414c94:	e0bffd17 	ldw	r2,-12(fp)
  414c98:	10800217 	ldw	r2,8(r2)
  414c9c:	1809883a 	mov	r4,r3
  414ca0:	e17ffe17 	ldw	r5,-8(fp)
  414ca4:	e1bfff17 	ldw	r6,-4(fp)
  414ca8:	100f883a 	mov	r7,r2
  414cac:	0414da80 	call	414da8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  414cb0:	e037883a 	mov	sp,fp
  414cb4:	dfc00117 	ldw	ra,4(sp)
  414cb8:	df000017 	ldw	fp,0(sp)
  414cbc:	dec00204 	addi	sp,sp,8
  414cc0:	f800283a 	ret

00414cc4 <altera_avalon_jtag_uart_read>:
 */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
  414cc4:	defff704 	addi	sp,sp,-36
  414cc8:	df000815 	stw	fp,32(sp)
  414ccc:	df000804 	addi	fp,sp,32
  414cd0:	e13ffc15 	stw	r4,-16(fp)
  414cd4:	e17ffd15 	stw	r5,-12(fp)
  414cd8:	e1bffe15 	stw	r6,-8(fp)
  414cdc:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
  414ce0:	e0bffc17 	ldw	r2,-16(fp)
  414ce4:	10800017 	ldw	r2,0(r2)
  414ce8:	e0bff915 	stw	r2,-28(fp)

  char * ptr = buffer;
  414cec:	e0bffd17 	ldw	r2,-12(fp)
  414cf0:	e0bff815 	stw	r2,-32(fp)
  char * end = buffer + space;
  414cf4:	e0bffe17 	ldw	r2,-8(fp)
  414cf8:	e0fffd17 	ldw	r3,-12(fp)
  414cfc:	1885883a 	add	r2,r3,r2
  414d00:	e0bffa15 	stw	r2,-24(fp)

  while (ptr < end)
  414d04:	00001406 	br	414d58 <altera_avalon_jtag_uart_read+0x94>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  414d08:	e0bff917 	ldw	r2,-28(fp)
  414d0c:	10800037 	ldwio	r2,0(r2)
  414d10:	e0bffb15 	stw	r2,-20(fp)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
  414d14:	e0bffb17 	ldw	r2,-20(fp)
  414d18:	10a0000c 	andi	r2,r2,32768
  414d1c:	10000626 	beq	r2,zero,414d38 <altera_avalon_jtag_uart_read+0x74>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  414d20:	e0bff817 	ldw	r2,-32(fp)
  414d24:	10c00044 	addi	r3,r2,1
  414d28:	e0fff815 	stw	r3,-32(fp)
  414d2c:	e0fffb17 	ldw	r3,-20(fp)
  414d30:	10c00005 	stb	r3,0(r2)
  414d34:	00000806 	br	414d58 <altera_avalon_jtag_uart_read+0x94>
    else if (ptr != buffer)
  414d38:	e0fff817 	ldw	r3,-32(fp)
  414d3c:	e0bffd17 	ldw	r2,-12(fp)
  414d40:	18800126 	beq	r3,r2,414d48 <altera_avalon_jtag_uart_read+0x84>
      break;
  414d44:	00000706 	br	414d64 <altera_avalon_jtag_uart_read+0xa0>
    else if(flags & O_NONBLOCK)
  414d48:	e0bfff17 	ldw	r2,-4(fp)
  414d4c:	1090000c 	andi	r2,r2,16384
  414d50:	10000126 	beq	r2,zero,414d58 <altera_avalon_jtag_uart_read+0x94>
      break;   
  414d54:	00000306 	br	414d64 <altera_avalon_jtag_uart_read+0xa0>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
  414d58:	e0fff817 	ldw	r3,-32(fp)
  414d5c:	e0bffa17 	ldw	r2,-24(fp)
  414d60:	18bfe936 	bltu	r3,r2,414d08 <_gp+0xffff550c>
    else if(flags & O_NONBLOCK)
      break;   
    
  }

  if (ptr != buffer)
  414d64:	e0fff817 	ldw	r3,-32(fp)
  414d68:	e0bffd17 	ldw	r2,-12(fp)
  414d6c:	18800426 	beq	r3,r2,414d80 <altera_avalon_jtag_uart_read+0xbc>
    return ptr - buffer;
  414d70:	e0fff817 	ldw	r3,-32(fp)
  414d74:	e0bffd17 	ldw	r2,-12(fp)
  414d78:	1885c83a 	sub	r2,r3,r2
  414d7c:	00000606 	br	414d98 <altera_avalon_jtag_uart_read+0xd4>
  else if (flags & O_NONBLOCK)
  414d80:	e0bfff17 	ldw	r2,-4(fp)
  414d84:	1090000c 	andi	r2,r2,16384
  414d88:	10000226 	beq	r2,zero,414d94 <altera_avalon_jtag_uart_read+0xd0>
    return -EWOULDBLOCK;
  414d8c:	00bffd44 	movi	r2,-11
  414d90:	00000106 	br	414d98 <altera_avalon_jtag_uart_read+0xd4>
  else
    return -EIO;
  414d94:	00bffec4 	movi	r2,-5
}
  414d98:	e037883a 	mov	sp,fp
  414d9c:	df000017 	ldw	fp,0(sp)
  414da0:	dec00104 	addi	sp,sp,4
  414da4:	f800283a 	ret

00414da8 <altera_avalon_jtag_uart_write>:
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  414da8:	defff904 	addi	sp,sp,-28
  414dac:	df000615 	stw	fp,24(sp)
  414db0:	df000604 	addi	fp,sp,24
  414db4:	e13ffc15 	stw	r4,-16(fp)
  414db8:	e17ffd15 	stw	r5,-12(fp)
  414dbc:	e1bffe15 	stw	r6,-8(fp)
  414dc0:	e1ffff15 	stw	r7,-4(fp)
  unsigned int base = sp->base;
  414dc4:	e0bffc17 	ldw	r2,-16(fp)
  414dc8:	10800017 	ldw	r2,0(r2)
  414dcc:	e0bffa15 	stw	r2,-24(fp)

  const char * end = ptr + count;
  414dd0:	e0bffe17 	ldw	r2,-8(fp)
  414dd4:	e0fffd17 	ldw	r3,-12(fp)
  414dd8:	1885883a 	add	r2,r3,r2
  414ddc:	e0bffb15 	stw	r2,-20(fp)

  while (ptr < end)
  414de0:	00000e06 	br	414e1c <altera_avalon_jtag_uart_write+0x74>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
  414de4:	e0bffa17 	ldw	r2,-24(fp)
  414de8:	10800104 	addi	r2,r2,4
  414dec:	10800037 	ldwio	r2,0(r2)
  414df0:	10bfffec 	andhi	r2,r2,65535
  414df4:	10000926 	beq	r2,zero,414e1c <altera_avalon_jtag_uart_write+0x74>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
  414df8:	e0fffa17 	ldw	r3,-24(fp)
  414dfc:	e0bffd17 	ldw	r2,-12(fp)
  414e00:	11000044 	addi	r4,r2,1
  414e04:	e13ffd15 	stw	r4,-12(fp)
  414e08:	10800003 	ldbu	r2,0(r2)
  414e0c:	10803fcc 	andi	r2,r2,255
  414e10:	1080201c 	xori	r2,r2,128
  414e14:	10bfe004 	addi	r2,r2,-128
  414e18:	18800035 	stwio	r2,0(r3)
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
  414e1c:	e0fffd17 	ldw	r3,-12(fp)
  414e20:	e0bffb17 	ldw	r2,-20(fp)
  414e24:	18bfef36 	bltu	r3,r2,414de4 <_gp+0xffff55e8>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
  414e28:	e0bffe17 	ldw	r2,-8(fp)
}
  414e2c:	e037883a 	mov	sp,fp
  414e30:	df000017 	ldw	fp,0(sp)
  414e34:	dec00104 	addi	sp,sp,4
  414e38:	f800283a 	ret

00414e3c <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  414e3c:	defffa04 	addi	sp,sp,-24
  414e40:	dfc00515 	stw	ra,20(sp)
  414e44:	df000415 	stw	fp,16(sp)
  414e48:	df000404 	addi	fp,sp,16
  414e4c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  414e50:	0007883a 	mov	r3,zero
  414e54:	e0bfff17 	ldw	r2,-4(fp)
  414e58:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  414e5c:	e0bfff17 	ldw	r2,-4(fp)
  414e60:	10800104 	addi	r2,r2,4
  414e64:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  414e68:	0005303a 	rdctl	r2,status
  414e6c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  414e70:	e0fffd17 	ldw	r3,-12(fp)
  414e74:	00bfff84 	movi	r2,-2
  414e78:	1884703a 	and	r2,r3,r2
  414e7c:	1001703a 	wrctl	status,r2
  
  return context;
  414e80:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  414e84:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
  414e88:	04169340 	call	416934 <alt_tick>
  414e8c:	e0bffc17 	ldw	r2,-16(fp)
  414e90:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  414e94:	e0bffe17 	ldw	r2,-8(fp)
  414e98:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  414e9c:	e037883a 	mov	sp,fp
  414ea0:	dfc00117 	ldw	ra,4(sp)
  414ea4:	df000017 	ldw	fp,0(sp)
  414ea8:	dec00204 	addi	sp,sp,8
  414eac:	f800283a 	ret

00414eb0 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  414eb0:	defff804 	addi	sp,sp,-32
  414eb4:	dfc00715 	stw	ra,28(sp)
  414eb8:	df000615 	stw	fp,24(sp)
  414ebc:	df000604 	addi	fp,sp,24
  414ec0:	e13ffc15 	stw	r4,-16(fp)
  414ec4:	e17ffd15 	stw	r5,-12(fp)
  414ec8:	e1bffe15 	stw	r6,-8(fp)
  414ecc:	e1ffff15 	stw	r7,-4(fp)
  414ed0:	e0bfff17 	ldw	r2,-4(fp)
  414ed4:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  414ed8:	00801074 	movhi	r2,65
  414edc:	109f3a04 	addi	r2,r2,31976
  414ee0:	10800017 	ldw	r2,0(r2)
  414ee4:	1000041e 	bne	r2,zero,414ef8 <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
  414ee8:	00801074 	movhi	r2,65
  414eec:	109f3a04 	addi	r2,r2,31976
  414ef0:	e0fffb17 	ldw	r3,-20(fp)
  414ef4:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  414ef8:	e0bffc17 	ldw	r2,-16(fp)
  414efc:	10800104 	addi	r2,r2,4
  414f00:	00c001c4 	movi	r3,7
  414f04:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  414f08:	d8000015 	stw	zero,0(sp)
  414f0c:	e13ffd17 	ldw	r4,-12(fp)
  414f10:	e17ffe17 	ldw	r5,-8(fp)
  414f14:	01801074 	movhi	r6,65
  414f18:	31938f04 	addi	r6,r6,20028
  414f1c:	e1fffc17 	ldw	r7,-16(fp)
  414f20:	0413bd80 	call	413bd8 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  414f24:	e037883a 	mov	sp,fp
  414f28:	dfc00117 	ldw	ra,4(sp)
  414f2c:	df000017 	ldw	fp,0(sp)
  414f30:	dec00204 	addi	sp,sp,8
  414f34:	f800283a 	ret

00414f38 <alt_timestamp_start>:
 * The return value of this function is 0 upon sucess and -1 if in timestamp
 * device has not been registered. 
 */

int alt_timestamp_start(void)
{
  414f38:	defffe04 	addi	sp,sp,-8
  414f3c:	df000115 	stw	fp,4(sp)
  414f40:	df000104 	addi	fp,sp,4
  void* base = altera_avalon_timer_ts_base;
  414f44:	00801074 	movhi	r2,65
  414f48:	109f3704 	addi	r2,r2,31964
  414f4c:	10800017 	ldw	r2,0(r2)
  414f50:	e0bfff15 	stw	r2,-4(fp)

  if (!altera_avalon_timer_ts_freq)
  414f54:	00801074 	movhi	r2,65
  414f58:	109f3804 	addi	r2,r2,31968
  414f5c:	10800017 	ldw	r2,0(r2)
  414f60:	1000021e 	bne	r2,zero,414f6c <alt_timestamp_start+0x34>
  {
    return -1;
  414f64:	00bfffc4 	movi	r2,-1
  414f68:	00001106 	br	414fb0 <alt_timestamp_start+0x78>
        IOWR_ALTERA_AVALON_TIMER_PERIOD_1 (base, 0xFFFF);;
        IOWR_ALTERA_AVALON_TIMER_PERIOD_2 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_PERIOD_3 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK);
    } else {
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base,ALTERA_AVALON_TIMER_CONTROL_STOP_MSK);
  414f6c:	e0bfff17 	ldw	r2,-4(fp)
  414f70:	10800104 	addi	r2,r2,4
  414f74:	00c00204 	movi	r3,8
  414f78:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIODL (base, 0xFFFF);
  414f7c:	e0bfff17 	ldw	r2,-4(fp)
  414f80:	10800204 	addi	r2,r2,8
  414f84:	00ffffd4 	movui	r3,65535
  414f88:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIODH (base, 0xFFFF);
  414f8c:	e0bfff17 	ldw	r2,-4(fp)
  414f90:	10800304 	addi	r2,r2,12
  414f94:	00ffffd4 	movui	r3,65535
  414f98:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK); 
  414f9c:	e0bfff17 	ldw	r2,-4(fp)
  414fa0:	10800104 	addi	r2,r2,4
  414fa4:	00c00104 	movi	r3,4
  414fa8:	10c00035 	stwio	r3,0(r2)
    } 
  }
  return 0;
  414fac:	0005883a 	mov	r2,zero
}
  414fb0:	e037883a 	mov	sp,fp
  414fb4:	df000017 	ldw	fp,0(sp)
  414fb8:	dec00104 	addi	sp,sp,4
  414fbc:	f800283a 	ret

00414fc0 <alt_timestamp>:
 * The returned timestamp counts up from the last time the period register
 * was reset. 
 */

alt_timestamp_type alt_timestamp(void)
{
  414fc0:	defffc04 	addi	sp,sp,-16
  414fc4:	df000315 	stw	fp,12(sp)
  414fc8:	df000304 	addi	fp,sp,12

  void* base = altera_avalon_timer_ts_base;
  414fcc:	00801074 	movhi	r2,65
  414fd0:	109f3704 	addi	r2,r2,31964
  414fd4:	10800017 	ldw	r2,0(r2)
  414fd8:	e0bffd15 	stw	r2,-12(fp)

  if (!altera_avalon_timer_ts_freq)
  414fdc:	00801074 	movhi	r2,65
  414fe0:	109f3804 	addi	r2,r2,31968
  414fe4:	10800017 	ldw	r2,0(r2)
  414fe8:	1000021e 	bne	r2,zero,414ff4 <alt_timestamp+0x34>
  {
#if (ALT_TIMESTAMP_COUNTER_SIZE == 64)
        return 0xFFFFFFFFFFFFFFFFULL;
#else
        return 0xFFFFFFFF;
  414fec:	00bfffc4 	movi	r2,-1
  414ff0:	00001306 	br	415040 <alt_timestamp+0x80>
        alt_timestamp_type snap_2 = IORD_ALTERA_AVALON_TIMER_SNAP_2(base) & ALTERA_AVALON_TIMER_SNAP_2_MSK;
        alt_timestamp_type snap_3 = IORD_ALTERA_AVALON_TIMER_SNAP_3(base) & ALTERA_AVALON_TIMER_SNAP_3_MSK;
        
        return (0xFFFFFFFFFFFFFFFFULL - ( (snap_3 << 48) | (snap_2 << 32) | (snap_1 << 16) | (snap_0) ));
#else
        IOWR_ALTERA_AVALON_TIMER_SNAPL (base, 0);
  414ff4:	e0bffd17 	ldw	r2,-12(fp)
  414ff8:	10800404 	addi	r2,r2,16
  414ffc:	0007883a 	mov	r3,zero
  415000:	10c00035 	stwio	r3,0(r2)
        alt_timestamp_type lower = IORD_ALTERA_AVALON_TIMER_SNAPL(base) & ALTERA_AVALON_TIMER_SNAPL_MSK;
  415004:	e0bffd17 	ldw	r2,-12(fp)
  415008:	10800404 	addi	r2,r2,16
  41500c:	10800037 	ldwio	r2,0(r2)
  415010:	10bfffcc 	andi	r2,r2,65535
  415014:	e0bffe15 	stw	r2,-8(fp)
        alt_timestamp_type upper = IORD_ALTERA_AVALON_TIMER_SNAPH(base) & ALTERA_AVALON_TIMER_SNAPH_MSK;
  415018:	e0bffd17 	ldw	r2,-12(fp)
  41501c:	10800504 	addi	r2,r2,20
  415020:	10800037 	ldwio	r2,0(r2)
  415024:	10bfffcc 	andi	r2,r2,65535
  415028:	e0bfff15 	stw	r2,-4(fp)
        
        return (0xFFFFFFFF - ((upper << 16) | lower)); 
  41502c:	e0bfff17 	ldw	r2,-4(fp)
  415030:	1006943a 	slli	r3,r2,16
  415034:	e0bffe17 	ldw	r2,-8(fp)
  415038:	1884b03a 	or	r2,r3,r2
  41503c:	0084303a 	nor	r2,zero,r2
#endif
  }
}
  415040:	e037883a 	mov	sp,fp
  415044:	df000017 	ldw	fp,0(sp)
  415048:	dec00104 	addi	sp,sp,4
  41504c:	f800283a 	ret

00415050 <alt_timestamp_freq>:
 * Return the number of timestamp ticks per second. This will be 0 if no
 * timestamp device has been registered.
 */

alt_u32 alt_timestamp_freq(void)
{
  415050:	deffff04 	addi	sp,sp,-4
  415054:	df000015 	stw	fp,0(sp)
  415058:	d839883a 	mov	fp,sp
  return altera_avalon_timer_ts_freq;
  41505c:	00801074 	movhi	r2,65
  415060:	109f3804 	addi	r2,r2,31968
  415064:	10800017 	ldw	r2,0(r2)
}
  415068:	e037883a 	mov	sp,fp
  41506c:	df000017 	ldw	fp,0(sp)
  415070:	dec00104 	addi	sp,sp,4
  415074:	f800283a 	ret

00415078 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  415078:	defffa04 	addi	sp,sp,-24
  41507c:	dfc00515 	stw	ra,20(sp)
  415080:	df000415 	stw	fp,16(sp)
  415084:	df000404 	addi	fp,sp,16
  415088:	e13ffd15 	stw	r4,-12(fp)
  41508c:	e17ffe15 	stw	r5,-8(fp)
  415090:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  415094:	e0bffd17 	ldw	r2,-12(fp)
  415098:	10800017 	ldw	r2,0(r2)
  41509c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
  4150a0:	e0bffc17 	ldw	r2,-16(fp)
  4150a4:	10c00a04 	addi	r3,r2,40
  4150a8:	e0bffd17 	ldw	r2,-12(fp)
  4150ac:	10800217 	ldw	r2,8(r2)
  4150b0:	1809883a 	mov	r4,r3
  4150b4:	e17ffe17 	ldw	r5,-8(fp)
  4150b8:	e1bfff17 	ldw	r6,-4(fp)
  4150bc:	100f883a 	mov	r7,r2
  4150c0:	04155900 	call	415590 <altera_avalon_uart_read>
      fd->fd_flags);
}
  4150c4:	e037883a 	mov	sp,fp
  4150c8:	dfc00117 	ldw	ra,4(sp)
  4150cc:	df000017 	ldw	fp,0(sp)
  4150d0:	dec00204 	addi	sp,sp,8
  4150d4:	f800283a 	ret

004150d8 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  4150d8:	defffa04 	addi	sp,sp,-24
  4150dc:	dfc00515 	stw	ra,20(sp)
  4150e0:	df000415 	stw	fp,16(sp)
  4150e4:	df000404 	addi	fp,sp,16
  4150e8:	e13ffd15 	stw	r4,-12(fp)
  4150ec:	e17ffe15 	stw	r5,-8(fp)
  4150f0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  4150f4:	e0bffd17 	ldw	r2,-12(fp)
  4150f8:	10800017 	ldw	r2,0(r2)
  4150fc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
  415100:	e0bffc17 	ldw	r2,-16(fp)
  415104:	10c00a04 	addi	r3,r2,40
  415108:	e0bffd17 	ldw	r2,-12(fp)
  41510c:	10800217 	ldw	r2,8(r2)
  415110:	1809883a 	mov	r4,r3
  415114:	e17ffe17 	ldw	r5,-8(fp)
  415118:	e1bfff17 	ldw	r6,-4(fp)
  41511c:	100f883a 	mov	r7,r2
  415120:	04157bc0 	call	4157bc <altera_avalon_uart_write>
      fd->fd_flags);
}
  415124:	e037883a 	mov	sp,fp
  415128:	dfc00117 	ldw	ra,4(sp)
  41512c:	df000017 	ldw	fp,0(sp)
  415130:	dec00204 	addi	sp,sp,8
  415134:	f800283a 	ret

00415138 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
  415138:	defffc04 	addi	sp,sp,-16
  41513c:	dfc00315 	stw	ra,12(sp)
  415140:	df000215 	stw	fp,8(sp)
  415144:	df000204 	addi	fp,sp,8
  415148:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  41514c:	e0bfff17 	ldw	r2,-4(fp)
  415150:	10800017 	ldw	r2,0(r2)
  415154:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
  415158:	e0bffe17 	ldw	r2,-8(fp)
  41515c:	10c00a04 	addi	r3,r2,40
  415160:	e0bfff17 	ldw	r2,-4(fp)
  415164:	10800217 	ldw	r2,8(r2)
  415168:	1809883a 	mov	r4,r3
  41516c:	100b883a 	mov	r5,r2
  415170:	04154ec0 	call	4154ec <altera_avalon_uart_close>
}
  415174:	e037883a 	mov	sp,fp
  415178:	dfc00117 	ldw	ra,4(sp)
  41517c:	df000017 	ldw	fp,0(sp)
  415180:	dec00204 	addi	sp,sp,8
  415184:	f800283a 	ret

00415188 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
  415188:	defff804 	addi	sp,sp,-32
  41518c:	dfc00715 	stw	ra,28(sp)
  415190:	df000615 	stw	fp,24(sp)
  415194:	df000604 	addi	fp,sp,24
  415198:	e13ffd15 	stw	r4,-12(fp)
  41519c:	e17ffe15 	stw	r5,-8(fp)
  4151a0:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
  4151a4:	e0bffd17 	ldw	r2,-12(fp)
  4151a8:	10800017 	ldw	r2,0(r2)
  4151ac:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
  4151b0:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  4151b4:	1000041e 	bne	r2,zero,4151c8 <altera_avalon_uart_init+0x40>
  4151b8:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  4151bc:	1000021e 	bne	r2,zero,4151c8 <altera_avalon_uart_init+0x40>
  4151c0:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  4151c4:	10000226 	beq	r2,zero,4151d0 <altera_avalon_uart_init+0x48>
  4151c8:	00800044 	movi	r2,1
  4151cc:	00000106 	br	4151d4 <altera_avalon_uart_init+0x4c>
  4151d0:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  4151d4:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
  4151d8:	e0bffc17 	ldw	r2,-16(fp)
  4151dc:	10000f1e 	bne	r2,zero,41521c <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
  4151e0:	e0bffd17 	ldw	r2,-12(fp)
  4151e4:	00c32004 	movi	r3,3200
  4151e8:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
  4151ec:	e0bffb17 	ldw	r2,-20(fp)
  4151f0:	10800304 	addi	r2,r2,12
  4151f4:	e0fffd17 	ldw	r3,-12(fp)
  4151f8:	18c00117 	ldw	r3,4(r3)
  4151fc:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
  415200:	d8000015 	stw	zero,0(sp)
  415204:	e13ffe17 	ldw	r4,-8(fp)
  415208:	e17fff17 	ldw	r5,-4(fp)
  41520c:	01801074 	movhi	r6,65
  415210:	31948c04 	addi	r6,r6,21040
  415214:	e1fffd17 	ldw	r7,-12(fp)
  415218:	0413bd80 	call	413bd8 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
  41521c:	e037883a 	mov	sp,fp
  415220:	dfc00117 	ldw	ra,4(sp)
  415224:	df000017 	ldw	fp,0(sp)
  415228:	dec00204 	addi	sp,sp,8
  41522c:	f800283a 	ret

00415230 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
  415230:	defffa04 	addi	sp,sp,-24
  415234:	dfc00515 	stw	ra,20(sp)
  415238:	df000415 	stw	fp,16(sp)
  41523c:	df000404 	addi	fp,sp,16
  415240:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
  415244:	e0bfff17 	ldw	r2,-4(fp)
  415248:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
  41524c:	e0bffc17 	ldw	r2,-16(fp)
  415250:	10800017 	ldw	r2,0(r2)
  415254:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
  415258:	e0bffd17 	ldw	r2,-12(fp)
  41525c:	10800204 	addi	r2,r2,8
  415260:	10800037 	ldwio	r2,0(r2)
  415264:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
  415268:	e0bffd17 	ldw	r2,-12(fp)
  41526c:	10800204 	addi	r2,r2,8
  415270:	0007883a 	mov	r3,zero
  415274:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
  415278:	e0bffd17 	ldw	r2,-12(fp)
  41527c:	10800204 	addi	r2,r2,8
  415280:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  415284:	e0bffe17 	ldw	r2,-8(fp)
  415288:	1080200c 	andi	r2,r2,128
  41528c:	10000326 	beq	r2,zero,41529c <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
  415290:	e13ffc17 	ldw	r4,-16(fp)
  415294:	e17ffe17 	ldw	r5,-8(fp)
  415298:	04152c80 	call	4152c8 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
  41529c:	e0bffe17 	ldw	r2,-8(fp)
  4152a0:	1081100c 	andi	r2,r2,1088
  4152a4:	10000326 	beq	r2,zero,4152b4 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
  4152a8:	e13ffc17 	ldw	r4,-16(fp)
  4152ac:	e17ffe17 	ldw	r5,-8(fp)
  4152b0:	04153a80 	call	4153a8 <altera_avalon_uart_txirq>
  }
  

}
  4152b4:	e037883a 	mov	sp,fp
  4152b8:	dfc00117 	ldw	ra,4(sp)
  4152bc:	df000017 	ldw	fp,0(sp)
  4152c0:	dec00204 	addi	sp,sp,8
  4152c4:	f800283a 	ret

004152c8 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  4152c8:	defffc04 	addi	sp,sp,-16
  4152cc:	df000315 	stw	fp,12(sp)
  4152d0:	df000304 	addi	fp,sp,12
  4152d4:	e13ffe15 	stw	r4,-8(fp)
  4152d8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
  4152dc:	e0bfff17 	ldw	r2,-4(fp)
  4152e0:	108000cc 	andi	r2,r2,3
  4152e4:	10000126 	beq	r2,zero,4152ec <altera_avalon_uart_rxirq+0x24>
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
  4152e8:	00002b06 	br	415398 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
  4152ec:	e0bffe17 	ldw	r2,-8(fp)
  4152f0:	10800317 	ldw	r2,12(r2)
  4152f4:	e0bffe17 	ldw	r2,-8(fp)
  4152f8:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  4152fc:	e0bffe17 	ldw	r2,-8(fp)
  415300:	10800317 	ldw	r2,12(r2)
  415304:	10800044 	addi	r2,r2,1
  415308:	10800fcc 	andi	r2,r2,63
  41530c:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
  415310:	e0bffe17 	ldw	r2,-8(fp)
  415314:	10800317 	ldw	r2,12(r2)
  415318:	e0fffe17 	ldw	r3,-8(fp)
  41531c:	18c00017 	ldw	r3,0(r3)
  415320:	18c00037 	ldwio	r3,0(r3)
  415324:	1809883a 	mov	r4,r3
  415328:	e0fffe17 	ldw	r3,-8(fp)
  41532c:	1885883a 	add	r2,r3,r2
  415330:	10800704 	addi	r2,r2,28
  415334:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
  415338:	e0bffe17 	ldw	r2,-8(fp)
  41533c:	e0fffd17 	ldw	r3,-12(fp)
  415340:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  415344:	e0bffe17 	ldw	r2,-8(fp)
  415348:	10800317 	ldw	r2,12(r2)
  41534c:	10800044 	addi	r2,r2,1
  415350:	10800fcc 	andi	r2,r2,63
  415354:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
  415358:	e0bffe17 	ldw	r2,-8(fp)
  41535c:	10c00217 	ldw	r3,8(r2)
  415360:	e0bffd17 	ldw	r2,-12(fp)
  415364:	18800c1e 	bne	r3,r2,415398 <altera_avalon_uart_rxirq+0xd0>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  415368:	e0bffe17 	ldw	r2,-8(fp)
  41536c:	10c00117 	ldw	r3,4(r2)
  415370:	00bfdfc4 	movi	r2,-129
  415374:	1886703a 	and	r3,r3,r2
  415378:	e0bffe17 	ldw	r2,-8(fp)
  41537c:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  415380:	e0bffe17 	ldw	r2,-8(fp)
  415384:	10800017 	ldw	r2,0(r2)
  415388:	10800304 	addi	r2,r2,12
  41538c:	e0fffe17 	ldw	r3,-8(fp)
  415390:	18c00117 	ldw	r3,4(r3)
  415394:	10c00035 	stwio	r3,0(r2)
  }   
}
  415398:	e037883a 	mov	sp,fp
  41539c:	df000017 	ldw	fp,0(sp)
  4153a0:	dec00104 	addi	sp,sp,4
  4153a4:	f800283a 	ret

004153a8 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  4153a8:	defffb04 	addi	sp,sp,-20
  4153ac:	df000415 	stw	fp,16(sp)
  4153b0:	df000404 	addi	fp,sp,16
  4153b4:	e13ffc15 	stw	r4,-16(fp)
  4153b8:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
  4153bc:	e0bffc17 	ldw	r2,-16(fp)
  4153c0:	10c00417 	ldw	r3,16(r2)
  4153c4:	e0bffc17 	ldw	r2,-16(fp)
  4153c8:	10800517 	ldw	r2,20(r2)
  4153cc:	18803226 	beq	r3,r2,415498 <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  4153d0:	e0bffc17 	ldw	r2,-16(fp)
  4153d4:	10800617 	ldw	r2,24(r2)
  4153d8:	1080008c 	andi	r2,r2,2
  4153dc:	10000326 	beq	r2,zero,4153ec <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  4153e0:	e0bffd17 	ldw	r2,-12(fp)
  4153e4:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  4153e8:	10001d26 	beq	r2,zero,415460 <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
  4153ec:	e0bffc17 	ldw	r2,-16(fp)
  4153f0:	10800417 	ldw	r2,16(r2)
  4153f4:	e0bffc17 	ldw	r2,-16(fp)
  4153f8:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
  4153fc:	e0bffc17 	ldw	r2,-16(fp)
  415400:	10800017 	ldw	r2,0(r2)
  415404:	10800104 	addi	r2,r2,4
  415408:	e0fffc17 	ldw	r3,-16(fp)
  41540c:	18c00417 	ldw	r3,16(r3)
  415410:	e13ffc17 	ldw	r4,-16(fp)
  415414:	20c7883a 	add	r3,r4,r3
  415418:	18c01704 	addi	r3,r3,92
  41541c:	18c00003 	ldbu	r3,0(r3)
  415420:	18c03fcc 	andi	r3,r3,255
  415424:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
  415428:	e0bffc17 	ldw	r2,-16(fp)
  41542c:	10800417 	ldw	r2,16(r2)
  415430:	10800044 	addi	r2,r2,1
  415434:	e0fffc17 	ldw	r3,-16(fp)
  415438:	18800415 	stw	r2,16(r3)
  41543c:	10c00fcc 	andi	r3,r2,63
  415440:	e0bffc17 	ldw	r2,-16(fp)
  415444:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  415448:	e0bffc17 	ldw	r2,-16(fp)
  41544c:	10800117 	ldw	r2,4(r2)
  415450:	10c01014 	ori	r3,r2,64
  415454:	e0bffc17 	ldw	r2,-16(fp)
  415458:	10c00115 	stw	r3,4(r2)
  41545c:	00000e06 	br	415498 <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
  415460:	e0bffc17 	ldw	r2,-16(fp)
  415464:	10800017 	ldw	r2,0(r2)
  415468:	10800204 	addi	r2,r2,8
  41546c:	10800037 	ldwio	r2,0(r2)
  415470:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  415474:	e0bffd17 	ldw	r2,-12(fp)
  415478:	1082000c 	andi	r2,r2,2048
  41547c:	1000061e 	bne	r2,zero,415498 <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  415480:	e0bffc17 	ldw	r2,-16(fp)
  415484:	10c00117 	ldw	r3,4(r2)
  415488:	00bfefc4 	movi	r2,-65
  41548c:	1886703a 	and	r3,r3,r2
  415490:	e0bffc17 	ldw	r2,-16(fp)
  415494:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
  415498:	e0bffc17 	ldw	r2,-16(fp)
  41549c:	10c00417 	ldw	r3,16(r2)
  4154a0:	e0bffc17 	ldw	r2,-16(fp)
  4154a4:	10800517 	ldw	r2,20(r2)
  4154a8:	1880061e 	bne	r3,r2,4154c4 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  4154ac:	e0bffc17 	ldw	r2,-16(fp)
  4154b0:	10c00117 	ldw	r3,4(r2)
  4154b4:	00beefc4 	movi	r2,-1089
  4154b8:	1886703a 	and	r3,r3,r2
  4154bc:	e0bffc17 	ldw	r2,-16(fp)
  4154c0:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  4154c4:	e0bffc17 	ldw	r2,-16(fp)
  4154c8:	10800017 	ldw	r2,0(r2)
  4154cc:	10800304 	addi	r2,r2,12
  4154d0:	e0fffc17 	ldw	r3,-16(fp)
  4154d4:	18c00117 	ldw	r3,4(r3)
  4154d8:	10c00035 	stwio	r3,0(r2)
}
  4154dc:	e037883a 	mov	sp,fp
  4154e0:	df000017 	ldw	fp,0(sp)
  4154e4:	dec00104 	addi	sp,sp,4
  4154e8:	f800283a 	ret

004154ec <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  4154ec:	defffd04 	addi	sp,sp,-12
  4154f0:	df000215 	stw	fp,8(sp)
  4154f4:	df000204 	addi	fp,sp,8
  4154f8:	e13ffe15 	stw	r4,-8(fp)
  4154fc:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  415500:	00000506 	br	415518 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  415504:	e0bfff17 	ldw	r2,-4(fp)
  415508:	1090000c 	andi	r2,r2,16384
  41550c:	10000226 	beq	r2,zero,415518 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
  415510:	00bffd44 	movi	r2,-11
  415514:	00000606 	br	415530 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  415518:	e0bffe17 	ldw	r2,-8(fp)
  41551c:	10c00417 	ldw	r3,16(r2)
  415520:	e0bffe17 	ldw	r2,-8(fp)
  415524:	10800517 	ldw	r2,20(r2)
  415528:	18bff61e 	bne	r3,r2,415504 <_gp+0xffff5d08>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  41552c:	0005883a 	mov	r2,zero
}
  415530:	e037883a 	mov	sp,fp
  415534:	df000017 	ldw	fp,0(sp)
  415538:	dec00104 	addi	sp,sp,4
  41553c:	f800283a 	ret

00415540 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  415540:	defffe04 	addi	sp,sp,-8
  415544:	dfc00115 	stw	ra,4(sp)
  415548:	df000015 	stw	fp,0(sp)
  41554c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  415550:	00801074 	movhi	r2,65
  415554:	109e0704 	addi	r2,r2,30748
  415558:	10800017 	ldw	r2,0(r2)
  41555c:	10000526 	beq	r2,zero,415574 <alt_get_errno+0x34>
  415560:	00801074 	movhi	r2,65
  415564:	109e0704 	addi	r2,r2,30748
  415568:	10800017 	ldw	r2,0(r2)
  41556c:	103ee83a 	callr	r2
  415570:	00000206 	br	41557c <alt_get_errno+0x3c>
  415574:	00801074 	movhi	r2,65
  415578:	109f3c04 	addi	r2,r2,31984
}
  41557c:	e037883a 	mov	sp,fp
  415580:	dfc00117 	ldw	ra,4(sp)
  415584:	df000017 	ldw	fp,0(sp)
  415588:	dec00204 	addi	sp,sp,8
  41558c:	f800283a 	ret

00415590 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
  415590:	defff204 	addi	sp,sp,-56
  415594:	dfc00d15 	stw	ra,52(sp)
  415598:	df000c15 	stw	fp,48(sp)
  41559c:	df000c04 	addi	fp,sp,48
  4155a0:	e13ffc15 	stw	r4,-16(fp)
  4155a4:	e17ffd15 	stw	r5,-12(fp)
  4155a8:	e1bffe15 	stw	r6,-8(fp)
  4155ac:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
  4155b0:	e03ff405 	stb	zero,-48(fp)
  int             count = 0;
  4155b4:	e03ff515 	stw	zero,-44(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
  4155b8:	e0bfff17 	ldw	r2,-4(fp)
  4155bc:	1090000c 	andi	r2,r2,16384
  4155c0:	1005003a 	cmpeq	r2,r2,zero
  4155c4:	10803fcc 	andi	r2,r2,255
  4155c8:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  4155cc:	00001306 	br	41561c <altera_avalon_uart_read+0x8c>
    {
      count++;
  4155d0:	e0bff517 	ldw	r2,-44(fp)
  4155d4:	10800044 	addi	r2,r2,1
  4155d8:	e0bff515 	stw	r2,-44(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
  4155dc:	e0bffd17 	ldw	r2,-12(fp)
  4155e0:	10c00044 	addi	r3,r2,1
  4155e4:	e0fffd15 	stw	r3,-12(fp)
  4155e8:	e0fffc17 	ldw	r3,-16(fp)
  4155ec:	18c00217 	ldw	r3,8(r3)
  4155f0:	e13ffc17 	ldw	r4,-16(fp)
  4155f4:	20c7883a 	add	r3,r4,r3
  4155f8:	18c00704 	addi	r3,r3,28
  4155fc:	18c00003 	ldbu	r3,0(r3)
  415600:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
  415604:	e0bffc17 	ldw	r2,-16(fp)
  415608:	10800217 	ldw	r2,8(r2)
  41560c:	10800044 	addi	r2,r2,1
  415610:	10c00fcc 	andi	r3,r2,63
  415614:	e0bffc17 	ldw	r2,-16(fp)
  415618:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  41561c:	e0fff517 	ldw	r3,-44(fp)
  415620:	e0bffe17 	ldw	r2,-8(fp)
  415624:	1880050e 	bge	r3,r2,41563c <altera_avalon_uart_read+0xac>
  415628:	e0bffc17 	ldw	r2,-16(fp)
  41562c:	10c00217 	ldw	r3,8(r2)
  415630:	e0bffc17 	ldw	r2,-16(fp)
  415634:	10800317 	ldw	r2,12(r2)
  415638:	18bfe51e 	bne	r3,r2,4155d0 <_gp+0xffff5dd4>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
  41563c:	e0bff517 	ldw	r2,-44(fp)
  415640:	1000251e 	bne	r2,zero,4156d8 <altera_avalon_uart_read+0x148>
  415644:	e0bffc17 	ldw	r2,-16(fp)
  415648:	10c00217 	ldw	r3,8(r2)
  41564c:	e0bffc17 	ldw	r2,-16(fp)
  415650:	10800317 	ldw	r2,12(r2)
  415654:	1880201e 	bne	r3,r2,4156d8 <altera_avalon_uart_read+0x148>
    {
      if (!block)
  415658:	e0bff617 	ldw	r2,-40(fp)
  41565c:	1000071e 	bne	r2,zero,41567c <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
  415660:	04155400 	call	415540 <alt_get_errno>
  415664:	1007883a 	mov	r3,r2
  415668:	008002c4 	movi	r2,11
  41566c:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
  415670:	00800044 	movi	r2,1
  415674:	e0bff405 	stb	r2,-48(fp)
        break;
  415678:	00001b06 	br	4156e8 <altera_avalon_uart_read+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  41567c:	0005303a 	rdctl	r2,status
  415680:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  415684:	e0fff817 	ldw	r3,-32(fp)
  415688:	00bfff84 	movi	r2,-2
  41568c:	1884703a 	and	r2,r3,r2
  415690:	1001703a 	wrctl	status,r2
  
  return context;
  415694:	e0bff817 	ldw	r2,-32(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
  415698:	e0bff715 	stw	r2,-36(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  41569c:	e0bffc17 	ldw	r2,-16(fp)
  4156a0:	10800117 	ldw	r2,4(r2)
  4156a4:	10c02014 	ori	r3,r2,128
  4156a8:	e0bffc17 	ldw	r2,-16(fp)
  4156ac:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  4156b0:	e0bffc17 	ldw	r2,-16(fp)
  4156b4:	10800017 	ldw	r2,0(r2)
  4156b8:	10800304 	addi	r2,r2,12
  4156bc:	e0fffc17 	ldw	r3,-16(fp)
  4156c0:	18c00117 	ldw	r3,4(r3)
  4156c4:	10c00035 	stwio	r3,0(r2)
  4156c8:	e0bff717 	ldw	r2,-36(fp)
  4156cc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  4156d0:	e0bff917 	ldw	r2,-28(fp)
  4156d4:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
  4156d8:	e0bff517 	ldw	r2,-44(fp)
  4156dc:	1000021e 	bne	r2,zero,4156e8 <altera_avalon_uart_read+0x158>
  4156e0:	e0bffe17 	ldw	r2,-8(fp)
  4156e4:	103fb91e 	bne	r2,zero,4155cc <_gp+0xffff5dd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4156e8:	0005303a 	rdctl	r2,status
  4156ec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4156f0:	e0fffa17 	ldw	r3,-24(fp)
  4156f4:	00bfff84 	movi	r2,-2
  4156f8:	1884703a 	and	r2,r3,r2
  4156fc:	1001703a 	wrctl	status,r2
  
  return context;
  415700:	e0bffa17 	ldw	r2,-24(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
  415704:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  415708:	e0bffc17 	ldw	r2,-16(fp)
  41570c:	10800117 	ldw	r2,4(r2)
  415710:	10c02014 	ori	r3,r2,128
  415714:	e0bffc17 	ldw	r2,-16(fp)
  415718:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  41571c:	e0bffc17 	ldw	r2,-16(fp)
  415720:	10800017 	ldw	r2,0(r2)
  415724:	10800304 	addi	r2,r2,12
  415728:	e0fffc17 	ldw	r3,-16(fp)
  41572c:	18c00117 	ldw	r3,4(r3)
  415730:	10c00035 	stwio	r3,0(r2)
  415734:	e0bff717 	ldw	r2,-36(fp)
  415738:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  41573c:	e0bffb17 	ldw	r2,-20(fp)
  415740:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
  415744:	e0bff403 	ldbu	r2,-48(fp)
  415748:	10000226 	beq	r2,zero,415754 <altera_avalon_uart_read+0x1c4>
    return -EWOULDBLOCK;
  41574c:	00bffd44 	movi	r2,-11
  415750:	00000106 	br	415758 <altera_avalon_uart_read+0x1c8>
  }
  else {
    return count;
  415754:	e0bff517 	ldw	r2,-44(fp)
  }
}
  415758:	e037883a 	mov	sp,fp
  41575c:	dfc00117 	ldw	ra,4(sp)
  415760:	df000017 	ldw	fp,0(sp)
  415764:	dec00204 	addi	sp,sp,8
  415768:	f800283a 	ret

0041576c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  41576c:	defffe04 	addi	sp,sp,-8
  415770:	dfc00115 	stw	ra,4(sp)
  415774:	df000015 	stw	fp,0(sp)
  415778:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  41577c:	00801074 	movhi	r2,65
  415780:	109e0704 	addi	r2,r2,30748
  415784:	10800017 	ldw	r2,0(r2)
  415788:	10000526 	beq	r2,zero,4157a0 <alt_get_errno+0x34>
  41578c:	00801074 	movhi	r2,65
  415790:	109e0704 	addi	r2,r2,30748
  415794:	10800017 	ldw	r2,0(r2)
  415798:	103ee83a 	callr	r2
  41579c:	00000206 	br	4157a8 <alt_get_errno+0x3c>
  4157a0:	00801074 	movhi	r2,65
  4157a4:	109f3c04 	addi	r2,r2,31984
}
  4157a8:	e037883a 	mov	sp,fp
  4157ac:	dfc00117 	ldw	ra,4(sp)
  4157b0:	df000017 	ldw	fp,0(sp)
  4157b4:	dec00204 	addi	sp,sp,8
  4157b8:	f800283a 	ret

004157bc <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
  4157bc:	defff204 	addi	sp,sp,-56
  4157c0:	dfc00d15 	stw	ra,52(sp)
  4157c4:	df000c15 	stw	fp,48(sp)
  4157c8:	df000c04 	addi	fp,sp,48
  4157cc:	e13ffc15 	stw	r4,-16(fp)
  4157d0:	e17ffd15 	stw	r5,-12(fp)
  4157d4:	e1bffe15 	stw	r6,-8(fp)
  4157d8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
  4157dc:	e0bffe17 	ldw	r2,-8(fp)
  4157e0:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
  4157e4:	e0bfff17 	ldw	r2,-4(fp)
  4157e8:	1090000c 	andi	r2,r2,16384
  4157ec:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  4157f0:	00003c06 	br	4158e4 <altera_avalon_uart_write+0x128>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  4157f4:	e0bffc17 	ldw	r2,-16(fp)
  4157f8:	10800517 	ldw	r2,20(r2)
  4157fc:	10800044 	addi	r2,r2,1
  415800:	10800fcc 	andi	r2,r2,63
  415804:	e0bff615 	stw	r2,-40(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
  415808:	e0bffc17 	ldw	r2,-16(fp)
  41580c:	10c00417 	ldw	r3,16(r2)
  415810:	e0bff617 	ldw	r2,-40(fp)
  415814:	1880221e 	bne	r3,r2,4158a0 <altera_avalon_uart_write+0xe4>
    {
      if (no_block)
  415818:	e0bff517 	ldw	r2,-44(fp)
  41581c:	10000526 	beq	r2,zero,415834 <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
  415820:	041576c0 	call	41576c <alt_get_errno>
  415824:	1007883a 	mov	r3,r2
  415828:	008002c4 	movi	r2,11
  41582c:	18800015 	stw	r2,0(r3)
        break;
  415830:	00002e06 	br	4158ec <altera_avalon_uart_write+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  415834:	0005303a 	rdctl	r2,status
  415838:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  41583c:	e0fff817 	ldw	r3,-32(fp)
  415840:	00bfff84 	movi	r2,-2
  415844:	1884703a 	and	r2,r3,r2
  415848:	1001703a 	wrctl	status,r2
  
  return context;
  41584c:	e0bff817 	ldw	r2,-32(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
  415850:	e0bff715 	stw	r2,-36(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  415854:	e0bffc17 	ldw	r2,-16(fp)
  415858:	10800117 	ldw	r2,4(r2)
  41585c:	10c11014 	ori	r3,r2,1088
  415860:	e0bffc17 	ldw	r2,-16(fp)
  415864:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  415868:	e0bffc17 	ldw	r2,-16(fp)
  41586c:	10800017 	ldw	r2,0(r2)
  415870:	10800304 	addi	r2,r2,12
  415874:	e0fffc17 	ldw	r3,-16(fp)
  415878:	18c00117 	ldw	r3,4(r3)
  41587c:	10c00035 	stwio	r3,0(r2)
  415880:	e0bff717 	ldw	r2,-36(fp)
  415884:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  415888:	e0bff917 	ldw	r2,-28(fp)
  41588c:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
  415890:	e0bffc17 	ldw	r2,-16(fp)
  415894:	10c00417 	ldw	r3,16(r2)
  415898:	e0bff617 	ldw	r2,-40(fp)
  41589c:	18bffc26 	beq	r3,r2,415890 <_gp+0xffff6094>
      }
    }

    count--;
  4158a0:	e0bff417 	ldw	r2,-48(fp)
  4158a4:	10bfffc4 	addi	r2,r2,-1
  4158a8:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
  4158ac:	e0bffc17 	ldw	r2,-16(fp)
  4158b0:	10c00517 	ldw	r3,20(r2)
  4158b4:	e0bffd17 	ldw	r2,-12(fp)
  4158b8:	11000044 	addi	r4,r2,1
  4158bc:	e13ffd15 	stw	r4,-12(fp)
  4158c0:	10800003 	ldbu	r2,0(r2)
  4158c4:	1009883a 	mov	r4,r2
  4158c8:	e0bffc17 	ldw	r2,-16(fp)
  4158cc:	10c5883a 	add	r2,r2,r3
  4158d0:	10801704 	addi	r2,r2,92
  4158d4:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
  4158d8:	e0bffc17 	ldw	r2,-16(fp)
  4158dc:	e0fff617 	ldw	r3,-40(fp)
  4158e0:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  4158e4:	e0bff417 	ldw	r2,-48(fp)
  4158e8:	103fc21e 	bne	r2,zero,4157f4 <_gp+0xffff5ff8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4158ec:	0005303a 	rdctl	r2,status
  4158f0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4158f4:	e0fffa17 	ldw	r3,-24(fp)
  4158f8:	00bfff84 	movi	r2,-2
  4158fc:	1884703a 	and	r2,r3,r2
  415900:	1001703a 	wrctl	status,r2
  
  return context;
  415904:	e0bffa17 	ldw	r2,-24(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
  415908:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  41590c:	e0bffc17 	ldw	r2,-16(fp)
  415910:	10800117 	ldw	r2,4(r2)
  415914:	10c11014 	ori	r3,r2,1088
  415918:	e0bffc17 	ldw	r2,-16(fp)
  41591c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  415920:	e0bffc17 	ldw	r2,-16(fp)
  415924:	10800017 	ldw	r2,0(r2)
  415928:	10800304 	addi	r2,r2,12
  41592c:	e0fffc17 	ldw	r3,-16(fp)
  415930:	18c00117 	ldw	r3,4(r3)
  415934:	10c00035 	stwio	r3,0(r2)
  415938:	e0bff717 	ldw	r2,-36(fp)
  41593c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  415940:	e0bffb17 	ldw	r2,-20(fp)
  415944:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
  415948:	e0fffe17 	ldw	r3,-8(fp)
  41594c:	e0bff417 	ldw	r2,-48(fp)
  415950:	1885c83a 	sub	r2,r3,r2
}
  415954:	e037883a 	mov	sp,fp
  415958:	dfc00117 	ldw	ra,4(sp)
  41595c:	df000017 	ldw	fp,0(sp)
  415960:	dec00204 	addi	sp,sp,8
  415964:	f800283a 	ret

00415968 <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
  415968:	defff904 	addi	sp,sp,-28
  41596c:	dfc00615 	stw	ra,24(sp)
  415970:	df000515 	stw	fp,20(sp)
  415974:	df000504 	addi	fp,sp,20
  415978:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
  41597c:	00800144 	movi	r2,5
  415980:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
  415984:	00800044 	movi	r2,1
  415988:	d8800015 	stw	r2,0(sp)
  41598c:	e0bffe44 	addi	r2,fp,-7
  415990:	d8800115 	stw	r2,4(sp)
  415994:	d8000215 	stw	zero,8(sp)
  415998:	e13fff17 	ldw	r4,-4(fp)
  41599c:	000b883a 	mov	r5,zero
  4159a0:	01800044 	movi	r6,1
  4159a4:	e1fffe04 	addi	r7,fp,-8
  4159a8:	0416a580 	call	416a58 <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
  4159ac:	e0bffe43 	ldbu	r2,-7(fp)
}
  4159b0:	e037883a 	mov	sp,fp
  4159b4:	dfc00117 	ldw	ra,4(sp)
  4159b8:	df000017 	ldw	fp,0(sp)
  4159bc:	dec00204 	addi	sp,sp,8
  4159c0:	f800283a 	ret

004159c4 <epcs_test_wip>:

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
  4159c4:	defffd04 	addi	sp,sp,-12
  4159c8:	dfc00215 	stw	ra,8(sp)
  4159cc:	df000115 	stw	fp,4(sp)
  4159d0:	df000104 	addi	fp,sp,4
  4159d4:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
  4159d8:	e13fff17 	ldw	r4,-4(fp)
  4159dc:	04159680 	call	415968 <epcs_read_status_register>
  4159e0:	10803fcc 	andi	r2,r2,255
  4159e4:	1080004c 	andi	r2,r2,1
}
  4159e8:	e037883a 	mov	sp,fp
  4159ec:	dfc00117 	ldw	ra,4(sp)
  4159f0:	df000017 	ldw	fp,0(sp)
  4159f4:	dec00204 	addi	sp,sp,8
  4159f8:	f800283a 	ret

004159fc <epcs_await_wip_released>:

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
  4159fc:	defffd04 	addi	sp,sp,-12
  415a00:	dfc00215 	stw	ra,8(sp)
  415a04:	df000115 	stw	fp,4(sp)
  415a08:	df000104 	addi	fp,sp,4
  415a0c:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
  415a10:	0001883a 	nop
  415a14:	e13fff17 	ldw	r4,-4(fp)
  415a18:	04159c40 	call	4159c4 <epcs_test_wip>
  415a1c:	103ffd1e 	bne	r2,zero,415a14 <_gp+0xffff6218>
  {
  }
}
  415a20:	e037883a 	mov	sp,fp
  415a24:	dfc00117 	ldw	ra,4(sp)
  415a28:	df000017 	ldw	fp,0(sp)
  415a2c:	dec00204 	addi	sp,sp,8
  415a30:	f800283a 	ret

00415a34 <epcs_sector_erase>:

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
  415a34:	defff604 	addi	sp,sp,-40
  415a38:	dfc00915 	stw	ra,36(sp)
  415a3c:	df000815 	stw	fp,32(sp)
  415a40:	df000804 	addi	fp,sp,32
  415a44:	e13ffd15 	stw	r4,-12(fp)
  415a48:	e17ffe15 	stw	r5,-8(fp)
  415a4c:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
  415a50:	e0bfff17 	ldw	r2,-4(fp)
  415a54:	10001226 	beq	r2,zero,415aa0 <epcs_sector_erase+0x6c>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
  415a58:	00bff604 	movi	r2,-40
  415a5c:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
  415a60:	e0bffe17 	ldw	r2,-8(fp)
  415a64:	1004d63a 	srli	r2,r2,24
  415a68:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
  415a6c:	e0bffe17 	ldw	r2,-8(fp)
  415a70:	1004d43a 	srli	r2,r2,16
  415a74:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
  415a78:	e0bffe17 	ldw	r2,-8(fp)
  415a7c:	1004d23a 	srli	r2,r2,8
  415a80:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
  415a84:	e0bffe17 	ldw	r2,-8(fp)
  415a88:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
  415a8c:	00800144 	movi	r2,5
  415a90:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
  415a94:	e13ffd17 	ldw	r4,-12(fp)
  415a98:	0415edc0 	call	415edc <epcs_enter_4_bytes_mode>
  415a9c:	00000c06 	br	415ad0 <epcs_sector_erase+0x9c>
  }
  else
  {
      se[0] = epcs_se;
  415aa0:	00bff604 	movi	r2,-40
  415aa4:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
  415aa8:	e0bffe17 	ldw	r2,-8(fp)
  415aac:	1004d43a 	srli	r2,r2,16
  415ab0:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
  415ab4:	e0bffe17 	ldw	r2,-8(fp)
  415ab8:	1004d23a 	srli	r2,r2,8
  415abc:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
  415ac0:	e0bffe17 	ldw	r2,-8(fp)
  415ac4:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
  415ac8:	00800104 	movi	r2,4
  415acc:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
  415ad0:	e13ffd17 	ldw	r4,-12(fp)
  415ad4:	0415c200 	call	415c20 <epcs_write_enable>

  alt_avalon_spi_command(
  415ad8:	e0fffb03 	ldbu	r3,-20(fp)
  415adc:	e0bffb44 	addi	r2,fp,-19
  415ae0:	d8000015 	stw	zero,0(sp)
  415ae4:	d8000115 	stw	zero,4(sp)
  415ae8:	d8000215 	stw	zero,8(sp)
  415aec:	e13ffd17 	ldw	r4,-12(fp)
  415af0:	000b883a 	mov	r5,zero
  415af4:	180d883a 	mov	r6,r3
  415af8:	100f883a 	mov	r7,r2
  415afc:	0416a580 	call	416a58 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
  415b00:	e13ffd17 	ldw	r4,-12(fp)
  415b04:	04159fc0 	call	4159fc <epcs_await_wip_released>

  if(four_bytes_mode)
  415b08:	e0bfff17 	ldw	r2,-4(fp)
  415b0c:	10000226 	beq	r2,zero,415b18 <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
  415b10:	e13ffd17 	ldw	r4,-12(fp)
  415b14:	0415f380 	call	415f38 <epcs_exit_4_bytes_mode>
  }
}
  415b18:	e037883a 	mov	sp,fp
  415b1c:	dfc00117 	ldw	ra,4(sp)
  415b20:	df000017 	ldw	fp,0(sp)
  415b24:	dec00204 	addi	sp,sp,8
  415b28:	f800283a 	ret

00415b2c <epcs_read_buffer>:

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
  415b2c:	defff404 	addi	sp,sp,-48
  415b30:	dfc00b15 	stw	ra,44(sp)
  415b34:	df000a15 	stw	fp,40(sp)
  415b38:	df000a04 	addi	fp,sp,40
  415b3c:	e13ffc15 	stw	r4,-16(fp)
  415b40:	e17ffd15 	stw	r5,-12(fp)
  415b44:	e1bffe15 	stw	r6,-8(fp)
  415b48:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
  415b4c:	008000c4 	movi	r2,3
  415b50:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
  415b54:	e0800217 	ldw	r2,8(fp)
  415b58:	10001026 	beq	r2,zero,415b9c <epcs_read_buffer+0x70>
  {
        read_command[1] = (offset >> 24) & 0xFF;
  415b5c:	e0bffd17 	ldw	r2,-12(fp)
  415b60:	1004d63a 	srli	r2,r2,24
  415b64:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
  415b68:	e0bffd17 	ldw	r2,-12(fp)
  415b6c:	1005d43a 	srai	r2,r2,16
  415b70:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
  415b74:	e0bffd17 	ldw	r2,-12(fp)
  415b78:	1005d23a 	srai	r2,r2,8
  415b7c:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
  415b80:	e0bffd17 	ldw	r2,-12(fp)
  415b84:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
  415b88:	00800144 	movi	r2,5
  415b8c:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
  415b90:	e13ffc17 	ldw	r4,-16(fp)
  415b94:	0415edc0 	call	415edc <epcs_enter_4_bytes_mode>
  415b98:	00000a06 	br	415bc4 <epcs_read_buffer+0x98>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
  415b9c:	e0bffd17 	ldw	r2,-12(fp)
  415ba0:	1005d43a 	srai	r2,r2,16
  415ba4:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
  415ba8:	e0bffd17 	ldw	r2,-12(fp)
  415bac:	1005d23a 	srai	r2,r2,8
  415bb0:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
  415bb4:	e0bffd17 	ldw	r2,-12(fp)
  415bb8:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
  415bbc:	00800104 	movi	r2,4
  415bc0:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
  415bc4:	e13ffc17 	ldw	r4,-16(fp)
  415bc8:	04159fc0 	call	4159fc <epcs_await_wip_released>

  alt_avalon_spi_command(
  415bcc:	e0bfff17 	ldw	r2,-4(fp)
  415bd0:	e0fffa04 	addi	r3,fp,-24
  415bd4:	d8800015 	stw	r2,0(sp)
  415bd8:	e0bffe17 	ldw	r2,-8(fp)
  415bdc:	d8800115 	stw	r2,4(sp)
  415be0:	d8000215 	stw	zero,8(sp)
  415be4:	e13ffc17 	ldw	r4,-16(fp)
  415be8:	000b883a 	mov	r5,zero
  415bec:	e1bff917 	ldw	r6,-28(fp)
  415bf0:	180f883a 	mov	r7,r3
  415bf4:	0416a580 	call	416a58 <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
  415bf8:	e0800217 	ldw	r2,8(fp)
  415bfc:	10000226 	beq	r2,zero,415c08 <epcs_read_buffer+0xdc>
  {
    epcs_exit_4_bytes_mode(base);
  415c00:	e13ffc17 	ldw	r4,-16(fp)
  415c04:	0415f380 	call	415f38 <epcs_exit_4_bytes_mode>
  }

  return length;
  415c08:	e0bfff17 	ldw	r2,-4(fp)
}
  415c0c:	e037883a 	mov	sp,fp
  415c10:	dfc00117 	ldw	ra,4(sp)
  415c14:	df000017 	ldw	fp,0(sp)
  415c18:	dec00204 	addi	sp,sp,8
  415c1c:	f800283a 	ret

00415c20 <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
  415c20:	defff904 	addi	sp,sp,-28
  415c24:	dfc00615 	stw	ra,24(sp)
  415c28:	df000515 	stw	fp,20(sp)
  415c2c:	df000504 	addi	fp,sp,20
  415c30:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
  415c34:	00800184 	movi	r2,6
  415c38:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
  415c3c:	d8000015 	stw	zero,0(sp)
  415c40:	d8000115 	stw	zero,4(sp)
  415c44:	d8000215 	stw	zero,8(sp)
  415c48:	e13fff17 	ldw	r4,-4(fp)
  415c4c:	000b883a 	mov	r5,zero
  415c50:	01800044 	movi	r6,1
  415c54:	e1fffe04 	addi	r7,fp,-8
  415c58:	0416a580 	call	416a58 <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
  415c5c:	e037883a 	mov	sp,fp
  415c60:	dfc00117 	ldw	ra,4(sp)
  415c64:	df000017 	ldw	fp,0(sp)
  415c68:	dec00204 	addi	sp,sp,8
  415c6c:	f800283a 	ret

00415c70 <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
  415c70:	defff804 	addi	sp,sp,-32
  415c74:	dfc00715 	stw	ra,28(sp)
  415c78:	df000615 	stw	fp,24(sp)
  415c7c:	df000604 	addi	fp,sp,24
  415c80:	e13ffe15 	stw	r4,-8(fp)
  415c84:	2805883a 	mov	r2,r5
  415c88:	e0bfff05 	stb	r2,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
  415c8c:	00800044 	movi	r2,1
  415c90:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
  415c94:	e0bfff03 	ldbu	r2,-4(fp)
  415c98:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
  415c9c:	d8000015 	stw	zero,0(sp)
  415ca0:	d8000115 	stw	zero,4(sp)
  415ca4:	d8000215 	stw	zero,8(sp)
  415ca8:	e13ffe17 	ldw	r4,-8(fp)
  415cac:	000b883a 	mov	r5,zero
  415cb0:	01800084 	movi	r6,2
  415cb4:	e1fffd04 	addi	r7,fp,-12
  415cb8:	0416a580 	call	416a58 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
  415cbc:	e13ffe17 	ldw	r4,-8(fp)
  415cc0:	04159fc0 	call	4159fc <epcs_await_wip_released>
}
  415cc4:	e037883a 	mov	sp,fp
  415cc8:	dfc00117 	ldw	ra,4(sp)
  415ccc:	df000017 	ldw	fp,0(sp)
  415cd0:	dec00204 	addi	sp,sp,8
  415cd4:	f800283a 	ret

00415cd8 <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
  415cd8:	defff404 	addi	sp,sp,-48
  415cdc:	dfc00b15 	stw	ra,44(sp)
  415ce0:	df000a15 	stw	fp,40(sp)
  415ce4:	df000a04 	addi	fp,sp,40
  415ce8:	e13ffc15 	stw	r4,-16(fp)
  415cec:	e17ffd15 	stw	r5,-12(fp)
  415cf0:	e1bffe15 	stw	r6,-8(fp)
  415cf4:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
  415cf8:	00800084 	movi	r2,2
  415cfc:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
  415d00:	e0800217 	ldw	r2,8(fp)
  415d04:	10001026 	beq	r2,zero,415d48 <epcs_write_buffer+0x70>
  {
      pp[1] = (offset >> 24) & 0xFF;
  415d08:	e0bffd17 	ldw	r2,-12(fp)
  415d0c:	1004d63a 	srli	r2,r2,24
  415d10:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
  415d14:	e0bffd17 	ldw	r2,-12(fp)
  415d18:	1005d43a 	srai	r2,r2,16
  415d1c:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
  415d20:	e0bffd17 	ldw	r2,-12(fp)
  415d24:	1005d23a 	srai	r2,r2,8
  415d28:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
  415d2c:	e0bffd17 	ldw	r2,-12(fp)
  415d30:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
  415d34:	00800144 	movi	r2,5
  415d38:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
  415d3c:	e13ffc17 	ldw	r4,-16(fp)
  415d40:	0415edc0 	call	415edc <epcs_enter_4_bytes_mode>
  415d44:	00000a06 	br	415d70 <epcs_write_buffer+0x98>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
  415d48:	e0bffd17 	ldw	r2,-12(fp)
  415d4c:	1005d43a 	srai	r2,r2,16
  415d50:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
  415d54:	e0bffd17 	ldw	r2,-12(fp)
  415d58:	1005d23a 	srai	r2,r2,8
  415d5c:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
  415d60:	e0bffd17 	ldw	r2,-12(fp)
  415d64:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
  415d68:	00800104 	movi	r2,4
  415d6c:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
  415d70:	e13ffc17 	ldw	r4,-16(fp)
  415d74:	0415c200 	call	415c20 <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
  415d78:	e0fffa04 	addi	r3,fp,-24
  415d7c:	d8000015 	stw	zero,0(sp)
  415d80:	d8000115 	stw	zero,4(sp)
  415d84:	00800044 	movi	r2,1
  415d88:	d8800215 	stw	r2,8(sp)
  415d8c:	e13ffc17 	ldw	r4,-16(fp)
  415d90:	000b883a 	mov	r5,zero
  415d94:	e1bff917 	ldw	r6,-28(fp)
  415d98:	180f883a 	mov	r7,r3
  415d9c:	0416a580 	call	416a58 <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
  415da0:	e0bfff17 	ldw	r2,-4(fp)
  415da4:	d8000015 	stw	zero,0(sp)
  415da8:	d8000115 	stw	zero,4(sp)
  415dac:	d8000215 	stw	zero,8(sp)
  415db0:	e13ffc17 	ldw	r4,-16(fp)
  415db4:	000b883a 	mov	r5,zero
  415db8:	100d883a 	mov	r6,r2
  415dbc:	e1fffe17 	ldw	r7,-8(fp)
  415dc0:	0416a580 	call	416a58 <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
  415dc4:	e13ffc17 	ldw	r4,-16(fp)
  415dc8:	04159fc0 	call	4159fc <epcs_await_wip_released>

  if(four_bytes_mode)
  415dcc:	e0800217 	ldw	r2,8(fp)
  415dd0:	10000226 	beq	r2,zero,415ddc <epcs_write_buffer+0x104>
  {
    epcs_exit_4_bytes_mode(base);
  415dd4:	e13ffc17 	ldw	r4,-16(fp)
  415dd8:	0415f380 	call	415f38 <epcs_exit_4_bytes_mode>
  }

  return length;
  415ddc:	e0bfff17 	ldw	r2,-4(fp)
}
  415de0:	e037883a 	mov	sp,fp
  415de4:	dfc00117 	ldw	ra,4(sp)
  415de8:	df000017 	ldw	fp,0(sp)
  415dec:	dec00204 	addi	sp,sp,8
  415df0:	f800283a 	ret

00415df4 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
  415df4:	defff804 	addi	sp,sp,-32
  415df8:	dfc00715 	stw	ra,28(sp)
  415dfc:	df000615 	stw	fp,24(sp)
  415e00:	df000604 	addi	fp,sp,24
  415e04:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
  415e08:	00bfeac4 	movi	r2,-85
  415e0c:	e0bffd05 	stb	r2,-12(fp)
  415e10:	e03ffd45 	stb	zero,-11(fp)
  415e14:	e03ffd85 	stb	zero,-10(fp)
  415e18:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
  415e1c:	00800044 	movi	r2,1
  415e20:	d8800015 	stw	r2,0(sp)
  415e24:	e0bffe04 	addi	r2,fp,-8
  415e28:	d8800115 	stw	r2,4(sp)
  415e2c:	d8000215 	stw	zero,8(sp)
  415e30:	e13fff17 	ldw	r4,-4(fp)
  415e34:	000b883a 	mov	r5,zero
  415e38:	01800104 	movi	r6,4
  415e3c:	e1fffd04 	addi	r7,fp,-12
  415e40:	0416a580 	call	416a58 <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
  415e44:	e0bffe03 	ldbu	r2,-8(fp)
}
  415e48:	e037883a 	mov	sp,fp
  415e4c:	dfc00117 	ldw	ra,4(sp)
  415e50:	df000017 	ldw	fp,0(sp)
  415e54:	dec00204 	addi	sp,sp,8
  415e58:	f800283a 	ret

00415e5c <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
  415e5c:	defff904 	addi	sp,sp,-28
  415e60:	dfc00615 	stw	ra,24(sp)
  415e64:	df000515 	stw	fp,20(sp)
  415e68:	df000504 	addi	fp,sp,20
  415e6c:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
  415e70:	00bfe7c4 	movi	r2,-97
  415e74:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
  415e78:	008000c4 	movi	r2,3
  415e7c:	d8800015 	stw	r2,0(sp)
  415e80:	e0bffe44 	addi	r2,fp,-7
  415e84:	d8800115 	stw	r2,4(sp)
  415e88:	d8000215 	stw	zero,8(sp)
  415e8c:	e13fff17 	ldw	r4,-4(fp)
  415e90:	000b883a 	mov	r5,zero
  415e94:	01800044 	movi	r6,1
  415e98:	e1fffe04 	addi	r7,fp,-8
  415e9c:	0416a580 	call	416a58 <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
  415ea0:	e0bffe43 	ldbu	r2,-7(fp)
  415ea4:	10803fcc 	andi	r2,r2,255
  415ea8:	1006943a 	slli	r3,r2,16
  415eac:	e0bffe83 	ldbu	r2,-6(fp)
  415eb0:	10803fcc 	andi	r2,r2,255
  415eb4:	1004923a 	slli	r2,r2,8
  415eb8:	1886b03a 	or	r3,r3,r2
  415ebc:	e0bffec3 	ldbu	r2,-5(fp)
  415ec0:	10803fcc 	andi	r2,r2,255
  415ec4:	1884b03a 	or	r2,r3,r2
}
  415ec8:	e037883a 	mov	sp,fp
  415ecc:	dfc00117 	ldw	ra,4(sp)
  415ed0:	df000017 	ldw	fp,0(sp)
  415ed4:	dec00204 	addi	sp,sp,8
  415ed8:	f800283a 	ret

00415edc <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
  415edc:	defff904 	addi	sp,sp,-28
  415ee0:	dfc00615 	stw	ra,24(sp)
  415ee4:	df000515 	stw	fp,20(sp)
  415ee8:	df000504 	addi	fp,sp,20
  415eec:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
  415ef0:	00bfedc4 	movi	r2,-73
  415ef4:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
  415ef8:	e13fff17 	ldw	r4,-4(fp)
  415efc:	0415c200 	call	415c20 <epcs_write_enable>

  alt_avalon_spi_command(
  415f00:	d8000015 	stw	zero,0(sp)
  415f04:	d8000115 	stw	zero,4(sp)
  415f08:	d8000215 	stw	zero,8(sp)
  415f0c:	e13fff17 	ldw	r4,-4(fp)
  415f10:	000b883a 	mov	r5,zero
  415f14:	01800044 	movi	r6,1
  415f18:	e1fffe04 	addi	r7,fp,-8
  415f1c:	0416a580 	call	416a58 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
  415f20:	0001883a 	nop
}
  415f24:	e037883a 	mov	sp,fp
  415f28:	dfc00117 	ldw	ra,4(sp)
  415f2c:	df000017 	ldw	fp,0(sp)
  415f30:	dec00204 	addi	sp,sp,8
  415f34:	f800283a 	ret

00415f38 <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
  415f38:	defff904 	addi	sp,sp,-28
  415f3c:	dfc00615 	stw	ra,24(sp)
  415f40:	df000515 	stw	fp,20(sp)
  415f44:	df000504 	addi	fp,sp,20
  415f48:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
  415f4c:	00bffa44 	movi	r2,-23
  415f50:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
  415f54:	e13fff17 	ldw	r4,-4(fp)
  415f58:	0415c200 	call	415c20 <epcs_write_enable>

  alt_avalon_spi_command(
  415f5c:	d8000015 	stw	zero,0(sp)
  415f60:	d8000115 	stw	zero,4(sp)
  415f64:	d8000215 	stw	zero,8(sp)
  415f68:	e13fff17 	ldw	r4,-4(fp)
  415f6c:	000b883a 	mov	r5,zero
  415f70:	01800044 	movi	r6,1
  415f74:	e1fffe04 	addi	r7,fp,-8
  415f78:	0416a580 	call	416a58 <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  return;
  415f7c:	0001883a 	nop
}
  415f80:	e037883a 	mov	sp,fp
  415f84:	dfc00117 	ldw	ra,4(sp)
  415f88:	df000017 	ldw	fp,0(sp)
  415f8c:	dec00204 	addi	sp,sp,8
  415f90:	f800283a 	ret

00415f94 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  415f94:	defffe04 	addi	sp,sp,-8
  415f98:	dfc00115 	stw	ra,4(sp)
  415f9c:	df000015 	stw	fp,0(sp)
  415fa0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  415fa4:	00801074 	movhi	r2,65
  415fa8:	109e0704 	addi	r2,r2,30748
  415fac:	10800017 	ldw	r2,0(r2)
  415fb0:	10000526 	beq	r2,zero,415fc8 <alt_get_errno+0x34>
  415fb4:	00801074 	movhi	r2,65
  415fb8:	109e0704 	addi	r2,r2,30748
  415fbc:	10800017 	ldw	r2,0(r2)
  415fc0:	103ee83a 	callr	r2
  415fc4:	00000206 	br	415fd0 <alt_get_errno+0x3c>
  415fc8:	00801074 	movhi	r2,65
  415fcc:	109f3c04 	addi	r2,r2,31984
}
  415fd0:	e037883a 	mov	sp,fp
  415fd4:	dfc00117 	ldw	ra,4(sp)
  415fd8:	df000017 	ldw	fp,0(sp)
  415fdc:	dec00204 	addi	sp,sp,8
  415fe0:	f800283a 	ret

00415fe4 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  415fe4:	defffb04 	addi	sp,sp,-20
  415fe8:	dfc00415 	stw	ra,16(sp)
  415fec:	df000315 	stw	fp,12(sp)
  415ff0:	df000304 	addi	fp,sp,12
  415ff4:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  415ff8:	e0bfff17 	ldw	r2,-4(fp)
  415ffc:	10000816 	blt	r2,zero,416020 <close+0x3c>
  416000:	e13fff17 	ldw	r4,-4(fp)
  416004:	01400304 	movi	r5,12
  416008:	04123e00 	call	4123e0 <__mulsi3>
  41600c:	1007883a 	mov	r3,r2
  416010:	00801074 	movhi	r2,65
  416014:	109d9f04 	addi	r2,r2,30332
  416018:	1885883a 	add	r2,r3,r2
  41601c:	00000106 	br	416024 <close+0x40>
  416020:	0005883a 	mov	r2,zero
  416024:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  416028:	e0bffd17 	ldw	r2,-12(fp)
  41602c:	10001926 	beq	r2,zero,416094 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  416030:	e0bffd17 	ldw	r2,-12(fp)
  416034:	10800017 	ldw	r2,0(r2)
  416038:	10800417 	ldw	r2,16(r2)
  41603c:	10000626 	beq	r2,zero,416058 <close+0x74>
  416040:	e0bffd17 	ldw	r2,-12(fp)
  416044:	10800017 	ldw	r2,0(r2)
  416048:	10800417 	ldw	r2,16(r2)
  41604c:	e13ffd17 	ldw	r4,-12(fp)
  416050:	103ee83a 	callr	r2
  416054:	00000106 	br	41605c <close+0x78>
  416058:	0005883a 	mov	r2,zero
  41605c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  416060:	e13fff17 	ldw	r4,-4(fp)
  416064:	041681c0 	call	41681c <alt_release_fd>
    if (rval < 0)
  416068:	e0bffe17 	ldw	r2,-8(fp)
  41606c:	1000070e 	bge	r2,zero,41608c <close+0xa8>
    {
      ALT_ERRNO = -rval;
  416070:	0415f940 	call	415f94 <alt_get_errno>
  416074:	1007883a 	mov	r3,r2
  416078:	e0bffe17 	ldw	r2,-8(fp)
  41607c:	0085c83a 	sub	r2,zero,r2
  416080:	18800015 	stw	r2,0(r3)
      return -1;
  416084:	00bfffc4 	movi	r2,-1
  416088:	00000706 	br	4160a8 <close+0xc4>
    }
    return 0;
  41608c:	0005883a 	mov	r2,zero
  416090:	00000506 	br	4160a8 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  416094:	0415f940 	call	415f94 <alt_get_errno>
  416098:	1007883a 	mov	r3,r2
  41609c:	00801444 	movi	r2,81
  4160a0:	18800015 	stw	r2,0(r3)
    return -1;
  4160a4:	00bfffc4 	movi	r2,-1
  }
}
  4160a8:	e037883a 	mov	sp,fp
  4160ac:	dfc00117 	ldw	ra,4(sp)
  4160b0:	df000017 	ldw	fp,0(sp)
  4160b4:	dec00204 	addi	sp,sp,8
  4160b8:	f800283a 	ret

004160bc <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  4160bc:	deffff04 	addi	sp,sp,-4
  4160c0:	df000015 	stw	fp,0(sp)
  4160c4:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  4160c8:	e037883a 	mov	sp,fp
  4160cc:	df000017 	ldw	fp,0(sp)
  4160d0:	dec00104 	addi	sp,sp,4
  4160d4:	f800283a 	ret

004160d8 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  4160d8:	defffc04 	addi	sp,sp,-16
  4160dc:	df000315 	stw	fp,12(sp)
  4160e0:	df000304 	addi	fp,sp,12
  4160e4:	e13ffd15 	stw	r4,-12(fp)
  4160e8:	e17ffe15 	stw	r5,-8(fp)
  4160ec:	e1bfff15 	stw	r6,-4(fp)
  return len;
  4160f0:	e0bfff17 	ldw	r2,-4(fp)
}
  4160f4:	e037883a 	mov	sp,fp
  4160f8:	df000017 	ldw	fp,0(sp)
  4160fc:	dec00104 	addi	sp,sp,4
  416100:	f800283a 	ret

00416104 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  416104:	defffe04 	addi	sp,sp,-8
  416108:	dfc00115 	stw	ra,4(sp)
  41610c:	df000015 	stw	fp,0(sp)
  416110:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  416114:	00801074 	movhi	r2,65
  416118:	109e0704 	addi	r2,r2,30748
  41611c:	10800017 	ldw	r2,0(r2)
  416120:	10000526 	beq	r2,zero,416138 <alt_get_errno+0x34>
  416124:	00801074 	movhi	r2,65
  416128:	109e0704 	addi	r2,r2,30748
  41612c:	10800017 	ldw	r2,0(r2)
  416130:	103ee83a 	callr	r2
  416134:	00000206 	br	416140 <alt_get_errno+0x3c>
  416138:	00801074 	movhi	r2,65
  41613c:	109f3c04 	addi	r2,r2,31984
}
  416140:	e037883a 	mov	sp,fp
  416144:	dfc00117 	ldw	ra,4(sp)
  416148:	df000017 	ldw	fp,0(sp)
  41614c:	dec00204 	addi	sp,sp,8
  416150:	f800283a 	ret

00416154 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  416154:	defffa04 	addi	sp,sp,-24
  416158:	dfc00515 	stw	ra,20(sp)
  41615c:	df000415 	stw	fp,16(sp)
  416160:	df000404 	addi	fp,sp,16
  416164:	e13ffe15 	stw	r4,-8(fp)
  416168:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  41616c:	e0bffe17 	ldw	r2,-8(fp)
  416170:	10000326 	beq	r2,zero,416180 <alt_dev_llist_insert+0x2c>
  416174:	e0bffe17 	ldw	r2,-8(fp)
  416178:	10800217 	ldw	r2,8(r2)
  41617c:	1000061e 	bne	r2,zero,416198 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
  416180:	04161040 	call	416104 <alt_get_errno>
  416184:	1007883a 	mov	r3,r2
  416188:	00800584 	movi	r2,22
  41618c:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  416190:	00bffa84 	movi	r2,-22
  416194:	00001306 	br	4161e4 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  416198:	e0bffe17 	ldw	r2,-8(fp)
  41619c:	e0ffff17 	ldw	r3,-4(fp)
  4161a0:	e0fffc15 	stw	r3,-16(fp)
  4161a4:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  4161a8:	e0bffd17 	ldw	r2,-12(fp)
  4161ac:	e0fffc17 	ldw	r3,-16(fp)
  4161b0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  4161b4:	e0bffc17 	ldw	r2,-16(fp)
  4161b8:	10c00017 	ldw	r3,0(r2)
  4161bc:	e0bffd17 	ldw	r2,-12(fp)
  4161c0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  4161c4:	e0bffc17 	ldw	r2,-16(fp)
  4161c8:	10800017 	ldw	r2,0(r2)
  4161cc:	e0fffd17 	ldw	r3,-12(fp)
  4161d0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  4161d4:	e0bffc17 	ldw	r2,-16(fp)
  4161d8:	e0fffd17 	ldw	r3,-12(fp)
  4161dc:	10c00015 	stw	r3,0(r2)

  return 0;  
  4161e0:	0005883a 	mov	r2,zero
}
  4161e4:	e037883a 	mov	sp,fp
  4161e8:	dfc00117 	ldw	ra,4(sp)
  4161ec:	df000017 	ldw	fp,0(sp)
  4161f0:	dec00204 	addi	sp,sp,8
  4161f4:	f800283a 	ret

004161f8 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  4161f8:	defffd04 	addi	sp,sp,-12
  4161fc:	dfc00215 	stw	ra,8(sp)
  416200:	df000115 	stw	fp,4(sp)
  416204:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  416208:	00801074 	movhi	r2,65
  41620c:	109c9504 	addi	r2,r2,29268
  416210:	e0bfff15 	stw	r2,-4(fp)
  416214:	00000606 	br	416230 <_do_ctors+0x38>
        (*ctor) (); 
  416218:	e0bfff17 	ldw	r2,-4(fp)
  41621c:	10800017 	ldw	r2,0(r2)
  416220:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  416224:	e0bfff17 	ldw	r2,-4(fp)
  416228:	10bfff04 	addi	r2,r2,-4
  41622c:	e0bfff15 	stw	r2,-4(fp)
  416230:	e0ffff17 	ldw	r3,-4(fp)
  416234:	00801074 	movhi	r2,65
  416238:	109c9604 	addi	r2,r2,29272
  41623c:	18bff62e 	bgeu	r3,r2,416218 <_gp+0xffff6a1c>
        (*ctor) (); 
}
  416240:	e037883a 	mov	sp,fp
  416244:	dfc00117 	ldw	ra,4(sp)
  416248:	df000017 	ldw	fp,0(sp)
  41624c:	dec00204 	addi	sp,sp,8
  416250:	f800283a 	ret

00416254 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  416254:	defffd04 	addi	sp,sp,-12
  416258:	dfc00215 	stw	ra,8(sp)
  41625c:	df000115 	stw	fp,4(sp)
  416260:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  416264:	00801074 	movhi	r2,65
  416268:	109c9504 	addi	r2,r2,29268
  41626c:	e0bfff15 	stw	r2,-4(fp)
  416270:	00000606 	br	41628c <_do_dtors+0x38>
        (*dtor) (); 
  416274:	e0bfff17 	ldw	r2,-4(fp)
  416278:	10800017 	ldw	r2,0(r2)
  41627c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  416280:	e0bfff17 	ldw	r2,-4(fp)
  416284:	10bfff04 	addi	r2,r2,-4
  416288:	e0bfff15 	stw	r2,-4(fp)
  41628c:	e0ffff17 	ldw	r3,-4(fp)
  416290:	00801074 	movhi	r2,65
  416294:	109c9604 	addi	r2,r2,29272
  416298:	18bff62e 	bgeu	r3,r2,416274 <_gp+0xffff6a78>
        (*dtor) (); 
}
  41629c:	e037883a 	mov	sp,fp
  4162a0:	dfc00117 	ldw	ra,4(sp)
  4162a4:	df000017 	ldw	fp,0(sp)
  4162a8:	dec00204 	addi	sp,sp,8
  4162ac:	f800283a 	ret

004162b0 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
  4162b0:	defffc04 	addi	sp,sp,-16
  4162b4:	dfc00315 	stw	ra,12(sp)
  4162b8:	df000215 	stw	fp,8(sp)
  4162bc:	df000204 	addi	fp,sp,8
  4162c0:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
  4162c4:	e13fff17 	ldw	r4,-4(fp)
  4162c8:	d1600904 	addi	r5,gp,-32732
  4162cc:	0416c5c0 	call	416c5c <alt_find_dev>
  4162d0:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
  4162d4:	e0bffe17 	ldw	r2,-8(fp)
  4162d8:	10000926 	beq	r2,zero,416300 <alt_flash_open_dev+0x50>
  4162dc:	e0bffe17 	ldw	r2,-8(fp)
  4162e0:	10800317 	ldw	r2,12(r2)
  4162e4:	10000626 	beq	r2,zero,416300 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
  4162e8:	e0bffe17 	ldw	r2,-8(fp)
  4162ec:	10800317 	ldw	r2,12(r2)
  4162f0:	e13ffe17 	ldw	r4,-8(fp)
  4162f4:	e17fff17 	ldw	r5,-4(fp)
  4162f8:	103ee83a 	callr	r2
  4162fc:	00000106 	br	416304 <alt_flash_open_dev+0x54>
  }

  return dev;
  416300:	e0bffe17 	ldw	r2,-8(fp)
}
  416304:	e037883a 	mov	sp,fp
  416308:	dfc00117 	ldw	ra,4(sp)
  41630c:	df000017 	ldw	fp,0(sp)
  416310:	dec00204 	addi	sp,sp,8
  416314:	f800283a 	ret

00416318 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
  416318:	defffd04 	addi	sp,sp,-12
  41631c:	dfc00215 	stw	ra,8(sp)
  416320:	df000115 	stw	fp,4(sp)
  416324:	df000104 	addi	fp,sp,4
  416328:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
  41632c:	e0bfff17 	ldw	r2,-4(fp)
  416330:	10000726 	beq	r2,zero,416350 <alt_flash_close_dev+0x38>
  416334:	e0bfff17 	ldw	r2,-4(fp)
  416338:	10800417 	ldw	r2,16(r2)
  41633c:	10000426 	beq	r2,zero,416350 <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
  416340:	e0bfff17 	ldw	r2,-4(fp)
  416344:	10800417 	ldw	r2,16(r2)
  416348:	e13fff17 	ldw	r4,-4(fp)
  41634c:	103ee83a 	callr	r2
  }
  return;
  416350:	0001883a 	nop
}
  416354:	e037883a 	mov	sp,fp
  416358:	dfc00117 	ldw	ra,4(sp)
  41635c:	df000017 	ldw	fp,0(sp)
  416360:	dec00204 	addi	sp,sp,8
  416364:	f800283a 	ret

00416368 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  416368:	deffff04 	addi	sp,sp,-4
  41636c:	df000015 	stw	fp,0(sp)
  416370:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
  416374:	e037883a 	mov	sp,fp
  416378:	df000017 	ldw	fp,0(sp)
  41637c:	dec00104 	addi	sp,sp,4
  416380:	f800283a 	ret

00416384 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  416384:	defffe04 	addi	sp,sp,-8
  416388:	df000115 	stw	fp,4(sp)
  41638c:	df000104 	addi	fp,sp,4
  416390:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
  416394:	e0bfff17 	ldw	r2,-4(fp)
  416398:	10bffe84 	addi	r2,r2,-6
  41639c:	10c00428 	cmpgeui	r3,r2,16
  4163a0:	18001a1e 	bne	r3,zero,41640c <alt_exception_cause_generated_bad_addr+0x88>
  4163a4:	100690ba 	slli	r3,r2,2
  4163a8:	00801074 	movhi	r2,65
  4163ac:	1098ef04 	addi	r2,r2,25532
  4163b0:	1885883a 	add	r2,r3,r2
  4163b4:	10800017 	ldw	r2,0(r2)
  4163b8:	1000683a 	jmp	r2
  4163bc:	004163fc 	xorhi	at,zero,1423
  4163c0:	004163fc 	xorhi	at,zero,1423
  4163c4:	0041640c 	andi	at,zero,1424
  4163c8:	0041640c 	andi	at,zero,1424
  4163cc:	0041640c 	andi	at,zero,1424
  4163d0:	004163fc 	xorhi	at,zero,1423
  4163d4:	00416404 	movi	at,1424
  4163d8:	0041640c 	andi	at,zero,1424
  4163dc:	004163fc 	xorhi	at,zero,1423
  4163e0:	004163fc 	xorhi	at,zero,1423
  4163e4:	0041640c 	andi	at,zero,1424
  4163e8:	004163fc 	xorhi	at,zero,1423
  4163ec:	00416404 	movi	at,1424
  4163f0:	0041640c 	andi	at,zero,1424
  4163f4:	0041640c 	andi	at,zero,1424
  4163f8:	004163fc 	xorhi	at,zero,1423
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
  4163fc:	00800044 	movi	r2,1
  416400:	00000306 	br	416410 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
  416404:	0005883a 	mov	r2,zero
  416408:	00000106 	br	416410 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
  41640c:	0005883a 	mov	r2,zero
  }
}
  416410:	e037883a 	mov	sp,fp
  416414:	df000017 	ldw	fp,0(sp)
  416418:	dec00104 	addi	sp,sp,4
  41641c:	f800283a 	ret

00416420 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  416420:	defff804 	addi	sp,sp,-32
  416424:	dfc00715 	stw	ra,28(sp)
  416428:	df000615 	stw	fp,24(sp)
  41642c:	dc000515 	stw	r16,20(sp)
  416430:	df000604 	addi	fp,sp,24
  416434:	e13ffb15 	stw	r4,-20(fp)
  416438:	e17ffc15 	stw	r5,-16(fp)
  41643c:	e1bffd15 	stw	r6,-12(fp)
  416440:	e1fffe15 	stw	r7,-8(fp)
  int old;

  old = open (name, flags, mode);
  416444:	e13ffc17 	ldw	r4,-16(fp)
  416448:	e17ffd17 	ldw	r5,-12(fp)
  41644c:	e1bffe17 	ldw	r6,-8(fp)
  416450:	04166bc0 	call	4166bc <open>
  416454:	e0bffa15 	stw	r2,-24(fp)

  if (old >= 0)
  416458:	e0bffa17 	ldw	r2,-24(fp)
  41645c:	10002216 	blt	r2,zero,4164e8 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
  416460:	04001074 	movhi	r16,65
  416464:	841d9f04 	addi	r16,r16,30332
  416468:	e0bffa17 	ldw	r2,-24(fp)
  41646c:	1009883a 	mov	r4,r2
  416470:	01400304 	movi	r5,12
  416474:	04123e00 	call	4123e0 <__mulsi3>
  416478:	8085883a 	add	r2,r16,r2
  41647c:	10c00017 	ldw	r3,0(r2)
  416480:	e0bffb17 	ldw	r2,-20(fp)
  416484:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  416488:	04001074 	movhi	r16,65
  41648c:	841d9f04 	addi	r16,r16,30332
  416490:	e0bffa17 	ldw	r2,-24(fp)
  416494:	1009883a 	mov	r4,r2
  416498:	01400304 	movi	r5,12
  41649c:	04123e00 	call	4123e0 <__mulsi3>
  4164a0:	10800104 	addi	r2,r2,4
  4164a4:	8085883a 	add	r2,r16,r2
  4164a8:	10c00017 	ldw	r3,0(r2)
  4164ac:	e0bffb17 	ldw	r2,-20(fp)
  4164b0:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  4164b4:	04001074 	movhi	r16,65
  4164b8:	841d9f04 	addi	r16,r16,30332
  4164bc:	e0bffa17 	ldw	r2,-24(fp)
  4164c0:	1009883a 	mov	r4,r2
  4164c4:	01400304 	movi	r5,12
  4164c8:	04123e00 	call	4123e0 <__mulsi3>
  4164cc:	10800204 	addi	r2,r2,8
  4164d0:	8085883a 	add	r2,r16,r2
  4164d4:	10c00017 	ldw	r3,0(r2)
  4164d8:	e0bffb17 	ldw	r2,-20(fp)
  4164dc:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  4164e0:	e13ffa17 	ldw	r4,-24(fp)
  4164e4:	041681c0 	call	41681c <alt_release_fd>
  }
} 
  4164e8:	e6ffff04 	addi	sp,fp,-4
  4164ec:	dfc00217 	ldw	ra,8(sp)
  4164f0:	df000117 	ldw	fp,4(sp)
  4164f4:	dc000017 	ldw	r16,0(sp)
  4164f8:	dec00304 	addi	sp,sp,12
  4164fc:	f800283a 	ret

00416500 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  416500:	defffb04 	addi	sp,sp,-20
  416504:	dfc00415 	stw	ra,16(sp)
  416508:	df000315 	stw	fp,12(sp)
  41650c:	df000304 	addi	fp,sp,12
  416510:	e13ffd15 	stw	r4,-12(fp)
  416514:	e17ffe15 	stw	r5,-8(fp)
  416518:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  41651c:	01001074 	movhi	r4,65
  416520:	211da204 	addi	r4,r4,30344
  416524:	e17ffd17 	ldw	r5,-12(fp)
  416528:	01800044 	movi	r6,1
  41652c:	01c07fc4 	movi	r7,511
  416530:	04164200 	call	416420 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  416534:	01001074 	movhi	r4,65
  416538:	211d9f04 	addi	r4,r4,30332
  41653c:	e17ffe17 	ldw	r5,-8(fp)
  416540:	000d883a 	mov	r6,zero
  416544:	01c07fc4 	movi	r7,511
  416548:	04164200 	call	416420 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  41654c:	01001074 	movhi	r4,65
  416550:	211da504 	addi	r4,r4,30356
  416554:	e17fff17 	ldw	r5,-4(fp)
  416558:	01800044 	movi	r6,1
  41655c:	01c07fc4 	movi	r7,511
  416560:	04164200 	call	416420 <alt_open_fd>
}  
  416564:	e037883a 	mov	sp,fp
  416568:	dfc00117 	ldw	ra,4(sp)
  41656c:	df000017 	ldw	fp,0(sp)
  416570:	dec00204 	addi	sp,sp,8
  416574:	f800283a 	ret

00416578 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  416578:	defffe04 	addi	sp,sp,-8
  41657c:	dfc00115 	stw	ra,4(sp)
  416580:	df000015 	stw	fp,0(sp)
  416584:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  416588:	00801074 	movhi	r2,65
  41658c:	109e0704 	addi	r2,r2,30748
  416590:	10800017 	ldw	r2,0(r2)
  416594:	10000526 	beq	r2,zero,4165ac <alt_get_errno+0x34>
  416598:	00801074 	movhi	r2,65
  41659c:	109e0704 	addi	r2,r2,30748
  4165a0:	10800017 	ldw	r2,0(r2)
  4165a4:	103ee83a 	callr	r2
  4165a8:	00000206 	br	4165b4 <alt_get_errno+0x3c>
  4165ac:	00801074 	movhi	r2,65
  4165b0:	109f3c04 	addi	r2,r2,31984
}
  4165b4:	e037883a 	mov	sp,fp
  4165b8:	dfc00117 	ldw	ra,4(sp)
  4165bc:	df000017 	ldw	fp,0(sp)
  4165c0:	dec00204 	addi	sp,sp,8
  4165c4:	f800283a 	ret

004165c8 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  4165c8:	defffb04 	addi	sp,sp,-20
  4165cc:	dfc00415 	stw	ra,16(sp)
  4165d0:	df000315 	stw	fp,12(sp)
  4165d4:	dc000215 	stw	r16,8(sp)
  4165d8:	df000304 	addi	fp,sp,12
  4165dc:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  4165e0:	e0bffe17 	ldw	r2,-8(fp)
  4165e4:	10800217 	ldw	r2,8(r2)
  4165e8:	10d00034 	orhi	r3,r2,16384
  4165ec:	e0bffe17 	ldw	r2,-8(fp)
  4165f0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  4165f4:	e03ffd15 	stw	zero,-12(fp)
  4165f8:	00002306 	br	416688 <alt_file_locked+0xc0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  4165fc:	04001074 	movhi	r16,65
  416600:	841d9f04 	addi	r16,r16,30332
  416604:	e0bffd17 	ldw	r2,-12(fp)
  416608:	1009883a 	mov	r4,r2
  41660c:	01400304 	movi	r5,12
  416610:	04123e00 	call	4123e0 <__mulsi3>
  416614:	8085883a 	add	r2,r16,r2
  416618:	10c00017 	ldw	r3,0(r2)
  41661c:	e0bffe17 	ldw	r2,-8(fp)
  416620:	10800017 	ldw	r2,0(r2)
  416624:	1880151e 	bne	r3,r2,41667c <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  416628:	04001074 	movhi	r16,65
  41662c:	841d9f04 	addi	r16,r16,30332
  416630:	e0bffd17 	ldw	r2,-12(fp)
  416634:	1009883a 	mov	r4,r2
  416638:	01400304 	movi	r5,12
  41663c:	04123e00 	call	4123e0 <__mulsi3>
  416640:	10800204 	addi	r2,r2,8
  416644:	8085883a 	add	r2,r16,r2
  416648:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  41664c:	10000b0e 	bge	r2,zero,41667c <alt_file_locked+0xb4>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  416650:	e13ffd17 	ldw	r4,-12(fp)
  416654:	01400304 	movi	r5,12
  416658:	04123e00 	call	4123e0 <__mulsi3>
  41665c:	1007883a 	mov	r3,r2
  416660:	00801074 	movhi	r2,65
  416664:	109d9f04 	addi	r2,r2,30332
  416668:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  41666c:	e0bffe17 	ldw	r2,-8(fp)
  416670:	18800226 	beq	r3,r2,41667c <alt_file_locked+0xb4>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  416674:	00bffcc4 	movi	r2,-13
  416678:	00000a06 	br	4166a4 <alt_file_locked+0xdc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  41667c:	e0bffd17 	ldw	r2,-12(fp)
  416680:	10800044 	addi	r2,r2,1
  416684:	e0bffd15 	stw	r2,-12(fp)
  416688:	00801074 	movhi	r2,65
  41668c:	109e0604 	addi	r2,r2,30744
  416690:	10800017 	ldw	r2,0(r2)
  416694:	1007883a 	mov	r3,r2
  416698:	e0bffd17 	ldw	r2,-12(fp)
  41669c:	18bfd72e 	bgeu	r3,r2,4165fc <_gp+0xffff6e00>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  4166a0:	0005883a 	mov	r2,zero
}
  4166a4:	e6ffff04 	addi	sp,fp,-4
  4166a8:	dfc00217 	ldw	ra,8(sp)
  4166ac:	df000117 	ldw	fp,4(sp)
  4166b0:	dc000017 	ldw	r16,0(sp)
  4166b4:	dec00304 	addi	sp,sp,12
  4166b8:	f800283a 	ret

004166bc <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  4166bc:	defff604 	addi	sp,sp,-40
  4166c0:	dfc00915 	stw	ra,36(sp)
  4166c4:	df000815 	stw	fp,32(sp)
  4166c8:	df000804 	addi	fp,sp,32
  4166cc:	e13ffd15 	stw	r4,-12(fp)
  4166d0:	e17ffe15 	stw	r5,-8(fp)
  4166d4:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  4166d8:	00bfffc4 	movi	r2,-1
  4166dc:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  4166e0:	00bffb44 	movi	r2,-19
  4166e4:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  4166e8:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  4166ec:	e13ffd17 	ldw	r4,-12(fp)
  4166f0:	01401074 	movhi	r5,65
  4166f4:	295e0404 	addi	r5,r5,30736
  4166f8:	0416c5c0 	call	416c5c <alt_find_dev>
  4166fc:	e0bff815 	stw	r2,-32(fp)
  416700:	e0bff817 	ldw	r2,-32(fp)
  416704:	1000051e 	bne	r2,zero,41671c <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  416708:	e13ffd17 	ldw	r4,-12(fp)
  41670c:	0416cec0 	call	416cec <alt_find_file>
  416710:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  416714:	00800044 	movi	r2,1
  416718:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  41671c:	e0bff817 	ldw	r2,-32(fp)
  416720:	10002b26 	beq	r2,zero,4167d0 <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
  416724:	e13ff817 	ldw	r4,-32(fp)
  416728:	0416e000 	call	416e00 <alt_get_fd>
  41672c:	e0bff915 	stw	r2,-28(fp)
  416730:	e0bff917 	ldw	r2,-28(fp)
  416734:	1000030e 	bge	r2,zero,416744 <open+0x88>
    {
      status = index;
  416738:	e0bff917 	ldw	r2,-28(fp)
  41673c:	e0bffa15 	stw	r2,-24(fp)
  416740:	00002506 	br	4167d8 <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
  416744:	e13ff917 	ldw	r4,-28(fp)
  416748:	01400304 	movi	r5,12
  41674c:	04123e00 	call	4123e0 <__mulsi3>
  416750:	1007883a 	mov	r3,r2
  416754:	00801074 	movhi	r2,65
  416758:	109d9f04 	addi	r2,r2,30332
  41675c:	1885883a 	add	r2,r3,r2
  416760:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  416764:	e0fffe17 	ldw	r3,-8(fp)
  416768:	00900034 	movhi	r2,16384
  41676c:	10bfffc4 	addi	r2,r2,-1
  416770:	1886703a 	and	r3,r3,r2
  416774:	e0bffc17 	ldw	r2,-16(fp)
  416778:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  41677c:	e0bffb17 	ldw	r2,-20(fp)
  416780:	1000051e 	bne	r2,zero,416798 <open+0xdc>
  416784:	e13ffc17 	ldw	r4,-16(fp)
  416788:	04165c80 	call	4165c8 <alt_file_locked>
  41678c:	e0bffa15 	stw	r2,-24(fp)
  416790:	e0bffa17 	ldw	r2,-24(fp)
  416794:	10001016 	blt	r2,zero,4167d8 <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  416798:	e0bff817 	ldw	r2,-32(fp)
  41679c:	10800317 	ldw	r2,12(r2)
  4167a0:	10000826 	beq	r2,zero,4167c4 <open+0x108>
  4167a4:	e0bff817 	ldw	r2,-32(fp)
  4167a8:	10800317 	ldw	r2,12(r2)
  4167ac:	e13ffc17 	ldw	r4,-16(fp)
  4167b0:	e17ffd17 	ldw	r5,-12(fp)
  4167b4:	e1bffe17 	ldw	r6,-8(fp)
  4167b8:	e1ffff17 	ldw	r7,-4(fp)
  4167bc:	103ee83a 	callr	r2
  4167c0:	00000106 	br	4167c8 <open+0x10c>
  4167c4:	0005883a 	mov	r2,zero
  4167c8:	e0bffa15 	stw	r2,-24(fp)
  4167cc:	00000206 	br	4167d8 <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
  4167d0:	00bffb44 	movi	r2,-19
  4167d4:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  4167d8:	e0bffa17 	ldw	r2,-24(fp)
  4167dc:	1000090e 	bge	r2,zero,416804 <open+0x148>
  {
    alt_release_fd (index);  
  4167e0:	e13ff917 	ldw	r4,-28(fp)
  4167e4:	041681c0 	call	41681c <alt_release_fd>
    ALT_ERRNO = -status;
  4167e8:	04165780 	call	416578 <alt_get_errno>
  4167ec:	1007883a 	mov	r3,r2
  4167f0:	e0bffa17 	ldw	r2,-24(fp)
  4167f4:	0085c83a 	sub	r2,zero,r2
  4167f8:	18800015 	stw	r2,0(r3)
    return -1;
  4167fc:	00bfffc4 	movi	r2,-1
  416800:	00000106 	br	416808 <open+0x14c>
  }
  
  /* return the reference upon success */

  return index;
  416804:	e0bff917 	ldw	r2,-28(fp)
}
  416808:	e037883a 	mov	sp,fp
  41680c:	dfc00117 	ldw	ra,4(sp)
  416810:	df000017 	ldw	fp,0(sp)
  416814:	dec00204 	addi	sp,sp,8
  416818:	f800283a 	ret

0041681c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  41681c:	defffc04 	addi	sp,sp,-16
  416820:	dfc00315 	stw	ra,12(sp)
  416824:	df000215 	stw	fp,8(sp)
  416828:	dc000115 	stw	r16,4(sp)
  41682c:	df000204 	addi	fp,sp,8
  416830:	e13ffe15 	stw	r4,-8(fp)
  if (fd > 2)
  416834:	e0bffe17 	ldw	r2,-8(fp)
  416838:	108000d0 	cmplti	r2,r2,3
  41683c:	1000111e 	bne	r2,zero,416884 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
  416840:	04001074 	movhi	r16,65
  416844:	841d9f04 	addi	r16,r16,30332
  416848:	e0bffe17 	ldw	r2,-8(fp)
  41684c:	1009883a 	mov	r4,r2
  416850:	01400304 	movi	r5,12
  416854:	04123e00 	call	4123e0 <__mulsi3>
  416858:	10800204 	addi	r2,r2,8
  41685c:	8085883a 	add	r2,r16,r2
  416860:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  416864:	04001074 	movhi	r16,65
  416868:	841d9f04 	addi	r16,r16,30332
  41686c:	e0bffe17 	ldw	r2,-8(fp)
  416870:	1009883a 	mov	r4,r2
  416874:	01400304 	movi	r5,12
  416878:	04123e00 	call	4123e0 <__mulsi3>
  41687c:	8085883a 	add	r2,r16,r2
  416880:	10000015 	stw	zero,0(r2)
  }
}
  416884:	e6ffff04 	addi	sp,fp,-4
  416888:	dfc00217 	ldw	ra,8(sp)
  41688c:	df000117 	ldw	fp,4(sp)
  416890:	dc000017 	ldw	r16,0(sp)
  416894:	dec00304 	addi	sp,sp,12
  416898:	f800283a 	ret

0041689c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  41689c:	defffa04 	addi	sp,sp,-24
  4168a0:	df000515 	stw	fp,20(sp)
  4168a4:	df000504 	addi	fp,sp,20
  4168a8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4168ac:	0005303a 	rdctl	r2,status
  4168b0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4168b4:	e0fffc17 	ldw	r3,-16(fp)
  4168b8:	00bfff84 	movi	r2,-2
  4168bc:	1884703a 	and	r2,r3,r2
  4168c0:	1001703a 	wrctl	status,r2
  
  return context;
  4168c4:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  4168c8:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  4168cc:	e0bfff17 	ldw	r2,-4(fp)
  4168d0:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  4168d4:	e0bffd17 	ldw	r2,-12(fp)
  4168d8:	10800017 	ldw	r2,0(r2)
  4168dc:	e0fffd17 	ldw	r3,-12(fp)
  4168e0:	18c00117 	ldw	r3,4(r3)
  4168e4:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  4168e8:	e0bffd17 	ldw	r2,-12(fp)
  4168ec:	10800117 	ldw	r2,4(r2)
  4168f0:	e0fffd17 	ldw	r3,-12(fp)
  4168f4:	18c00017 	ldw	r3,0(r3)
  4168f8:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  4168fc:	e0bffd17 	ldw	r2,-12(fp)
  416900:	e0fffd17 	ldw	r3,-12(fp)
  416904:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  416908:	e0bffd17 	ldw	r2,-12(fp)
  41690c:	e0fffd17 	ldw	r3,-12(fp)
  416910:	10c00015 	stw	r3,0(r2)
  416914:	e0bffb17 	ldw	r2,-20(fp)
  416918:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  41691c:	e0bffe17 	ldw	r2,-8(fp)
  416920:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  416924:	e037883a 	mov	sp,fp
  416928:	df000017 	ldw	fp,0(sp)
  41692c:	dec00104 	addi	sp,sp,4
  416930:	f800283a 	ret

00416934 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  416934:	defffb04 	addi	sp,sp,-20
  416938:	dfc00415 	stw	ra,16(sp)
  41693c:	df000315 	stw	fp,12(sp)
  416940:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  416944:	d0a00b17 	ldw	r2,-32724(gp)
  416948:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  41694c:	d0a13c17 	ldw	r2,-31504(gp)
  416950:	10800044 	addi	r2,r2,1
  416954:	d0a13c15 	stw	r2,-31504(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  416958:	00002e06 	br	416a14 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  41695c:	e0bffd17 	ldw	r2,-12(fp)
  416960:	10800017 	ldw	r2,0(r2)
  416964:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  416968:	e0bffd17 	ldw	r2,-12(fp)
  41696c:	10800403 	ldbu	r2,16(r2)
  416970:	10803fcc 	andi	r2,r2,255
  416974:	10000426 	beq	r2,zero,416988 <alt_tick+0x54>
  416978:	d0a13c17 	ldw	r2,-31504(gp)
  41697c:	1000021e 	bne	r2,zero,416988 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  416980:	e0bffd17 	ldw	r2,-12(fp)
  416984:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  416988:	e0bffd17 	ldw	r2,-12(fp)
  41698c:	10800217 	ldw	r2,8(r2)
  416990:	d0e13c17 	ldw	r3,-31504(gp)
  416994:	18801d36 	bltu	r3,r2,416a0c <alt_tick+0xd8>
  416998:	e0bffd17 	ldw	r2,-12(fp)
  41699c:	10800403 	ldbu	r2,16(r2)
  4169a0:	10803fcc 	andi	r2,r2,255
  4169a4:	1000191e 	bne	r2,zero,416a0c <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  4169a8:	e0bffd17 	ldw	r2,-12(fp)
  4169ac:	10800317 	ldw	r2,12(r2)
  4169b0:	e0fffd17 	ldw	r3,-12(fp)
  4169b4:	18c00517 	ldw	r3,20(r3)
  4169b8:	1809883a 	mov	r4,r3
  4169bc:	103ee83a 	callr	r2
  4169c0:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  4169c4:	e0bfff17 	ldw	r2,-4(fp)
  4169c8:	1000031e 	bne	r2,zero,4169d8 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  4169cc:	e13ffd17 	ldw	r4,-12(fp)
  4169d0:	041689c0 	call	41689c <alt_alarm_stop>
  4169d4:	00000d06 	br	416a0c <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  4169d8:	e0bffd17 	ldw	r2,-12(fp)
  4169dc:	10c00217 	ldw	r3,8(r2)
  4169e0:	e0bfff17 	ldw	r2,-4(fp)
  4169e4:	1887883a 	add	r3,r3,r2
  4169e8:	e0bffd17 	ldw	r2,-12(fp)
  4169ec:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  4169f0:	e0bffd17 	ldw	r2,-12(fp)
  4169f4:	10c00217 	ldw	r3,8(r2)
  4169f8:	d0a13c17 	ldw	r2,-31504(gp)
  4169fc:	1880032e 	bgeu	r3,r2,416a0c <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  416a00:	e0bffd17 	ldw	r2,-12(fp)
  416a04:	00c00044 	movi	r3,1
  416a08:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  416a0c:	e0bffe17 	ldw	r2,-8(fp)
  416a10:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  416a14:	e0fffd17 	ldw	r3,-12(fp)
  416a18:	d0a00b04 	addi	r2,gp,-32724
  416a1c:	18bfcf1e 	bne	r3,r2,41695c <_gp+0xffff7160>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  416a20:	0001883a 	nop
}
  416a24:	e037883a 	mov	sp,fp
  416a28:	dfc00117 	ldw	ra,4(sp)
  416a2c:	df000017 	ldw	fp,0(sp)
  416a30:	dec00204 	addi	sp,sp,8
  416a34:	f800283a 	ret

00416a38 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  416a38:	deffff04 	addi	sp,sp,-4
  416a3c:	df000015 	stw	fp,0(sp)
  416a40:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  416a44:	000170fa 	wrctl	ienable,zero
}
  416a48:	e037883a 	mov	sp,fp
  416a4c:	df000017 	ldw	fp,0(sp)
  416a50:	dec00104 	addi	sp,sp,4
  416a54:	f800283a 	ret

00416a58 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  416a58:	defff404 	addi	sp,sp,-48
  416a5c:	df000b15 	stw	fp,44(sp)
  416a60:	df000b04 	addi	fp,sp,44
  416a64:	e13ffc15 	stw	r4,-16(fp)
  416a68:	e17ffd15 	stw	r5,-12(fp)
  416a6c:	e1bffe15 	stw	r6,-8(fp)
  416a70:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
  416a74:	e0ffff17 	ldw	r3,-4(fp)
  416a78:	e0bffe17 	ldw	r2,-8(fp)
  416a7c:	1885883a 	add	r2,r3,r2
  416a80:	e0bff815 	stw	r2,-32(fp)
  alt_u8 * read_end = read_data + read_length;
  416a84:	e0c00217 	ldw	r3,8(fp)
  416a88:	e0800117 	ldw	r2,4(fp)
  416a8c:	1885883a 	add	r2,r3,r2
  416a90:	e0bff915 	stw	r2,-28(fp)

  alt_u32 write_zeros = read_length;
  416a94:	e0800117 	ldw	r2,4(fp)
  416a98:	e0bff515 	stw	r2,-44(fp)
  alt_u32 read_ignore = write_length;
  416a9c:	e0bffe17 	ldw	r2,-8(fp)
  416aa0:	e0bff615 	stw	r2,-40(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
  416aa4:	00800044 	movi	r2,1
  416aa8:	e0bff715 	stw	r2,-36(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
  416aac:	e0bffc17 	ldw	r2,-16(fp)
  416ab0:	10800504 	addi	r2,r2,20
  416ab4:	1009883a 	mov	r4,r2
  416ab8:	e0bffd17 	ldw	r2,-12(fp)
  416abc:	00c00044 	movi	r3,1
  416ac0:	1884983a 	sll	r2,r3,r2
  416ac4:	20800035 	stwio	r2,0(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
  416ac8:	e0800317 	ldw	r2,12(fp)
  416acc:	1080008c 	andi	r2,r2,2
  416ad0:	1000051e 	bne	r2,zero,416ae8 <alt_avalon_spi_command+0x90>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
  416ad4:	e0bffc17 	ldw	r2,-16(fp)
  416ad8:	10800304 	addi	r2,r2,12
  416adc:	1007883a 	mov	r3,r2
  416ae0:	00810004 	movi	r2,1024
  416ae4:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
  416ae8:	e0bffc17 	ldw	r2,-16(fp)
  416aec:	10800037 	ldwio	r2,0(r2)
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  416af0:	e0bffc17 	ldw	r2,-16(fp)
  416af4:	10800204 	addi	r2,r2,8
  416af8:	10800037 	ldwio	r2,0(r2)
  416afc:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  416b00:	e0bffa17 	ldw	r2,-24(fp)
  416b04:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
  416b08:	10000226 	beq	r2,zero,416b14 <alt_avalon_spi_command+0xbc>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  416b0c:	e0bff717 	ldw	r2,-36(fp)
  416b10:	1000031e 	bne	r2,zero,416b20 <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
  416b14:	e0bffa17 	ldw	r2,-24(fp)
  416b18:	1080200c 	andi	r2,r2,128
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
  416b1c:	103ff426 	beq	r2,zero,416af0 <_gp+0xffff72f4>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
  416b20:	e0bffa17 	ldw	r2,-24(fp)
  416b24:	1080100c 	andi	r2,r2,64
  416b28:	10001e26 	beq	r2,zero,416ba4 <alt_avalon_spi_command+0x14c>
  416b2c:	e0bff717 	ldw	r2,-36(fp)
  416b30:	00801c0e 	bge	zero,r2,416ba4 <alt_avalon_spi_command+0x14c>
    {
      credits--;
  416b34:	e0bff717 	ldw	r2,-36(fp)
  416b38:	10bfffc4 	addi	r2,r2,-1
  416b3c:	e0bff715 	stw	r2,-36(fp)

      if (write_data < write_end)
  416b40:	e0ffff17 	ldw	r3,-4(fp)
  416b44:	e0bff817 	ldw	r2,-32(fp)
  416b48:	18800a2e 	bgeu	r3,r2,416b74 <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
  416b4c:	e0bffc17 	ldw	r2,-16(fp)
  416b50:	10800104 	addi	r2,r2,4
  416b54:	1009883a 	mov	r4,r2
  416b58:	e0bfff17 	ldw	r2,-4(fp)
  416b5c:	10c00044 	addi	r3,r2,1
  416b60:	e0ffff15 	stw	r3,-4(fp)
  416b64:	10800003 	ldbu	r2,0(r2)
  416b68:	10803fcc 	andi	r2,r2,255
  416b6c:	20800035 	stwio	r2,0(r4)
  416b70:	00000c06 	br	416ba4 <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
  416b74:	e0bff517 	ldw	r2,-44(fp)
  416b78:	10000826 	beq	r2,zero,416b9c <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
  416b7c:	e0bff517 	ldw	r2,-44(fp)
  416b80:	10bfffc4 	addi	r2,r2,-1
  416b84:	e0bff515 	stw	r2,-44(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
  416b88:	e0bffc17 	ldw	r2,-16(fp)
  416b8c:	10800104 	addi	r2,r2,4
  416b90:	0007883a 	mov	r3,zero
  416b94:	10c00035 	stwio	r3,0(r2)
  416b98:	00000206 	br	416ba4 <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
  416b9c:	00bf0004 	movi	r2,-1024
  416ba0:	e0bff715 	stw	r2,-36(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
  416ba4:	e0bffa17 	ldw	r2,-24(fp)
  416ba8:	1080200c 	andi	r2,r2,128
  416bac:	10001726 	beq	r2,zero,416c0c <alt_avalon_spi_command+0x1b4>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
  416bb0:	e0bffc17 	ldw	r2,-16(fp)
  416bb4:	10800037 	ldwio	r2,0(r2)
  416bb8:	e0bffb15 	stw	r2,-20(fp)

      if (read_ignore > 0)
  416bbc:	e0bff617 	ldw	r2,-40(fp)
  416bc0:	10000426 	beq	r2,zero,416bd4 <alt_avalon_spi_command+0x17c>
        read_ignore--;
  416bc4:	e0bff617 	ldw	r2,-40(fp)
  416bc8:	10bfffc4 	addi	r2,r2,-1
  416bcc:	e0bff615 	stw	r2,-40(fp)
  416bd0:	00000506 	br	416be8 <alt_avalon_spi_command+0x190>
      else
        *read_data++ = (alt_u8)rxdata;
  416bd4:	e0800217 	ldw	r2,8(fp)
  416bd8:	10c00044 	addi	r3,r2,1
  416bdc:	e0c00215 	stw	r3,8(fp)
  416be0:	e0fffb17 	ldw	r3,-20(fp)
  416be4:	10c00005 	stb	r3,0(r2)
      credits++;
  416be8:	e0bff717 	ldw	r2,-36(fp)
  416bec:	10800044 	addi	r2,r2,1
  416bf0:	e0bff715 	stw	r2,-36(fp)

      if (read_ignore == 0 && read_data == read_end)
  416bf4:	e0bff617 	ldw	r2,-40(fp)
  416bf8:	1000041e 	bne	r2,zero,416c0c <alt_avalon_spi_command+0x1b4>
  416bfc:	e0c00217 	ldw	r3,8(fp)
  416c00:	e0bff917 	ldw	r2,-28(fp)
  416c04:	1880011e 	bne	r3,r2,416c0c <alt_avalon_spi_command+0x1b4>
        break;
  416c08:	00000106 	br	416c10 <alt_avalon_spi_command+0x1b8>
    }
    
  }
  416c0c:	003fb806 	br	416af0 <_gp+0xffff72f4>

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
  416c10:	e0bffc17 	ldw	r2,-16(fp)
  416c14:	10800204 	addi	r2,r2,8
  416c18:	10800037 	ldwio	r2,0(r2)
  416c1c:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
  416c20:	e0bffa17 	ldw	r2,-24(fp)
  416c24:	1080080c 	andi	r2,r2,32
  416c28:	103ff926 	beq	r2,zero,416c10 <_gp+0xffff7414>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
  416c2c:	e0800317 	ldw	r2,12(fp)
  416c30:	1080004c 	andi	r2,r2,1
  416c34:	1000041e 	bne	r2,zero,416c48 <alt_avalon_spi_command+0x1f0>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
  416c38:	e0bffc17 	ldw	r2,-16(fp)
  416c3c:	10800304 	addi	r2,r2,12
  416c40:	0007883a 	mov	r3,zero
  416c44:	10c00035 	stwio	r3,0(r2)

  return read_length;
  416c48:	e0800117 	ldw	r2,4(fp)
}
  416c4c:	e037883a 	mov	sp,fp
  416c50:	df000017 	ldw	fp,0(sp)
  416c54:	dec00104 	addi	sp,sp,4
  416c58:	f800283a 	ret

00416c5c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  416c5c:	defffa04 	addi	sp,sp,-24
  416c60:	dfc00515 	stw	ra,20(sp)
  416c64:	df000415 	stw	fp,16(sp)
  416c68:	df000404 	addi	fp,sp,16
  416c6c:	e13ffe15 	stw	r4,-8(fp)
  416c70:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  416c74:	e0bfff17 	ldw	r2,-4(fp)
  416c78:	10800017 	ldw	r2,0(r2)
  416c7c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  416c80:	e13ffe17 	ldw	r4,-8(fp)
  416c84:	0413bbc0 	call	413bbc <strlen>
  416c88:	10800044 	addi	r2,r2,1
  416c8c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  416c90:	00000d06 	br	416cc8 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  416c94:	e0bffc17 	ldw	r2,-16(fp)
  416c98:	10c00217 	ldw	r3,8(r2)
  416c9c:	e0bffd17 	ldw	r2,-12(fp)
  416ca0:	1809883a 	mov	r4,r3
  416ca4:	e17ffe17 	ldw	r5,-8(fp)
  416ca8:	100d883a 	mov	r6,r2
  416cac:	0416f080 	call	416f08 <memcmp>
  416cb0:	1000021e 	bne	r2,zero,416cbc <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  416cb4:	e0bffc17 	ldw	r2,-16(fp)
  416cb8:	00000706 	br	416cd8 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  416cbc:	e0bffc17 	ldw	r2,-16(fp)
  416cc0:	10800017 	ldw	r2,0(r2)
  416cc4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  416cc8:	e0fffc17 	ldw	r3,-16(fp)
  416ccc:	e0bfff17 	ldw	r2,-4(fp)
  416cd0:	18bff01e 	bne	r3,r2,416c94 <_gp+0xffff7498>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  416cd4:	0005883a 	mov	r2,zero
}
  416cd8:	e037883a 	mov	sp,fp
  416cdc:	dfc00117 	ldw	ra,4(sp)
  416ce0:	df000017 	ldw	fp,0(sp)
  416ce4:	dec00204 	addi	sp,sp,8
  416ce8:	f800283a 	ret

00416cec <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  416cec:	defffb04 	addi	sp,sp,-20
  416cf0:	dfc00415 	stw	ra,16(sp)
  416cf4:	df000315 	stw	fp,12(sp)
  416cf8:	df000304 	addi	fp,sp,12
  416cfc:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  416d00:	00801074 	movhi	r2,65
  416d04:	109e0204 	addi	r2,r2,30728
  416d08:	10800017 	ldw	r2,0(r2)
  416d0c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  416d10:	00003106 	br	416dd8 <alt_find_file+0xec>
  {
    len = strlen(next->name);
  416d14:	e0bffd17 	ldw	r2,-12(fp)
  416d18:	10800217 	ldw	r2,8(r2)
  416d1c:	1009883a 	mov	r4,r2
  416d20:	0413bbc0 	call	413bbc <strlen>
  416d24:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  416d28:	e0bffd17 	ldw	r2,-12(fp)
  416d2c:	10c00217 	ldw	r3,8(r2)
  416d30:	e0bffe17 	ldw	r2,-8(fp)
  416d34:	10bfffc4 	addi	r2,r2,-1
  416d38:	1885883a 	add	r2,r3,r2
  416d3c:	10800003 	ldbu	r2,0(r2)
  416d40:	10803fcc 	andi	r2,r2,255
  416d44:	1080201c 	xori	r2,r2,128
  416d48:	10bfe004 	addi	r2,r2,-128
  416d4c:	10800bd8 	cmpnei	r2,r2,47
  416d50:	1000031e 	bne	r2,zero,416d60 <alt_find_file+0x74>
    {
      len -= 1;
  416d54:	e0bffe17 	ldw	r2,-8(fp)
  416d58:	10bfffc4 	addi	r2,r2,-1
  416d5c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  416d60:	e0bffe17 	ldw	r2,-8(fp)
  416d64:	e0ffff17 	ldw	r3,-4(fp)
  416d68:	1885883a 	add	r2,r3,r2
  416d6c:	10800003 	ldbu	r2,0(r2)
  416d70:	10803fcc 	andi	r2,r2,255
  416d74:	1080201c 	xori	r2,r2,128
  416d78:	10bfe004 	addi	r2,r2,-128
  416d7c:	10800be0 	cmpeqi	r2,r2,47
  416d80:	1000081e 	bne	r2,zero,416da4 <alt_find_file+0xb8>
  416d84:	e0bffe17 	ldw	r2,-8(fp)
  416d88:	e0ffff17 	ldw	r3,-4(fp)
  416d8c:	1885883a 	add	r2,r3,r2
  416d90:	10800003 	ldbu	r2,0(r2)
  416d94:	10803fcc 	andi	r2,r2,255
  416d98:	1080201c 	xori	r2,r2,128
  416d9c:	10bfe004 	addi	r2,r2,-128
  416da0:	10000a1e 	bne	r2,zero,416dcc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  416da4:	e0bffd17 	ldw	r2,-12(fp)
  416da8:	10c00217 	ldw	r3,8(r2)
  416dac:	e0bffe17 	ldw	r2,-8(fp)
  416db0:	1809883a 	mov	r4,r3
  416db4:	e17fff17 	ldw	r5,-4(fp)
  416db8:	100d883a 	mov	r6,r2
  416dbc:	0416f080 	call	416f08 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  416dc0:	1000021e 	bne	r2,zero,416dcc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  416dc4:	e0bffd17 	ldw	r2,-12(fp)
  416dc8:	00000806 	br	416dec <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  416dcc:	e0bffd17 	ldw	r2,-12(fp)
  416dd0:	10800017 	ldw	r2,0(r2)
  416dd4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  416dd8:	e0fffd17 	ldw	r3,-12(fp)
  416ddc:	00801074 	movhi	r2,65
  416de0:	109e0204 	addi	r2,r2,30728
  416de4:	18bfcb1e 	bne	r3,r2,416d14 <_gp+0xffff7518>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  416de8:	0005883a 	mov	r2,zero
}
  416dec:	e037883a 	mov	sp,fp
  416df0:	dfc00117 	ldw	ra,4(sp)
  416df4:	df000017 	ldw	fp,0(sp)
  416df8:	dec00204 	addi	sp,sp,8
  416dfc:	f800283a 	ret

00416e00 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  416e00:	defffa04 	addi	sp,sp,-24
  416e04:	dfc00515 	stw	ra,20(sp)
  416e08:	df000415 	stw	fp,16(sp)
  416e0c:	dc000315 	stw	r16,12(sp)
  416e10:	df000404 	addi	fp,sp,16
  416e14:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
  416e18:	00bffa04 	movi	r2,-24
  416e1c:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  416e20:	e03ffc15 	stw	zero,-16(fp)
  416e24:	00002106 	br	416eac <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
  416e28:	04001074 	movhi	r16,65
  416e2c:	841d9f04 	addi	r16,r16,30332
  416e30:	e0bffc17 	ldw	r2,-16(fp)
  416e34:	1009883a 	mov	r4,r2
  416e38:	01400304 	movi	r5,12
  416e3c:	04123e00 	call	4123e0 <__mulsi3>
  416e40:	8085883a 	add	r2,r16,r2
  416e44:	10800017 	ldw	r2,0(r2)
  416e48:	1000151e 	bne	r2,zero,416ea0 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
  416e4c:	04001074 	movhi	r16,65
  416e50:	841d9f04 	addi	r16,r16,30332
  416e54:	e0bffc17 	ldw	r2,-16(fp)
  416e58:	1009883a 	mov	r4,r2
  416e5c:	01400304 	movi	r5,12
  416e60:	04123e00 	call	4123e0 <__mulsi3>
  416e64:	8085883a 	add	r2,r16,r2
  416e68:	e0fffe17 	ldw	r3,-8(fp)
  416e6c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  416e70:	00801074 	movhi	r2,65
  416e74:	109e0604 	addi	r2,r2,30744
  416e78:	10c00017 	ldw	r3,0(r2)
  416e7c:	e0bffc17 	ldw	r2,-16(fp)
  416e80:	1880040e 	bge	r3,r2,416e94 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
  416e84:	00801074 	movhi	r2,65
  416e88:	109e0604 	addi	r2,r2,30744
  416e8c:	e0fffc17 	ldw	r3,-16(fp)
  416e90:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  416e94:	e0bffc17 	ldw	r2,-16(fp)
  416e98:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
  416e9c:	00000606 	br	416eb8 <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  416ea0:	e0bffc17 	ldw	r2,-16(fp)
  416ea4:	10800044 	addi	r2,r2,1
  416ea8:	e0bffc15 	stw	r2,-16(fp)
  416eac:	e0bffc17 	ldw	r2,-16(fp)
  416eb0:	10800810 	cmplti	r2,r2,32
  416eb4:	103fdc1e 	bne	r2,zero,416e28 <_gp+0xffff762c>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  416eb8:	e0bffd17 	ldw	r2,-12(fp)
}
  416ebc:	e6ffff04 	addi	sp,fp,-4
  416ec0:	dfc00217 	ldw	ra,8(sp)
  416ec4:	df000117 	ldw	fp,4(sp)
  416ec8:	dc000017 	ldw	r16,0(sp)
  416ecc:	dec00304 	addi	sp,sp,12
  416ed0:	f800283a 	ret

00416ed4 <atexit>:
  416ed4:	200b883a 	mov	r5,r4
  416ed8:	000d883a 	mov	r6,zero
  416edc:	0009883a 	mov	r4,zero
  416ee0:	000f883a 	mov	r7,zero
  416ee4:	0416f381 	jmpi	416f38 <__register_exitproc>

00416ee8 <exit>:
  416ee8:	defffe04 	addi	sp,sp,-8
  416eec:	000b883a 	mov	r5,zero
  416ef0:	dc000015 	stw	r16,0(sp)
  416ef4:	dfc00115 	stw	ra,4(sp)
  416ef8:	2021883a 	mov	r16,r4
  416efc:	04170880 	call	417088 <__call_exitprocs>
  416f00:	8009883a 	mov	r4,r16
  416f04:	04172240 	call	417224 <_exit>

00416f08 <memcmp>:
  416f08:	218d883a 	add	r6,r4,r6
  416f0c:	21800826 	beq	r4,r6,416f30 <memcmp+0x28>
  416f10:	20800003 	ldbu	r2,0(r4)
  416f14:	28c00003 	ldbu	r3,0(r5)
  416f18:	10c00226 	beq	r2,r3,416f24 <memcmp+0x1c>
  416f1c:	10c5c83a 	sub	r2,r2,r3
  416f20:	f800283a 	ret
  416f24:	21000044 	addi	r4,r4,1
  416f28:	29400044 	addi	r5,r5,1
  416f2c:	003ff706 	br	416f0c <_gp+0xffff7710>
  416f30:	0005883a 	mov	r2,zero
  416f34:	f800283a 	ret

00416f38 <__register_exitproc>:
  416f38:	00801074 	movhi	r2,65
  416f3c:	defff904 	addi	sp,sp,-28
  416f40:	109dff04 	addi	r2,r2,30716
  416f44:	dcc00315 	stw	r19,12(sp)
  416f48:	14c00017 	ldw	r19,0(r2)
  416f4c:	dc000015 	stw	r16,0(sp)
  416f50:	dd400515 	stw	r21,20(sp)
  416f54:	9c000c17 	ldw	r16,48(r19)
  416f58:	dd000415 	stw	r20,16(sp)
  416f5c:	dc800215 	stw	r18,8(sp)
  416f60:	dc400115 	stw	r17,4(sp)
  416f64:	dfc00615 	stw	ra,24(sp)
  416f68:	202b883a 	mov	r21,r4
  416f6c:	2823883a 	mov	r17,r5
  416f70:	3029883a 	mov	r20,r6
  416f74:	3825883a 	mov	r18,r7
  416f78:	8000021e 	bne	r16,zero,416f84 <__register_exitproc+0x4c>
  416f7c:	9c000d04 	addi	r16,r19,52
  416f80:	9c000c15 	stw	r16,48(r19)
  416f84:	80800117 	ldw	r2,4(r16)
  416f88:	00c007c4 	movi	r3,31
  416f8c:	1880100e 	bge	r3,r2,416fd0 <__register_exitproc+0x98>
  416f90:	00800034 	movhi	r2,0
  416f94:	10800004 	addi	r2,r2,0
  416f98:	1000021e 	bne	r2,zero,416fa4 <__register_exitproc+0x6c>
  416f9c:	00bfffc4 	movi	r2,-1
  416fa0:	00003006 	br	417064 <__register_exitproc+0x12c>
  416fa4:	01002304 	movi	r4,140
  416fa8:	00000000 	call	0 <__alt_mem_epcs_flash_controller_0-0x21000>
  416fac:	1021883a 	mov	r16,r2
  416fb0:	103ffa26 	beq	r2,zero,416f9c <_gp+0xffff77a0>
  416fb4:	10000115 	stw	zero,4(r2)
  416fb8:	98800c17 	ldw	r2,48(r19)
  416fbc:	80800015 	stw	r2,0(r16)
  416fc0:	9c000c15 	stw	r16,48(r19)
  416fc4:	80002215 	stw	zero,136(r16)
  416fc8:	a800071e 	bne	r21,zero,416fe8 <__register_exitproc+0xb0>
  416fcc:	00001c06 	br	417040 <__register_exitproc+0x108>
  416fd0:	a8001b26 	beq	r21,zero,417040 <__register_exitproc+0x108>
  416fd4:	80802217 	ldw	r2,136(r16)
  416fd8:	1000091e 	bne	r2,zero,417000 <__register_exitproc+0xc8>
  416fdc:	00800034 	movhi	r2,0
  416fe0:	10800004 	addi	r2,r2,0
  416fe4:	103fed26 	beq	r2,zero,416f9c <_gp+0xffff77a0>
  416fe8:	01004204 	movi	r4,264
  416fec:	00000000 	call	0 <__alt_mem_epcs_flash_controller_0-0x21000>
  416ff0:	103fea26 	beq	r2,zero,416f9c <_gp+0xffff77a0>
  416ff4:	10004015 	stw	zero,256(r2)
  416ff8:	10004115 	stw	zero,260(r2)
  416ffc:	80802215 	stw	r2,136(r16)
  417000:	81000117 	ldw	r4,4(r16)
  417004:	01400044 	movi	r5,1
  417008:	2107883a 	add	r3,r4,r4
  41700c:	18c7883a 	add	r3,r3,r3
  417010:	10c7883a 	add	r3,r2,r3
  417014:	1d000015 	stw	r20,0(r3)
  417018:	290a983a 	sll	r5,r5,r4
  41701c:	11004017 	ldw	r4,256(r2)
  417020:	2148b03a 	or	r4,r4,r5
  417024:	11004015 	stw	r4,256(r2)
  417028:	1c802015 	stw	r18,128(r3)
  41702c:	00c00084 	movi	r3,2
  417030:	a8c0031e 	bne	r21,r3,417040 <__register_exitproc+0x108>
  417034:	10c04117 	ldw	r3,260(r2)
  417038:	194ab03a 	or	r5,r3,r5
  41703c:	11404115 	stw	r5,260(r2)
  417040:	80800117 	ldw	r2,4(r16)
  417044:	10c00044 	addi	r3,r2,1
  417048:	10800084 	addi	r2,r2,2
  41704c:	1085883a 	add	r2,r2,r2
  417050:	1085883a 	add	r2,r2,r2
  417054:	80c00115 	stw	r3,4(r16)
  417058:	80a1883a 	add	r16,r16,r2
  41705c:	84400015 	stw	r17,0(r16)
  417060:	0005883a 	mov	r2,zero
  417064:	dfc00617 	ldw	ra,24(sp)
  417068:	dd400517 	ldw	r21,20(sp)
  41706c:	dd000417 	ldw	r20,16(sp)
  417070:	dcc00317 	ldw	r19,12(sp)
  417074:	dc800217 	ldw	r18,8(sp)
  417078:	dc400117 	ldw	r17,4(sp)
  41707c:	dc000017 	ldw	r16,0(sp)
  417080:	dec00704 	addi	sp,sp,28
  417084:	f800283a 	ret

00417088 <__call_exitprocs>:
  417088:	00801074 	movhi	r2,65
  41708c:	109dff04 	addi	r2,r2,30716
  417090:	10800017 	ldw	r2,0(r2)
  417094:	defff304 	addi	sp,sp,-52
  417098:	ddc00a15 	stw	r23,40(sp)
  41709c:	d8800015 	stw	r2,0(sp)
  4170a0:	05c00034 	movhi	r23,0
  4170a4:	10800c04 	addi	r2,r2,48
  4170a8:	dc800515 	stw	r18,20(sp)
  4170ac:	dfc00c15 	stw	ra,48(sp)
  4170b0:	df000b15 	stw	fp,44(sp)
  4170b4:	dd800915 	stw	r22,36(sp)
  4170b8:	dd400815 	stw	r21,32(sp)
  4170bc:	dd000715 	stw	r20,28(sp)
  4170c0:	dcc00615 	stw	r19,24(sp)
  4170c4:	dc400415 	stw	r17,16(sp)
  4170c8:	dc000315 	stw	r16,12(sp)
  4170cc:	d9000115 	stw	r4,4(sp)
  4170d0:	2825883a 	mov	r18,r5
  4170d4:	d8800215 	stw	r2,8(sp)
  4170d8:	bdc00004 	addi	r23,r23,0
  4170dc:	d8800017 	ldw	r2,0(sp)
  4170e0:	dc400217 	ldw	r17,8(sp)
  4170e4:	14c00c17 	ldw	r19,48(r2)
  4170e8:	98004226 	beq	r19,zero,4171f4 <__call_exitprocs+0x16c>
  4170ec:	9c000117 	ldw	r16,4(r19)
  4170f0:	00900034 	movhi	r2,16384
  4170f4:	10bfffc4 	addi	r2,r2,-1
  4170f8:	9d002217 	ldw	r20,136(r19)
  4170fc:	857fffc4 	addi	r21,r16,-1
  417100:	80a1883a 	add	r16,r16,r2
  417104:	8421883a 	add	r16,r16,r16
  417108:	8421883a 	add	r16,r16,r16
  41710c:	a42d883a 	add	r22,r20,r16
  417110:	84000204 	addi	r16,r16,8
  417114:	9c21883a 	add	r16,r19,r16
  417118:	a8002616 	blt	r21,zero,4171b4 <__call_exitprocs+0x12c>
  41711c:	90000326 	beq	r18,zero,41712c <__call_exitprocs+0xa4>
  417120:	a0002026 	beq	r20,zero,4171a4 <__call_exitprocs+0x11c>
  417124:	b1002017 	ldw	r4,128(r22)
  417128:	24801e1e 	bne	r4,r18,4171a4 <__call_exitprocs+0x11c>
  41712c:	99000117 	ldw	r4,4(r19)
  417130:	82000017 	ldw	r8,0(r16)
  417134:	213fffc4 	addi	r4,r4,-1
  417138:	a900021e 	bne	r21,r4,417144 <__call_exitprocs+0xbc>
  41713c:	9d400115 	stw	r21,4(r19)
  417140:	00000106 	br	417148 <__call_exitprocs+0xc0>
  417144:	80000015 	stw	zero,0(r16)
  417148:	40001626 	beq	r8,zero,4171a4 <__call_exitprocs+0x11c>
  41714c:	9f000117 	ldw	fp,4(r19)
  417150:	a0000526 	beq	r20,zero,417168 <__call_exitprocs+0xe0>
  417154:	00800044 	movi	r2,1
  417158:	1552983a 	sll	r9,r2,r21
  41715c:	a1404017 	ldw	r5,256(r20)
  417160:	494a703a 	and	r5,r9,r5
  417164:	2800021e 	bne	r5,zero,417170 <__call_exitprocs+0xe8>
  417168:	403ee83a 	callr	r8
  41716c:	00000906 	br	417194 <__call_exitprocs+0x10c>
  417170:	a1004117 	ldw	r4,260(r20)
  417174:	4908703a 	and	r4,r9,r4
  417178:	2000041e 	bne	r4,zero,41718c <__call_exitprocs+0x104>
  41717c:	d9000117 	ldw	r4,4(sp)
  417180:	b1400017 	ldw	r5,0(r22)
  417184:	403ee83a 	callr	r8
  417188:	00000206 	br	417194 <__call_exitprocs+0x10c>
  41718c:	b1000017 	ldw	r4,0(r22)
  417190:	403ee83a 	callr	r8
  417194:	99000117 	ldw	r4,4(r19)
  417198:	e13fd01e 	bne	fp,r4,4170dc <_gp+0xffff78e0>
  41719c:	89000017 	ldw	r4,0(r17)
  4171a0:	24ffce1e 	bne	r4,r19,4170dc <_gp+0xffff78e0>
  4171a4:	ad7fffc4 	addi	r21,r21,-1
  4171a8:	b5bfff04 	addi	r22,r22,-4
  4171ac:	843fff04 	addi	r16,r16,-4
  4171b0:	003fd906 	br	417118 <_gp+0xffff791c>
  4171b4:	b8000f26 	beq	r23,zero,4171f4 <__call_exitprocs+0x16c>
  4171b8:	99400117 	ldw	r5,4(r19)
  4171bc:	99000017 	ldw	r4,0(r19)
  4171c0:	2800091e 	bne	r5,zero,4171e8 <__call_exitprocs+0x160>
  4171c4:	20000826 	beq	r4,zero,4171e8 <__call_exitprocs+0x160>
  4171c8:	89000015 	stw	r4,0(r17)
  4171cc:	a0000226 	beq	r20,zero,4171d8 <__call_exitprocs+0x150>
  4171d0:	a009883a 	mov	r4,r20
  4171d4:	00000000 	call	0 <__alt_mem_epcs_flash_controller_0-0x21000>
  4171d8:	9809883a 	mov	r4,r19
  4171dc:	00000000 	call	0 <__alt_mem_epcs_flash_controller_0-0x21000>
  4171e0:	8cc00017 	ldw	r19,0(r17)
  4171e4:	003fc006 	br	4170e8 <_gp+0xffff78ec>
  4171e8:	9823883a 	mov	r17,r19
  4171ec:	2027883a 	mov	r19,r4
  4171f0:	003fbd06 	br	4170e8 <_gp+0xffff78ec>
  4171f4:	dfc00c17 	ldw	ra,48(sp)
  4171f8:	df000b17 	ldw	fp,44(sp)
  4171fc:	ddc00a17 	ldw	r23,40(sp)
  417200:	dd800917 	ldw	r22,36(sp)
  417204:	dd400817 	ldw	r21,32(sp)
  417208:	dd000717 	ldw	r20,28(sp)
  41720c:	dcc00617 	ldw	r19,24(sp)
  417210:	dc800517 	ldw	r18,20(sp)
  417214:	dc400417 	ldw	r17,16(sp)
  417218:	dc000317 	ldw	r16,12(sp)
  41721c:	dec00d04 	addi	sp,sp,52
  417220:	f800283a 	ret

00417224 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  417224:	defffd04 	addi	sp,sp,-12
  417228:	df000215 	stw	fp,8(sp)
  41722c:	df000204 	addi	fp,sp,8
  417230:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  417234:	0001883a 	nop
  417238:	e0bfff17 	ldw	r2,-4(fp)
  41723c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  417240:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  417244:	10000226 	beq	r2,zero,417250 <_exit+0x2c>
    ALT_SIM_FAIL();
  417248:	002af070 	cmpltui	zero,zero,43969
  41724c:	00000106 	br	417254 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  417250:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  417254:	003fff06 	br	417254 <_gp+0xffff7a58>
